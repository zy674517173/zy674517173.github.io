<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件测试学习</title>
    <link href="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试-黑马"><a href="#软件测试-黑马" class="headerlink" title="软件测试-黑马"></a>软件测试-黑马</h1><h2 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h2><h3 id="1、测试介绍"><a href="#1、测试介绍" class="headerlink" title="1、测试介绍"></a>1、测试介绍</h3><h4 id="1-1-什么是软件测试"><a href="#1-1-什么是软件测试" class="headerlink" title="1.1 什么是软件测试"></a>1.1 什么是软件测试</h4><p>使⽤技术⼿段验证软件是否满⾜需求</p><h4 id="1-2-测试主流技能"><a href="#1-2-测试主流技能" class="headerlink" title="1.2 测试主流技能"></a>1.2 测试主流技能</h4><ol><li>功能测试：测试主要验证程序的功能是否满足需求</li><li>自动化测试：使用代码或工具代替手工，对项目进行测试</li><li>接口测试：使用代码或工具验证程序中的接口是否访问正常</li><li>性能测试：模拟多人使用软件，查找服务器缺陷</li></ol><p>主流方向建议：</p><ol><li>功能测试 + 接口测试</li><li>自动化测试 + 接口</li><li>功能 + 性能</li></ol><h3 id="2、测试常用分类"><a href="#2、测试常用分类" class="headerlink" title="2、测试常用分类"></a>2、测试常用分类</h3><p>分类</p><ul><li>阶段划分：（软件产出过程顺序）</li><li>代码可见度</li></ul><h4 id="2-1-阶段划分"><a href="#2-1-阶段划分" class="headerlink" title="2.1 阶段划分"></a>2.1 阶段划分</h4><ul><li>单元测试：针对程序源代码进行测试（单元：最小独立功能代码段）</li><li>集成测试：针对单元与单元之间的接口进行测试（又叫接口测试）</li><li>系统测试：针对系统整体功能+兼容+文档（说明、安装文档）</li><li>验收测试：主要分为内测、公测，使用不同的人群来发掘项目缺陷</li></ul><h4 id="2-2-代码可见度划分"><a href="#2-2-代码可见度划分" class="headerlink" title="2.2 代码可见度划分"></a>2.2 代码可见度划分</h4><ul><li>黑盒测试：看不见源代码，主要对<strong>程序功能</strong>进行测试。                                                      主要针对功能（阶段划分-&gt;系统测试）</li><li>灰盒测试：看见部分代码，主要对<strong>程序接口</strong>进行测试。                                                      主要接口测试（阶段划分-&gt;集成测试）</li><li>白盒测试：看见全部代码，主要对<strong>程序源代码</strong>进行测试。                                                      主要程序源代码（阶段划分-&gt;单元测试）</li></ul><h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><ul><li>系统测试和⿊盒测试重点核⼼是功能测试 </li><li>集成测试和灰盒测试⼜称接⼝测试  </li><li>单元测试和⽩盒测试是对代码进⾏测试 </li><li>⾃动化测试归属功能测试 </li><li>性能测试、安全测试归属专项测试</li></ul><h3 id="3、模型"><a href="#3、模型" class="headerlink" title="3、模型"></a>3、模型</h3><p>角度</p><ul><li>质量模型</li><li>测试模型</li></ul><h4 id="3-1-质量模型"><a href="#3-1-质量模型" class="headerlink" title="3.1 质量模型"></a>3.1 质量模型</h4><p>软件质量模型 ISO&#x2F;IEC 25010</p><p>说明：质量模型能告诉我们，测试时应该考虑的方面</p><ol><li>功能性</li><li>性能效率</li><li>兼容性：多种浏览器内核、操作系统、手机</li><li>易用性：简洁、友好、流畅、美观</li><li>可靠性：出现无响应、相应时间慢</li><li>信息安全</li><li>可维护性：</li><li>可移植性</li></ol><h3 id="4、测试流程"><a href="#4、测试流程" class="headerlink" title="4、测试流程"></a>4、测试流程</h3><ol><li><p>需求分析：确保各部门需求理解一致</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">前提：阅读<span class="hljs-number">1</span>遍需求⽂档，记录不明确之处。<br>参与⼈员：前端、后端、测试、产品<br>⽬的：<br><span class="hljs-number">1</span>、确保各部⻔需求理解⼀致<br><span class="hljs-number">2</span>、各⻆⾊对需求进⾏查漏补缺<br><span class="hljs-number">3</span>、了解软件有些功能<br>提示：需求分析阶段-&gt;软件还未实现（刚⽴项）<br></code></pre></td></tr></table></figure></li><li><p>计划编写：测什么、谁来测、怎么测</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">说明：指导测试执⾏的⽂档（重要）<br>测什么（⽬标、范围）<br>谁来测（⼈员进度及安排）<br>怎么测（测试⼯具、测试策略）<br></code></pre></td></tr></table></figure></li><li><p>用例设计：验证项目是否符合需求的操作的文档</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">说明：保证能准确验证软件测试点执⾏的⽂档。<br>1、分析需求<br>2、提取测试点<br>3、设计⽤例覆盖测试点<br></code></pre></td></tr></table></figure></li><li><p>用例执行：项目模块开发完成开始执行用例文档实施测试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">说明：实施测试<br></code></pre></td></tr></table></figure></li><li><p>缺陷管理：对缺陷进行管理的过程（提交、回归、关闭）</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">提交-&gt;验证-&gt;关闭<br></code></pre></td></tr></table></figure></li><li><p>测试报告：实施测试结果文档</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>、<span class="hljs-keyword">bug分析及统计</span><br><span class="hljs-keyword"></span><span class="hljs-number">2</span>、测试中遇到的问题<br><span class="hljs-number">3</span>、测试总结（本次测试中的优点和不⾜）<br></code></pre></td></tr></table></figure></li></ol><h3 id="5、测试用例"><a href="#5、测试用例" class="headerlink" title="5、测试用例"></a>5、测试用例</h3><p>是为测试项目而设计的执行文档</p><p>用例：<strong>用</strong>户使用的案例，</p><p>用例的作用：</p><ol><li>防止漏测</li><li>衡量软件是否通过标准</li></ol><h4 id="5-1-八大要素编写规范"><a href="#5-1-八大要素编写规范" class="headerlink" title="5.1 八大要素编写规范"></a>5.1 八大要素编写规范</h4><ul><li>用例编号：项目  模块  编号</li><li>用例标题：预期结果（测试点）</li><li>模块&#x2F;项目：所属项目或板块</li><li>前置条件：要执行此条案例，有那些前置操作</li><li>优先级：表示用例的重要程度或者影响力 P0~P4 (P0最高)</li><li>测试步骤：描述操作步骤</li><li>测试数据：操作的数据，没有的话可以为空</li><li>预期结果：期望达到的结果</li></ul><h4 id="5-2-练习案例"><a href="#5-2-练习案例" class="headerlink" title="5.2 练习案例"></a>5.2 练习案例</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/QQ%E7%99%BB%E9%99%86%E6%B5%8B%E8%AF%95.png" class=""><table><thead><tr><th align="center">项目模块编号</th><th align="center">用例标题</th><th>项目&#x2F;模块</th><th>优先级</th><th>前置条件</th><th>测试步骤</th><th>测试数据</th><th align="center">预期结果</th></tr></thead><tbody><tr><td align="center">qq_login_001</td><td align="center">登陆失败（账号为空）</td><td>登陆</td><td>P1</td><td>1、打开QQ登陆界面<br />2、账号已注册</td><td>1、输入账号<br />2、输入密码<br />3、点击登陆</td><td>1、账号：为空<br />2、密码：12345</td><td align="center">登陆失败。提示：账号不能为空</td></tr><tr><td align="center">qq_login_002</td><td align="center">登陆失败（账号未注册）</td><td>登陆</td><td>P1</td><td>1、打开QQ登陆界面<br />2、账号未注册</td><td>1、输入账号<br />2、输入密码<br />3、点击登陆</td><td>1、账号：未注册正确格式账号<br />2、密码：12345</td><td align="center">登陆失败。提示：账号不存在</td></tr><tr><td align="center">qq_login_003</td><td align="center">登陆失败（密码为空）</td><td>登陆</td><td>P1</td><td>1、打开QQ登陆界面<br />2、账号已注册</td><td>1、输入账号<br />2、输入密码<br />3、点击登陆</td><td>1、账号：正确账号<br />2、密码：12345</td><td align="center">登陆失败。提示：密码不能为空</td></tr><tr><td align="center">qq_login_004</td><td align="center">登陆失败（密码错误）</td><td>登陆</td><td>P1</td><td>1、打开QQ登陆界面<br />2、账号已注册</td><td>1、输入账号<br />2、输入密码<br />3、点击登陆</td><td>1、账号：正确账号<br />2、密码：错误密码</td><td align="center">登陆失败。提示：密码不正确</td></tr></tbody></table><h3 id="6、用例设计方法"><a href="#6、用例设计方法" class="headerlink" title="6、用例设计方法"></a>6、用例设计方法</h3><p>目标</p><ol><li>能对穷举场景设计测试点</li><li>能对限定边界规则设计测试点</li><li>能对多条件依赖关系进行设计测试点</li><li>能对于项目业务进行设计测试点</li></ol><h4 id="6-1-等价类划分"><a href="#6-1-等价类划分" class="headerlink" title="6.1 等价类划分"></a>6.1 等价类划分</h4><p>说明：在所有测试数据中，具有某种共同特征的数据集合进行划分</p><p>分类：有效等价类、无效等价类</p><p><strong>步骤</strong></p><ol><li>明确需求</li><li>确定有效等价类 和 无效等价类       长度、类型、规则</li><li>提取数据编写测试用例</li></ol><h4 id="6-2-边界值分析法"><a href="#6-2-边界值分析法" class="headerlink" title="6.2 边界值分析法"></a>6.2 边界值分析法</h4><p>选取正好等于、刚好大于、刚好小于边界的值作为测试数据</p><ul><li>上点：边界上的点（正好等于） （绿色） 必选</li><li>离店：距离上点最近的点（刚好大于、刚好小于）  （黄色）    必选</li><li>内点：范围内的点（区间范围内的数据）   （蓝色）                 开内闭外</li></ul><p>开内闭外举例（用于优化边界值数量）</p><p>需求：20 &lt;&#x3D; b &lt; 60</p><p>上点：20、60</p><p>内点：30</p><p>离点：19、59</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95.png" class=""><p>边界值能解决位数限制问题，但是不能解决类型问题（要结合等价类）</p><p><strong>步骤</strong></p><ol><li>明确需求</li><li>确定有效和无效等价类             </li><li>确定边界范围值</li><li>提取数据编写测试用例</li></ol><p>类型用等价类、长度用边界值</p><h4 id="6-3-判定表法"><a href="#6-3-判定表法" class="headerlink" title="6.3 判定表法"></a>6.3 判定表法</h4><p>案例：验证 “若用户欠费或者关机，则不允许主被叫”的功能测试</p><p><strong>说明：</strong></p><ul><li>等价类边界值分析法主要关注单个输入类条件的测试</li><li>并未考虑输入条件之间的各种组合、输入条件与输出结果之间有相互制约关系的测试</li></ul><p><strong>介绍</strong></p><ul><li><p>定义：是一种以表格形式表达多条件逻辑判断的工具</p></li><li><p>组成</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E5%88%A4%E5%AE%9A%E8%A1%A8%E6%B3%95%E7%BB%84%E6%88%90.png" class=""></li></ul><p><strong>规则</strong></p><ul><li>判定表中贯穿条件项和动作项的一列就是一条规则</li><li>假设有n个条件，每个条件的取值有两个(0,1)，全组合有2的n次方种规则</li></ul><p><strong>步骤</strong></p><ol><li>明确要求</li><li>画出判定表<ol><li>列出条件桩和动作桩</li><li>填写条件项、对条件进行全组合</li><li>根据条件项的组合确定动作项</li><li>简化、合并相似规则（有相同规则）</li></ol></li><li>根据规则编写测试用例</li></ol><p><strong>总结</strong></p><p>使用场景</p><ul><li>有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖(制约)关系</li><li>判定表一般适用于条件组合数量较少的情况(比如4个条件以下)</li></ul><p><strong>提示</strong>：</p><ol><li>多条件之间有依赖关系，使⽤判定表来进⾏测试覆盖。 </li><li>判定表⼀般适合4个以内条件依赖关系 </li><li>如果条件超过4个，就不适合覆盖所有条件，应采⽤（正交法）来解决。</li></ol><h4 id="6-4-场景法"><a href="#6-4-场景法" class="headerlink" title="6.4 场景法"></a>6.4 场景法</h4><p><strong>说明</strong></p><p>场景法也可以叫流程图法，是用流程图描述用户的使用场景，然后通过覆盖流程路径来设计测试用例。</p><p><strong>意义:</strong></p><ul><li>用户使用角度:用户平时使用的不是单个功能，而是多个功能组合起来进行使用</li><li>测试人员角度:平时测试的都是单个功能点进行测试，容易忽略多个功能的组合测试</li></ul><p><strong>流程图</strong></p><p>提示:业务⽤例是根据流程图来梳理的,需要先了解流程图</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%B3%95.png" class=""><p>开始都是椭圆，判断是菱形，语句是方形</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%A1%88%E4%BE%8B.png" class=""><h4 id="6-5-错误推荐法"><a href="#6-5-错误推荐法" class="headerlink" title="6.5 错误推荐法"></a>6.5 错误推荐法</h4><p>应⽤场景：当项⽬⽤例都执⾏完毕，且BUG修复完成，离上线还有⼀段时间， 在这段时间中可是使⽤错误推荐法复测主要业务或测试未覆盖的功能。</p><p>定义：通过经验推测系统可能出现的问题</p><p>场景：</p><ol><li>时间紧任务量大时，根据之前项目类似经验找出易出错的模块重点测试</li><li>时间宽裕通过该方法列出之前出现问题较多的模块再次测试</li></ol><p>思想：根据经验列举出可能出现问题的清单，根据清单分析问题可能原因，推测发现缺陷。</p><h3 id="7、缺陷"><a href="#7、缺陷" class="headerlink" title="7、缺陷"></a>7、缺陷</h3><h4 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a>7.1 定义</h4><p>软件中存在的各种问题，都为缺陷，简称bug；</p><h4 id="7-2-缺陷标准"><a href="#7-2-缺陷标准" class="headerlink" title="7.2 缺陷标准"></a>7.2 缺陷标准</h4><ol><li>少功能 </li><li>功能错误 </li><li>多功能 </li><li>缺少隐性功能 </li><li>易⽤性（软件测试⼈员专业⻆度）-不易使用</li></ol><h4 id="7-3-缺陷产生的原因"><a href="#7-3-缺陷产生的原因" class="headerlink" title="7.3 缺陷产生的原因"></a>7.3 缺陷产生的原因</h4><ol><li>需求⽂档 </li><li>架构设计 </li><li>编码实现 </li><li>环境（硬件、软件）</li></ol><h4 id="7-4-缺陷的生命周期"><a href="#7-4-缺陷的生命周期" class="headerlink" title="7.4 缺陷的生命周期"></a>7.4 缺陷的生命周期</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E7%BC%BA%E9%99%B7%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class=""><ol><li>回归测试：<ol><li>常规项⽬回归：项⽬本次发布新增2个模块，最基本要测新增模块功能及新增模块关联的旧模块。 </li><li>⾮常规项⽬（银⾏、部队、航天）：新增功能，必须全部复测。</li></ol></li><li>回归bug：上⼀个版本发现的缺陷，开发修复完毕，在下个版本进⾏重新验证。</li></ol><h4 id="7-5-缺陷的核心要素"><a href="#7-5-缺陷的核心要素" class="headerlink" title="7.5 缺陷的核心要素"></a>7.5 缺陷的核心要素</h4><ol><li>缺陷的标题：描述缺陷的核心问题</li><li>缺陷的预置条件：缺陷产生的前提</li><li>缺陷的复现步骤：复现缺陷的步骤</li><li>缺陷的预期结果：希望得到的结果</li><li>缺陷的实际结果：实际得到的结果</li><li>缺陷的必要附件：图片、日志等信息（证据）</li></ol><h4 id="7-6-缺陷提交要素"><a href="#7-6-缺陷提交要素" class="headerlink" title="7.6 缺陷提交要素"></a>7.6 缺陷提交要素</h4><ol><li>缺陷报告编号：缺陷的唯一性标志</li><li>严重程度：S1-S4，                                                                                                       S1(严重)主功能    S2(一般) 次要功能    S3(微小) 易用性、界面   S4(建议) 建议性问题</li><li>缺陷优先级：P0~P3</li><li>Bug类型：代码错误、兼容性问题、设计缺陷、性能问题</li><li>缺陷状态：new(新建)、open(打开)、closed(关闭)、postponed(延期)</li></ol><h4 id="7-7-缺陷类型"><a href="#7-7-缺陷类型" class="headerlink" title="7.7 缺陷类型"></a>7.7 缺陷类型</h4><ol><li>功能错误 </li><li>UI⻚⾯错误 </li><li>兼容性 </li><li>数据（数据库） </li><li>易⽤性 </li><li>建议 </li><li>架构缺陷</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">设计⽤例-&gt;执⾏⽤例（执⾏测试）-&gt;缺陷（提交、验证、关闭）<br>缺陷定义：任何问题（Bug）<br>缺陷标准：多功能、少功能、错误、缺少隐性功能、易⽤性<br>描述缺陷重点：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注<br>提交缺陷信息：指派⼈、缺陷等级、修复优先级、类型、状态（统计缺陷）<br></code></pre></td></tr></table></figure><h3 id="8、缺陷管理"><a href="#8、缺陷管理" class="headerlink" title="8、缺陷管理"></a>8、缺陷管理</h3><h4 id="8-1-excel示例"><a href="#8-1-excel示例" class="headerlink" title="8.1 excel示例"></a>8.1 excel示例</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/excel%E7%BC%BA%E9%99%B7%E7%A4%BA%E4%BE%8B.png" class=""><h4 id="8-2-缺陷跟踪流程"><a href="#8-2-缺陷跟踪流程" class="headerlink" title="8.2 缺陷跟踪流程"></a>8.2 缺陷跟踪流程</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E7%BC%BA%E9%99%B7%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png" class=""><h4 id="8-3-提交注意事项"><a href="#8-3-提交注意事项" class="headerlink" title="8.3 提交注意事项"></a>8.3 提交注意事项</h4><ol><li>可重现：缺陷可以复现</li><li>规范性：符合公司或者项目要求</li></ol><p><strong>面试题</strong></p><p>发现缺陷后，首先会怎么办？ 确定bug可复现，确定时bug</p><h2 id="接口自动化测试"><a href="#接口自动化测试" class="headerlink" title="接口自动化测试"></a>接口自动化测试</h2><h3 id="1、接口测试理论"><a href="#1、接口测试理论" class="headerlink" title="1、接口测试理论"></a>1、接口测试理论</h3><p>接口：系统与系统之间数据交互的通道</p><p>接口测试：校验 预期结果 与 实际结果 是否一致</p><p>特征：</p><ul><li>测试页面发现不了的问题（因为接口测试 绕过前端界面）</li><li>符合质量控制前移理念</li><li>低成本、高收益</li></ul><p>实现方式：</p><ol><li><p>工具实现</p><ul><li>Postman：使用简单。功能较少</li><li>jmeter：功能完善，上手难度大</li></ul></li><li><p>代码实现</p><ul><li>python + requests + pytest</li><li>java + httpclient</li></ul></li></ol><h3 id="2、HTTP协议"><a href="#2、HTTP协议" class="headerlink" title="2、HTTP协议"></a>2、HTTP协议</h3><p>特性： </p><ul><li>客户端、服务器模式 </li><li>简单快速 </li><li>灵活 </li><li>⽆状态 </li><li>⽆连接</li></ul><h4 id="2-1-URL-统一志愿定位符-格式"><a href="#2-1-URL-统一志愿定位符-格式" class="headerlink" title="2.1 URL (统一志愿定位符)格式"></a>2.1 URL (统一志愿定位符)格式</h4><p><strong>格式</strong>：协议：&#x2F;&#x2F; 域名：端口&#x2F;资源路径？查询参数1 &amp; 查询参数2…..</p><p>端口： http 80 https443</p><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">http://tpshop-test.itheima.net/index.php?m=Home&amp;c=User&amp;a=do_login<br></code></pre></td></tr></table></figure><h4 id="2-2-HTTP请求"><a href="#2-2-HTTP请求" class="headerlink" title="2.2 HTTP请求"></a>2.2 HTTP请求</h4><p>整体格式：</p><ul><li>请求行：http请求第一行</li><li>请求头：第二行开始，到空行之前</li><li>空行：代表请求头结束</li><li>请求体：空行之后，直到结束</li></ul><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/HTTP%E8%AF%B7%E6%B1%82.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apl">POST http://demo.zentao.net/user-login.html HTTP/1.1 <br>Host: demo.zentao.net <br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 <br>Firefox/68.0 <br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 <br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 <br>Accept-Encoding: gzip, deflate <br>Referer: http://demo.zentao.net/user-login.html <br>Content-Type: application/x-www-form-urlencoded <br>Content-Length: 54 <br>Connection: keep-alive <br>Upgrade-Insecure-Requests: 1 <br>account=demo&amp;password=efc4a3b32e48054865e5a8321cfda3e4 <br></code></pre></td></tr></table></figure><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>组成： 请求方法 （空格） URL (空格)  协议版本</p><ul><li>请求方法：<ul><li>get：查询   – 没有请求体</li><li>post：添加 （登陆、注册）</li><li>put：修改</li><li>delete：删除    – 没有请求体</li></ul></li><li>URL</li><li>协议版本：默认常用 HTTP&#x2F;1.1</li></ul><h5 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h5><p>Content-Type：描述 请求体 数据类型</p><ul><li>text&#x2F;html： HTML格式</li><li>text&#x2F;plain：纯文本格式</li><li>image&#x2F;jpeg： jpg图片格式</li><li>application&#x2F;json：请求体为 json 格式数据 </li><li>application&#x2F;x-www-form-urlencoded:  请求体为 表单 格式的数据。</li><li>multipart&#x2F;form-data： 在表单中进行文件上传时使用</li></ul><h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><p>get、delete没有，post、put有</p><p>请求体中的数据，受Content-Type的内容影响</p><h4 id="2-3-HTTP响应"><a href="#2-3-HTTP响应" class="headerlink" title="2.3 HTTP响应"></a>2.3 HTTP响应</h4><p>整体格式：</p><ul><li>响应行（第一行）: 协议版本（空格）状态码（空格）状态码描述</li><li>响应头（第二行开始，到空行结束）：</li><li>空行（表示响应头结束）</li><li>响应体（空行、直到结束）</li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apl"> HTTP/1.1 200 OK <br>Date: Fri, 22 May 2009 06:07:21 GMT <br>Content-Type: text/html; charset=UTF-8 <br>&lt;html&gt;<br>     &lt;head&gt;&lt;/head&gt; <br>    &lt;body&gt;...&lt;/body&gt; <br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><ul><li>1xx：指示性信息 </li><li>2xx：成功类信息。 200  ok </li><li>3xx：重定向类信息 </li><li>4xx：客户端错误。 404  Not Found </li><li>5xx：服务器端错误</li></ul><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><ul><li>数据组织的格式为 k:v 键值对格式。 </li><li>Content-Type：作⽤：响应体数据类型。（了解）</li></ul><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><ul><li>包含  接⼝测试过程中，需要 “实际结果” </li><li>响应体，不受 请求⽅法 影响。 绝⼤多数 响应包，都包含响应体。</li></ul><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apl">HTTP/1.1 200 OK<br>Server: nginx<br>Date: Mon, 29 Jun 2020 03:36:28 GMT<br>Content-Type: text/html; charset=UTF-8<br>Connection: keep-alive<br>Set-Cookie: is_mobile=0; expires=Mon, 29-Jun-2020 04:36:28 GMT;<br>Expires: Thu, 19 Nov 1981 08:52:00 GMT<br>Content-Length: 805<br><br>&#123;&quot;status&quot;:1,&quot;msg&quot;:&quot;\u767b\u9646\u6210\u529f&quot;,&quot;result&quot;:<br>&#123;&quot;user_id&quot;:3338,&quot;email&quot;:&quot;&quot;,&quot;password&quot;:&quot;519475228fe35ad067744465<br>c42a19b2&quot;,&quot;paypwd&quot;:null,&quot;sex&quot;:0,&quot;birthday&quot;:0,&quot;user_money&quot;:&quot;0.00<br>&quot;,&quot;frozen_money&quot;:&quot;0.00&quot;,&quot;distribut_money&quot;:&quot;0.00&quot;,&quot;underling_num<br>ber&quot;:0,&quot;pay_points&quot;:100,&quot;address_id&quot;:0,&quot;reg_time&quot;:1590980161,&quot;l<br>ast_login&quot;:1590980161,&quot;last_ip&quot;:&quot;&quot;,&quot;qq&quot;:&quot;&quot;,&quot;mobile&quot;:&quot;1380013800<br>6&quot;,&quot;level_name&quot;:&quot;\u6ce8\u518c\u4f1a\u5458&quot;&#125;,&quot;url&quot;:&quot;&quot;&#125;<br></code></pre></td></tr></table></figure><h3 id="3、接口规范"><a href="#3、接口规范" class="headerlink" title="3、接口规范"></a>3、接口规范</h3><h4 id="传统风格接口"><a href="#传统风格接口" class="headerlink" title="传统风格接口"></a>传统风格接口</h4><p>特性：</p><ul><li>请求⽅法，统⼀使⽤ get 或 post </li><li>针对⼀个资源的操作，URL 不唯⼀ </li><li>响应状态码统⼀使⽤ 200 表示</li></ul><h4 id="RESTful风格接口"><a href="#RESTful风格接口" class="headerlink" title="RESTful风格接口"></a>RESTful风格接口</h4><p>特性</p><ul><li>请求⽅法，与 http协议对应。 <ul><li>get —— 查询 </li><li>post —— 添加 </li><li>put —— 修改 </li><li>delete —— 删除</li></ul></li><li>针对⼀个资源的操作，URL 唯⼀。 只看URL ⽆法确定具体操作。 </li><li>状态码使⽤较灵活</li></ul><h3 id="4、结构测试流程"><a href="#4、结构测试流程" class="headerlink" title="4、结构测试流程"></a>4、结构测试流程</h3><ol><li>需求分析（产品经理产出的需求文档）</li><li>接口文档解析（由开发产出的接口文档）</li><li>编写接口测试用例（将用例用Excel形式表现）</li><li>编写接口测试脚本         （多这一项）<ul><li>工具（postman）生成脚本</li><li>代码（python）编写，生成脚本</li></ul></li><li>执行脚本，跟踪缺陷</li><li>生成接口测试报告</li><li>（可选）接口自动化持续集成</li></ol><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png" class=""><h4 id="4-1-接口文档解析"><a href="#4-1-接口文档解析" class="headerlink" title="4.1 接口文档解析"></a>4.1 接口文档解析</h4><ul><li><p>什么是接⼝⽂档 也叫 API⽂档，描述接⼝信息。 </p></li><li><p>接⼝⽂档的作⽤ ⽅便团队成员协同⼯作。</p></li></ul><p><strong>解析核心目标</strong></p><ul><li><p>http请求 相关数据</p><ul><li>请求⽅法 </li><li>URL </li><li>请求头 </li><li>请求体（数据类型）</li></ul></li><li><p>http响应 相关数据（预期结果） </p><ul><li>响应状态码 </li><li>响应体</li></ul><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%A7%A3%E6%9E%90.png" class=""></li></ul><h3 id="5、Postman使用"><a href="#5、Postman使用" class="headerlink" title="5、Postman使用"></a>5、Postman使用</h3><p>需要使用Postman工具构建请求头、请求行、请求体</p><h4 id="5-1-Postman断言"><a href="#5-1-Postman断言" class="headerlink" title="5.1 Postman断言"></a>5.1 Postman断言</h4><p>借助Postman工具，代替人工自动判断，预期结果和实际结果是一致的</p><p><strong>Postman常用断言</strong></p><ol><li><p>断言响应状态码</p><p><strong>Status Code： code is 200</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 断言响应状态码</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Status code is 200&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    pm.<span class="hljs-property">response</span>.<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>);<br>&#125;);<br><br>pm.<span class="hljs-property">postman</span>的一个实例（对象）<br><span class="hljs-title function_">test</span>(): postman的一个测试方法。有两个参数<br>参<span class="hljs-number">1</span>：断言完成后，给用户的提示性文字信息。可以任意修改（不参与断言）<br>    参<span class="hljs-number">2</span>：是一个 匿名函数 调用。<br>pm.<span class="hljs-property">response</span>.<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>);  postman的响应结果中应该有状态码 <span class="hljs-number">200</span><br>这里面的 <span class="hljs-number">200</span> 为 预期结果<br></code></pre></td></tr></table></figure></li><li><p>断言包含某个字符串</p><p><strong>Response body: Contains string</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 断言响应体包含某字符串</span><br>pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Body matches string&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    pm.<span class="hljs-title function_">expect</span>(pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">text</span>()).<span class="hljs-property">to</span>.<span class="hljs-title function_">include</span>(<span class="hljs-string">&quot;string_you_want_to_search&quot;</span>);<br>&#125;);<br><br><span class="hljs-attr">pm</span>:postman的一个实例<br><span class="hljs-title function_">test</span>(): postman的方法。有两个参数。<br>参<span class="hljs-number">1</span>：断言完成后，给用户的提示性文字信息。可以任意修改（不参与断言）<br>    参<span class="hljs-number">2</span>：是一个 匿名函数 调用。<br>pm.<span class="hljs-title function_">expect</span>(pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">text</span>()).<span class="hljs-property">to</span>.<span class="hljs-title function_">include</span>(<span class="hljs-string">&quot;string_you_want_to_search&quot;</span>); <br>意思是：postman期望，在响应文本中，包含 “你想搜索的字符串”<br><br><span class="hljs-string">&quot;string_you_want_to_search&quot;</span> 可以替换为，欲判断的字符串 （预期结果）<br></code></pre></td></tr></table></figure></li><li><p>断言 <code>JSON</code> 数据</p><p><strong>Response body：JSON value check</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">pm.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;断言json结果中指定key的值&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br>    pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">value</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(<span class="hljs-number">100</span>);<br>&#125;);<br><br><span class="hljs-attr">pm</span>:postman的一个实例<br><span class="hljs-title function_">test</span>(): postman的方法。有两个参数。<br>  参<span class="hljs-number">1</span>：断言完成后，给用户的提示性文字信息。可以任意修改（不参与断言）<br>    参<span class="hljs-number">2</span>：是一个 匿名函数 调用。<br><span class="hljs-keyword">var</span> jsonData = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();<br><span class="hljs-keyword">var</span> 是 js 语言中，定义变量的关键字。<br>    jsonData 是变量名<br>    pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>() 表示 postman的 json响应结果<br>    代表：<br>    &#123;<br>        <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">10000</span>,<br>        <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;操作成功！&quot;</span>,<br>        <span class="hljs-string">&quot;data&quot;</span>: <span class="hljs-string">&quot;46b1fcde-e996-4520-b8f6-a2cd2da95350&quot;</span><br>&#125;<br>pm.<span class="hljs-title function_">expect</span>(jsonData.<span class="hljs-property">value</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">eql</span>(<span class="hljs-number">100</span>);<br>value 指代 json数据中的 “key” (举例：可以取值：success 或 code 或 message 或 data)<br><span class="hljs-number">100</span>，应该替换为 key 所对应的 value (预期结果)<br></code></pre></td></tr></table></figure></li></ol><h4 id="5-2-Postman关联"><a href="#5-2-Postman关联" class="headerlink" title="5.2 Postman关联"></a>5.2 Postman关联</h4><p><strong>简介</strong></p><p>关联，是postman中，用来解决http请求之间有依赖关系时，使用的技术</p><ul><li>依赖：1个http请求响应结果中的数据，被另一个http请求使用。</li><li>举例：<ul><li>登陆http请求，返回的令牌。被添加员工请求依赖（请求头中使用）。可以使用postman的关联技术来使用。</li></ul></li></ul><p><strong>实现步骤</strong></p><p>A接口响应结果，被B接口依赖</p><ol><li>发送 A 接口请求，得到响应结果</li><li>将结果中的关联数据，存入 公共容器 （全局变量、环境变量）</li><li>B接口，从公共容器中提起数据，发送 B 接口的请求</li></ol><p><strong>核心代码</strong></p><ol><li><p>获取相应结果  &#x3D;&#x3D;var jsonData &#x3D; pm.response.json();&#x3D;&#x3D;</p></li><li><p>将数据设置到全局中、环境变量中。</p><ul><li><p>全局变量：&#x3D;&#x3D;pm.globals.set(“全局变量名”, 全局变量值)&#x3D;&#x3D;，全局变量，在整个 postman 随处都能使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 示例</span><br>pm.<span class="hljs-property">globals</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;glb_age&quot;</span>, <span class="hljs-number">22</span>)<br></code></pre></td></tr></table></figure></li><li><p>环境变量：&#x3D;&#x3D;pm.environment.set(“环境变量名”, 环境变量值)&#x3D;&#x3D;，在 特定的环境下，才能使用。因此，必须先创建环境，再创建 环境变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 示例</span><br>pm.<span class="hljs-property">environment</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;env_age&quot;</span>, <span class="hljs-number">88</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在 请求参数（URL、请求头、请求体）中 获取 变量数据 &#x3D;&#x3D;  或者 &#x3D;&#x3D;</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#123;&#123;glb<span class="hljs-built_in">_</span>age&#125;&#125; 或 &#123;&#123;env<span class="hljs-built_in">_</span>age&#125;&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="5-3-Postman参数化"><a href="#5-3-Postman参数化" class="headerlink" title="5.3 Postman参数化"></a>5.3 Postman参数化</h4><p><strong>简介</strong></p><ul><li>什么是参数化：将 http请求需要的数据，和断言数据，组织到一个 文件中。从postman导入文件，实现 http请求发送、断言。</li><li>应用场景：针对同一个接口，组织 N 条 不同的 测试用例。数据格式完全一致的。适用 参数化。</li></ul><p><strong>数据文件简介</strong></p><ol><li>CSV：</li></ol><ul><li>优点：数据组织的格式简单。</li><li>缺点：<ul><li>不支持bool类型。（原因：postman读取csv文件后，将所有的非数值数据，自动添加 “ ” 包裹）</li><li>不支持复杂数据类型。</li><li>不支持参数测试。</li></ul></li><li>应用场景：当有大量测试数据时，适用。</li></ul><ol><li>JSON：</li></ol><ul><li>优点：<ul><li>支持bool类型。</li><li>支持复杂数据类型。</li><li>支持参数测试。</li></ul></li><li>缺点：<ul><li>相同的数据量，json文件要远大于 csv文件。</li></ul></li><li>应用场景：测试数据量较少。需要进行 参数测试！</li></ul><p><strong>编写数据文件</strong></p><p><code>csv</code> 和 <code>json</code> 格式</p><p><strong>读取数据文件</strong></p><p>理论</p><p>根据 使用位置 不同，有两种方法。</p><ul><li><p>第一种：请求参数（URL、请求头、请求体）中，使用  数据文件中 的数据</p><ul><li><strong>&#x3D;&#x3D;使用包裹 csv文件第一行的字段名。或 json文件的 key名&#x3D;&#x3D;</strong></li></ul></li><li><p>第二种：代码（Tests）中，使用  数据文件中 的数据</p><ul><li><strong>&#x3D;&#x3D;使用 postman 内置 关键字 data.csv文件的字段名  或  data.json文件的key名&#x3D;&#x3D;</strong></li></ul></li></ul><p><strong>案例</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex">需求：批量查询 手机号 所属运营商，校验运营商数据正确性<br><br>接口： http://cx.shouji.360.cn/phonearea.php?number=13012345678<br><br>测试数据：<br><br>​手机号: 13012345678 运营商: 联通<br>​手机号: 13800001111 运营商: 移动<br>​手机号: 18966778899 运营商: 电信<br></code></pre></td></tr></table></figure><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E5%8F%82%E6%95%B0%E5%8C%96%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95.png" class=""><h3 id="6、接口用例设计"><a href="#6、接口用例设计" class="headerlink" title="6、接口用例设计"></a>6、接口用例设计</h3><h4 id="6-1-接口测试的测试点"><a href="#6-1-接口测试的测试点" class="headerlink" title="6.1 接口测试的测试点"></a>6.1 接口测试的测试点</h4><ul><li><p>功能测试：</p><ul><li><p>单接口功能：一个接口对应一个功能：如：登陆业务——登陆接口注册业务——注册接口</p></li><li><p>业务场景功能：按用户的实际使用场景。模拟 连续调用 多个接口。测试功能正确性</p></li></ul></li><li><p>性能测试：响应时长、吞吐量、错误率、服务器资源利用率</p></li><li><p>安全测试：敏感数据是否加密、SQL注入、其他</p><ul><li>攻击安全：木马、病毒、黑客</li><li>业务安全：保证系统在业务过程中，保证 业务上没有安全漏洞、敏感数据是否加密</li></ul></li></ul><h4 id="6-2-接口用例设计方法"><a href="#6-2-接口用例设计方法" class="headerlink" title="6.2 接口用例设计方法"></a>6.2 接口用例设计方法</h4><p><strong>单接口测试</strong></p><ul><li>正向测试<ol><li>必填参数组合    P0</li><li>必选 + 非必选组合    P2&#x2F;P3</li><li>全部参数     P1</li></ol></li><li>反向测试<ol><li>功能异常（覆盖反向需求）P1密码和手机号对应不上、登陆不了 就是功能异常</li><li>数据异常（空、类型不符、长度不符）P2      【等价类、边界值测试法】</li><li>参数异常（多参、少参、错误参数） P3</li></ol></li></ul><p><strong>业务场景测试</strong></p><ul><li>必须在单接口测试完成之后</li><li>模拟用户实际使用场景，尽量用较少的测试用例，覆盖更多的接口</li><li>一般情况下，只需要设计业务场景的正向测试用例即可</li></ul><h4 id="6-3-单接口测试用例"><a href="#6-3-单接口测试用例" class="headerlink" title="6.3 单接口测试用例"></a>6.3 单接口测试用例</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E5%8D%95%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%99%BB%E9%99%86%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png" class=""><p><strong>分析测试点</strong></p><p><strong>登陆</strong>：</p><ul><li>正向<ul><li>登陆成功</li></ul></li><li>反向<ul><li>手机号未注册</li><li>密码错误</li><li>手机号为空</li><li>手机号有特殊字符、字母</li><li>10位手机号</li><li>12位手机号</li><li>密码为空</li><li>密码特殊字符、字母</li><li>1位密码</li><li>100位密码</li><li>多参</li><li>少参</li><li>无参</li><li>错误参数</li></ul></li></ul><p><strong>测试模板</strong></p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%9D%BF.png" class=""><h3 id="7、Requests模块接口测试"><a href="#7、Requests模块接口测试" class="headerlink" title="7、Requests模块接口测试"></a>7、Requests模块接口测试</h3><h4 id="7-1-设置http请求语法"><a href="#7-1-设置http请求语法" class="headerlink" title="7.1 设置http请求语法"></a>7.1 设置http请求语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">resp = requests.请求方法(url=<span class="hljs-string">&#x27;URL地址&#x27;</span>, params=&#123;k:v&#125;, headers=&#123;k:v&#125;,  <br>                    data=&#123;k:v&#125;, json=&#123;k:v&#125;, cookies=<span class="hljs-string">&#x27;cookie数据&#x27;</span>(如：令牌))<br>请求方法：<br>get请求 - get方法<br>post请求 - post方法<br>put请求 - put方法<br>delete请求 - delete方法<br>    <br>url：要访问的地址   - string类型<br>params：查询参数 - 字典<br>headers：请求头  - 字典<br>data：表单格式请求体数据  - 字典  - tpshop商城项目<br>json：json格式请求体数据  - 字典  - ihrm项目<br><br>cookies：用来传递cookies<br><br>resp：代表响应结果。<br></code></pre></td></tr></table></figure><p><strong>案例1</strong></p><p>【带 查询参数 的get请求】使用Requests库，请求 tpshop商城 搜索商品接口。查询 iphone </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导包</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 发送 get请求，访问 tpshop搜索接口，得到响应结果</span><br><span class="hljs-comment"># resp = requests.get(url=&quot;http://tpshop-test.itheima.net/Home/Goods/search.html?q=iphone&quot;)</span><br>resp = requests.get(url=<span class="hljs-string">&quot;http://tpshop-test.itheima.net/Home/Goods/search.html&quot;</span>,<br>                    params=&#123;<span class="hljs-string">&quot;q&quot;</span>: <span class="hljs-string">&quot;iphone&quot;</span>&#125;)<br><span class="hljs-comment"># 打印响应结果</span><br><span class="hljs-built_in">print</span>(resp.text)<br></code></pre></td></tr></table></figure><p><strong>案例2</strong></p><p>【带 表单数据 的post请求】使用Requests库，完成 tpshop商城 登录接口调用。返回 ”验证码错误“ 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导包</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 发送 post请求，登录，得响应结果</span><br>resp = requests.post(url=<span class="hljs-string">&quot;http://tpshop-test.itheima.net/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.06754297110809726&quot;</span>,<br>                     headers=&#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>&#125;,<br>                     data=&#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;13812345678&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;12345678&quot;</span>, <span class="hljs-string">&quot;verify_code&quot;</span>: <span class="hljs-string">&quot;8888&quot;</span>&#125;)<br><br><span class="hljs-comment"># 保单是data，josn格式是j</span><br><br><span class="hljs-comment"># 打印 文本 响应结果</span><br><span class="hljs-built_in">print</span>(resp.text)<br><br><span class="hljs-comment"># 打印 转换为 json格式的 响应结果</span><br><span class="hljs-built_in">print</span>(resp.json())<br></code></pre></td></tr></table></figure><p><strong>案例3</strong></p><p>【带 json数据 的post请求】使用Requests库，完成 iHRM系统 成功登录。返回 ”令牌数据“</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导包</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 发送 post请求，登录 ihrm。得响应结果</span><br>resp = requests.post(url=<span class="hljs-string">&quot;http://ihrm-test.itheima.net/api/sys/login&quot;</span>,<br>                     <span class="hljs-comment"># headers=&#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;,</span><br>                     json=&#123;<span class="hljs-string">&quot;mobile&quot;</span>: <span class="hljs-string">&quot;13800000002&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;123456&quot;</span>&#125;)<br><br><span class="hljs-comment"># 打印响应结果，转json格式</span><br><span class="hljs-built_in">print</span>(resp.json())<br></code></pre></td></tr></table></figure><h2 id="项目实战-黑马头条"><a href="#项目实战-黑马头条" class="headerlink" title="项目实战-黑马头条"></a>项目实战-黑马头条</h2><h3 id="UI自动化测试"><a href="#UI自动化测试" class="headerlink" title="UI自动化测试"></a>UI自动化测试</h3><h1 id="八股总结"><a href="#八股总结" class="headerlink" title="八股总结"></a>八股总结</h1><h2 id="软件测试的术语"><a href="#软件测试的术语" class="headerlink" title="软件测试的术语"></a>软件测试的术语</h2><p><strong>失效</strong></p><p><strong>事故</strong></p><p><strong>故障</strong></p><p><strong>错误</strong></p><p><strong>测试</strong></p><p><strong>调试</strong></p><p><strong>测试用例</strong></p><p>- </p><h2 id="软件测试的几个模型"><a href="#软件测试的几个模型" class="headerlink" title="软件测试的几个模型"></a>软件测试的几个模型</h2><h3 id="V-V模型"><a href="#V-V模型" class="headerlink" title="V&amp;V模型"></a>V&amp;V模型</h3><p>为把握软件开发各个环节的正确性，需要进行各种<strong>确认</strong>和<strong>验证</strong>工作</p><p>验证(Verification)，在软件开发过程的某个阶段，决定此时的产品是否满⾜前⼀个阶段所确定需求的过程。（Are you building the product right?是否正确地构造软件？）</p><p>确认(Validation)，在软件开发结尾时，评估软件以保证所开发的软件和预期⽤途相符的过程。（ Are you building the right product?是否构造正确的软件？）</p><h2 id="软件测试过程模型"><a href="#软件测试过程模型" class="headerlink" title="软件测试过程模型"></a>软件测试过程模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>Paul Rook在20世纪80年代后期提出，最具有代表意义的测试模型，是软件开发瀑布模型的变 体，反映了测试活动与分析和设计的关系。</p><p><strong>两个特点</strong></p><ol><li>展示了动态测试的全过程，并定义了动态测试与开发之间的关系。 </li><li>动态测试的⾏为与开发过程的⾏为相对应，测试基础是对应开发阶段的⽂档。</li></ol><p><strong>三个缺点</strong></p><ol><li>测试与开发⽂档之间很少有完美的⼀对⼀关系。 </li><li>完全没有提及静态测试，忽略了代码审查、需求规格说明审查等重要的测试⼿段。 </li><li>软件测试时间经常由于前期开发阶段进度的拖延⽽被挤占，甚⾄取消，从⽽使得测试质量 得不到保证。</li></ol><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/V%E6%A8%A1%E5%9E%8B.png" class=""><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p>Paul Herzlich在1993年提出，对V模型的改进，表明测试与开发的并⾏关系，充分体现测试贯 穿于整个开发过程。</p><p><strong>两个特点：</strong></p><ol><li>W是V的发展，强调测试应在整个开发周期进⾏。 </li><li>W和V⼀样，开发⾏为与测试⾏为⼀⼀对应，但W并不主张动态测试必须要与开发阶段对应 起来，W也不限制动态测试⾏为必须严格地基于开发⾏为产⽣的单⼀⽂档</li></ol><p><strong>一个缺点</strong></p><ol><li>在W模型中，需求、设计、编码等<strong>活动是串⾏</strong>的，测试和开发活动也保持⼀种线性的前后 关系。只有上⼀个阶段完成之后，才能正式开始下⼀个阶段⼯作，从⽽⽆法⽀持迭代的开 发模式。</li></ol><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/W%E6%A8%A1%E5%9E%8B.png" class=""><h3 id="H模型"><a href="#H模型" class="headerlink" title="H模型"></a>H模型</h3><p>将测试活动视为⼀个完全独⽴的活动，具有独⽴的包括测试准备活动和测试执⾏活动的流程。</p><p>只要测试准备就绪，就可以开始测试执⾏活动。在整个开发周期内，存在多个这样独⽴的 测试流程。 体现“尽早准备、尽早执⾏”的思想，并且不同测试活动可以按照合理的顺序进⾏。</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/H%E6%A8%A1%E5%9E%8B.png" class=""><h3 id="X模型"><a href="#X模型" class="headerlink" title="X模型"></a>X模型</h3><p>认为V模型⽆法引导项⽬的全部过程。认为模型必须能处理开发的所有⽅⾯，包括交接、 频繁重复的集成以及需求⽂档的缺乏等。 </p><p>认为V是基于⼀套必须按照⼀定顺序严格排列的开发步骤，可能不能反映实际的实践过 程。 提倡探索性测试，即不进⾏事先计划的特殊类型的测试。</p><h3 id="建议模型"><a href="#建议模型" class="headerlink" title="建议模型"></a>建议模型</h3><p>以W模型为基本框架，从开发过程⼀开始就介⼊，并与开发过程同步开展相应的测试⼯作 ，同时灵活运⽤H模型独⽴测试的思想，只要满⾜就绪条件就进⾏独⽴的测试，并对测试 ⼯作进⾏迭代，直⾄完成测试⽬标。体现了尽早测试、全⾯测试、独⽴迭代测试的思想。</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E5%BB%BA%E8%AE%AE%E7%9A%84%E6%A8%A1%E5%9E%8Bpng.png" class=""><h2 id="静态测试和动态测试"><a href="#静态测试和动态测试" class="headerlink" title="静态测试和动态测试"></a>静态测试和动态测试</h2><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>静态分析，对模块的源代码进⾏研读，查找错误或收集⼀些度量数据，并不需要对代码进⾏编译和仿真运⾏，采⽤⼈⼯检测和计算机辅助静态分析⼿段进⾏检测。 静态测试包括对各阶段的软件产品进⾏审查。</p><h4 id="软件评审"><a href="#软件评审" class="headerlink" title="软件评审"></a>软件评审</h4><p>30％－70％的缺陷是通过软件评审发现。 对所有⼈⼯静态分析技术和具体⽂档检查技术的通称。</p><p><strong>五个优点</strong></p><ol><li>早发现错误早纠正，从⽽降低开发成本。 </li><li>除了开发⼈员参加外，⽤户也要参与，这样可以兼容各家之⻓，从不同的视⻆考虑问题。 </li><li>发现的缺陷较显⻅。⽽软件测试是从迹象判断缺陷存在（实际输出与预期输出不符），再 根据各种现象分析，才能判断造成缺陷的原因，这是⼀个困难的过程。 </li><li>测试需对各个缺陷分别进⾏分析定位再纠正，⽽软件评审往往可以成批发现缺陷，同时也 可以成批纠正缺陷，效率较⾼。 </li><li>测试时发现缺陷，程序⼈员往往急于纠正，⽽不能冷静考虑修正⽅案，会导致错上加错。 ⽽软件评审在早期，软件开发⼈员往往能够从容对待，全⾯衡量选择修改⽅法。</li></ol><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>通过观察代码运⾏时的动作，来提供执⾏跟踪、测试覆盖率⽅⾯的信息。 通过有效的测试⽤例，对应的输⼊&#x2F;输出关系来分析被测程序的运⾏情况。</p><h2 id="软件测试的10条原则"><a href="#软件测试的10条原则" class="headerlink" title="软件测试的10条原则"></a>软件测试的10条原则</h2><ol><li>测试⽤例中⼀个必需部分是对预期输出或结果的定义； </li><li>程序员应该避免测试⾃⼰的程序； </li><li>编写软件的组织不应测试⾃⼰编写的软件； </li><li>应当彻底检查每个测试的执⾏结果； </li><li>测试⽤例的编写不仅应当根据有效和预期的输⼊情况，⽽且也应当根据⽆效和未预料到的 输⼊情况；</li><li>检查程序是否“未做其应该做的”仅是测试的⼀半，测试的另⼀半是检查程序是否“做了其不应该做的”； </li><li>应避免测试⽤例⽤后即弃，除⾮软件本身是⼀个⼀次性的软件； </li><li>计划测试⼯作时不应默许假定不会发现错误； </li><li><strong>程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正⽐；</strong> </li><li>测试是⼀项极富创造性、极具智⼒挑战性的⼯作</li></ol><h2 id="黑白盒测试"><a href="#黑白盒测试" class="headerlink" title="黑白盒测试"></a>黑白盒测试</h2><h3 id="四种功能性测试用例设计方法（黑盒测试）"><a href="#四种功能性测试用例设计方法（黑盒测试）" class="headerlink" title="四种功能性测试用例设计方法（黑盒测试）"></a>四种功能性测试用例设计方法（黑盒测试）</h3><h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><p>边界值分析法是对等价类划分的一种补充，因为大多数错误都在输入输出的边界上。如果边界附近取值不会导致程序出错，那么其他取值出错的可能性也就很小。</p><h5 id="1、简单边界值测试"><a href="#1、简单边界值测试" class="headerlink" title="1、简单边界值测试"></a>1、简单边界值测试</h5><p>错误更可能出现在输⼊变量值的附近,即 <code>Min,Min+,Nom,Max-,Max</code>会产⽣ <code>4n+1</code> 个测试⽤例。</p><h5 id="2、健壮性测试"><a href="#2、健壮性测试" class="headerlink" title="2、健壮性测试"></a>2、健壮性测试</h5><p>在1的基础上加⼊略超过最⼤值<code>Max+</code>的取值，以及略⼩于最⼩值<code>Min-</code>的取值，会产⽣ <code>6n+1</code> 个测试⽤例。</p><h5 id="3、最坏情况测试"><a href="#3、最坏情况测试" class="headerlink" title="3、最坏情况测试"></a>3、最坏情况测试</h5><p>对1进⾏笛卡尔集计算，共<code>5^n</code>个测试⽤例</p><h5 id="4、健壮性最坏情况测试"><a href="#4、健壮性最坏情况测试" class="headerlink" title="4、健壮性最坏情况测试"></a>4、健壮性最坏情况测试</h5><p>对2进⾏笛卡尔积计算，共<code>7^n</code>个测试⽤例</p><h4 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>是指把所有可能的输入数据，即程序的输入域划分成若干子集合，然后从每一个子集合中<br>选取少数具有代表性的数据作为测试用例。在该子集合中，所有的输入数据对于揭露软件中的错<br>误都是等效的。</p><h5 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h5><ul><li>有效等价类：指对程序的需求说明有意义的、合理的、正确的输入数据构成的集合</li><li>无效等价类：指不合理的或无意义的输入数据所构成的集合</li></ul><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E4%BE%8B%E5%AD%90.png" class=""><h5 id="等价类划分设计用例的步骤"><a href="#等价类划分设计用例的步骤" class="headerlink" title="等价类划分设计用例的步骤"></a>等价类划分设计用例的步骤</h5><ol><li>按数据范围（长度）&#x2F;数据类型&#x2F;为空&#x2F;需求规则约束角度划分等价类，并规定唯一的编号。数据范围（长度）：用户名长度（类似最小 &lt; x &lt; 最大、最小 &gt; x、最大 ）；数据类型：比如金额只能是数字；为空：比如必填项；需求规则约束角度：例如系统规定用户名必须白名单、黑名单不支持</li><li>设计测试用例，覆盖所有有效等价类：设计一个新的测试用例，<strong>尽可能多的</strong>覆盖有效等价类，直到所有的有效等价类都被覆盖</li><li>设计测试用例，覆盖所有无效等价类：设计一个新的测试用例，<strong>仅覆盖一个</strong>无效等价类，直到所有的有效等价类都被覆盖</li></ol><h4 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h4><p>略</p><h4 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h4><p>略</p><h3 id="两种结构性测试用例设计方法（白盒测试）"><a href="#两种结构性测试用例设计方法（白盒测试）" class="headerlink" title="两种结构性测试用例设计方法（白盒测试）"></a>两种结构性测试用例设计方法（白盒测试）</h3><h4 id="控制流-路径测试"><a href="#控制流-路径测试" class="headerlink" title="控制流&#x2F;路径测试"></a>控制流&#x2F;路径测试</h4><p>强度由低到高</p><ol><li>语句覆盖：选择足够多的测试用例，使得程序中每个可执行语句至少执行一次</li><li>分支覆盖：选择足够的测试用例，使得程序中每个判定至少都获得一次真值和假值</li><li>条件覆盖：选择足够的测试用例，使得程序中每个判定中的每个条件的可能至少满足一次</li><li>条件判定覆盖：选择足够的测试用例，使得程序中每个判定中的每个条件的所有可能（真、假）至少出现一次并且每个判定本身的结果（真、假）也至少出现一次。</li><li>条件组合覆盖：选择⾜够的测试⽤例，使得程序中每个判定条件的各种可能组合都⾄少出 现⼀次，显然满⾜条件组合覆盖的测试⽤例⼀定满⾜”（判定）分⽀覆盖”、“分⽀条件覆 盖”和“条件判定覆盖”。</li><li>路径覆盖：设计⾜够的测试⽤例要求覆盖程序中所有可能的路径。</li></ol><h4 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h4><h5 id="全定义覆盖"><a href="#全定义覆盖" class="headerlink" title="全定义覆盖"></a>全定义覆盖</h5><p>全定义覆盖（All Defs Coverage）要求每个变量的每个定义⾄少被有效使⽤⼀次。测试集合T满⾜全定义覆盖，当且仅当存在⼀个执⾏T产⽣的完整路径集合L的⼦路径集合包含每 个变量的每个定义和某个该定义的使⽤构成的定义-使⽤路径集合。</p><h5 id="全使⽤覆盖"><a href="#全使⽤覆盖" class="headerlink" title="全使⽤覆盖"></a>全使⽤覆盖</h5><p>全使⽤覆盖（All Uses Coverage）要求每个变量的每个使⽤⾄少被执⾏⼀次。测试集合T 满⾜全使⽤覆盖，当且仅当存在⼀个执⾏T产⽣的完整路径集合L的⼦路径集合包含每个变 量的每个定义和所有该定义的使⽤构成的定义-使⽤路径集合。</p><h5 id="全定义-使⽤覆盖"><a href="#全定义-使⽤覆盖" class="headerlink" title="全定义-使⽤覆盖"></a>全定义-使⽤覆盖</h5><p>全定义-使⽤路径覆盖（All DU-paths Coverage）要求所有定义-使⽤路径⾄少被执⾏⼀ 次。测试集合T满⾜全定义-使⽤路径覆盖，当且仅当执⾏T产⽣的完整路径集合L访问了所 有数据流图中的定义-使⽤路径。图6给出了上述3个覆盖准则之间的差异说明。 除开始结点，路径不存在变量的其他定义结点</p><h3 id="黑盒和白盒测试的区别和联系"><a href="#黑盒和白盒测试的区别和联系" class="headerlink" title="黑盒和白盒测试的区别和联系"></a>黑盒和白盒测试的区别和联系</h3><table><thead><tr><th></th><th>黑盒测试</th><th>白盒测试</th></tr></thead><tbody><tr><td></td><td>不查看内部代码结构</td><td>了解程序内部的代码结构</td></tr><tr><td></td><td>根据软件需求和规范设计</td><td>按照程序内部逻辑设计</td></tr><tr><td></td><td>涉及到单元、集成、系统和验收测试</td><td>涉及到单元测试、集成测试</td></tr><tr><td></td><td>测试人员不需要程序经验</td><td>需要一定的程序经验</td></tr><tr><td></td><td>可以手动或自动化测试</td><td>可以手动话和自动化测试</td></tr><tr><td>缺点</td><td>覆盖率低</td><td>穷举路径不太可能，只能测试开发人员做的对不对，不知道需求是否正确满足</td></tr></tbody></table><h2 id="集成测试方法"><a href="#集成测试方法" class="headerlink" title="集成测试方法"></a>集成测试方法</h2><h3 id="1、基于功能分解的集成测试"><a href="#1、基于功能分解的集成测试" class="headerlink" title="1、基于功能分解的集成测试"></a>1、基于功能分解的集成测试</h3><h4 id="1）自顶向下集成"><a href="#1）自顶向下集成" class="headerlink" title="1）自顶向下集成"></a>1）自顶向下集成</h4><p>⾃顶向下集成从主程序（树根）开始。所有被主程序调⽤的下层单元都作为“桩” 出现，桩就是模拟被调⽤单元的⼀次性代码</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90.png" class=""><h4 id="2）自底向上集成"><a href="#2）自底向上集成" class="headerlink" title="2）自底向上集成"></a>2）自底向上集成</h4><p>⾃底向上集成是⾃顶向下顺序的“镜像”，不同的是，桩由模拟功能分解树上⼀层 单元的驱动器模块替代。</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E9%9B%86%E6%88%90.png" class=""><h4 id="3）三明治集成"><a href="#3）三明治集成" class="headerlink" title="3）三明治集成"></a>3）三明治集成</h4><p>三明治是⾃顶向下和⾃底向上集成的组合。桩和驱动器的开发⼯作都⽐较⼩，不 过代价是有⼤爆炸的后果。</p><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E4%B8%89%E6%98%8E%E6%B2%BB%E9%9B%86%E6%88%90.png" class=""><h4 id="4）大爆炸集成"><a href="#4）大爆炸集成" class="headerlink" title="4）大爆炸集成"></a>4）大爆炸集成</h4><p>这种⽅法的优点是：将所有单元在⼀起编译并进⾏⼀次性测试。</p><p>这种⽅法的缺点是，当发现缺陷时，没有多少线索能够⽤来帮助确定缺陷位置。</p><h4 id="基于功能分解的集成测试优缺点"><a href="#基于功能分解的集成测试优缺点" class="headerlink" title="基于功能分解的集成测试优缺点"></a>基于功能分解的集成测试优缺点</h4><p><strong>优点</strong>：⽐较清晰；容易发现问题地点； </p><p><strong>缺点</strong>：功能分解是基于⼈⼯和管理需要的；桩和驱动器有⼀定开发⼯作量；</p><h3 id="2、基于调用图的集成测试"><a href="#2、基于调用图的集成测试" class="headerlink" title="2、基于调用图的集成测试"></a>2、基于调用图的集成测试</h3><h4 id="1）成对测试"><a href="#1）成对测试" class="headerlink" title="1）成对测试"></a>1）成对测试</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E6%88%90%E5%AF%B9%E9%9B%86%E6%88%90.png" class=""><h4 id="2）相邻集成"><a href="#2）相邻集成" class="headerlink" title="2）相邻集成"></a>2）相邻集成</h4><img src="/2024/09/15/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/%E7%9B%B8%E9%82%BB%E9%9B%86%E6%88%90.png" class=""><h4 id="基于调⽤图的集成测试优缺点"><a href="#基于调⽤图的集成测试优缺点" class="headerlink" title="基于调⽤图的集成测试优缺点"></a>基于调⽤图的集成测试优缺点</h4><p><strong>优点</strong>：偏离了纯结构基础，转向⾏为基础；免除了⼤量桩&#x2F;驱动器开发⼯作量；邻居序列可 以⽤于定义构建；</p><p><strong>缺点</strong>：缺陷的隔离问题，尤其是对有⼤量邻居的情况；如果在多邻居的多个节点中发现缺 陷会出现什么情况？缺陷修改后的回归测试量很⼤。</p><h3 id="3、基于路径的集成测试"><a href="#3、基于路径的集成测试" class="headerlink" title="3、基于路径的集成测试"></a>3、基于路径的集成测试</h3><h4 id="源节点："><a href="#源节点：" class="headerlink" title="源节点："></a>源节点：</h4><p>是程序执⾏开始或重复开始处的语句⽚段，单元中的第⼀个可执⾏语句是源节点，源 节点还会出现在紧接转移控制到其他单元节点之后。</p><h4 id="汇节点："><a href="#汇节点：" class="headerlink" title="汇节点："></a>汇节点：</h4><p>是程序执⾏结束出的语句⽚段，程序中的最后⼀个可执⾏语句是汇节点，转移控制到 其他单元的节点也是汇节点</p><h4 id="模块执⾏路径："><a href="#模块执⾏路径：" class="headerlink" title="模块执⾏路径："></a>模块执⾏路径：</h4><p>是以源节点开始，汇节点结束的⼀系列语句，中间没有插⼊汇节点。程序图有多个源 节点和汇节点。</p><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>是⼀种程序设计语⾔，通过这种机制⼀个单元将控制转移给另⼀个单元，消息可以被 解释为⼦程序调⽤过程调⽤和函数引⽤，约定接受信息的单元总是最终将控制返回给 消息源，消息可以向其他单元传递数据。</p><h4 id="MM-路径："><a href="#MM-路径：" class="headerlink" title="MM-路径："></a>MM-路径：</h4><p>是穿插出现模块执⾏路径和消息的序列，对于传统（过程）软件，MM-路径永远从主 程序开始，在主程序中结束。</p><h4 id="基于路径的集成测试优缺点"><a href="#基于路径的集成测试优缺点" class="headerlink" title="基于路径的集成测试优缺点"></a>基于路径的集成测试优缺点</h4><p><strong>优点</strong>：MM-路径是功能性测试和结构性测试的⼀种混合。它与实际系统⾏为密切匹配，⽽ 不是靠基于分解和调⽤图集成的结构性路径 </p><p><strong>缺点</strong>：需要更多的⼯作量标识MM-路径</p><h2 id="测试的类型"><a href="#测试的类型" class="headerlink" title="测试的类型"></a>测试的类型</h2><p>测试分为 <strong>功能测试</strong> 和 <strong>非功能测试</strong></p><p>非功能测试又可分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可通行测试、配置测试、GUI测试。</p><h2 id="软件质量的六个特征"><a href="#软件质量的六个特征" class="headerlink" title="软件质量的六个特征"></a>软件质量的六个特征</h2><ul><li>功能性：表示软件能够提供满足明确和隐含需求的功能。它涉及适用性、准确性、互操作性、安全性和符合性。</li><li>可靠性：指软件在特定条件下持续正常运行的能力。包括成熟度、容错性、恢复能力等。</li><li>易用性：软件的界面和功能对用户是否友好，是否易于理解、学习、使用和吸引用户&#x2F;包括可理解性、易学性、操作性、吸引力和用户界面的适用性。</li><li>效率：指软件在特定条件下对系统资源的有效使用。这涉及时间效率和资源效率。</li><li>可维护性：指在必要时能够有效地进行修正和改进软件的 能力。这包括模块化、可重用性、分析性、修改性、和测试性</li><li>可移植性：表示软件从一个环境迁移到另一个环境的能力。包括适应性、安装性、共存性和更换性。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股训练营回答</title>
    <link href="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/"/>
    <url>/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h1><h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><h3 id="HTTP-1-1的优点"><a href="#HTTP-1-1的优点" class="headerlink" title="HTTP&#x2F;1.1的优点"></a>HTTP&#x2F;1.1的优点</h3><p>HTTP最突出的优点就是【简单、灵活和易于扩展、应用广泛和跨平台】。</p><h3 id="HTTP-1-1的缺点"><a href="#HTTP-1-1的缺点" class="headerlink" title="HTTP&#x2F;1.1的缺点"></a>HTTP&#x2F;1.1的缺点</h3><h4 id="1）无状态双刃剑"><a href="#1）无状态双刃剑" class="headerlink" title="1）无状态双刃剑"></a>1）无状态双刃剑</h4><h4 id="2）明文传输双刃剑"><a href="#2）明文传输双刃剑" class="headerlink" title="2）明文传输双刃剑"></a>2）明文传输双刃剑</h4><h4 id="3）不安全"><a href="#3）不安全" class="headerlink" title="3）不安全"></a>3）不安全</h4><h3 id="HTTP-1-1-的性能如何？"><a href="#HTTP-1-1-的性能如何？" class="headerlink" title="HTTP&#x2F;1.1 的性能如何？"></a>HTTP&#x2F;1.1 的性能如何？</h3><p>HTTP 协议是基于 TCP&#x2F;IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥。</p><h4 id="1）长连接"><a href="#1）长连接" class="headerlink" title="1）长连接"></a>1）长连接</h4><p>⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。</p><h4 id="2）管道网络传输"><a href="#2）管道网络传输" class="headerlink" title="2）管道网络传输"></a>2）管道网络传输</h4><p>HTTP&#x2F;1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。</p><p>即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可 以发第⼆个请求出去，可以减少整体的响应时间。</p><h3 id="3）队头阻塞"><a href="#3）队头阻塞" class="headerlink" title="3）队头阻塞"></a>3）队头阻塞</h3><h1 id="八股训练营"><a href="#八股训练营" class="headerlink" title="八股训练营"></a>八股训练营</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="OSI模型和TCP-IP模型"><a href="#OSI模型和TCP-IP模型" class="headerlink" title="OSI模型和TCP&#x2F;IP模型"></a>OSI模型和TCP&#x2F;IP模型</h3><h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p><strong>掌握程度</strong>：</p><ul><li>理解OSI模型共有7层，能够说明是哪七层。 物、数、网、传、会、表、应</li><li>能够粗浅描述每一层的基本功能和职责</li><li>对于某些层，熟悉一些常见的协议，比如网络层的IP，传输层的TCP和UDP</li></ul><h5 id="1）物理层"><a href="#1）物理层" class="headerlink" title="1）物理层"></a>1）物理层</h5><ul><li>负责<strong>传输原始比特流</strong>，而不是数据包。涉及到硬件设备的物理特性，如网线、光纤、电缆、连接器、接口和信号传输方式（如电气信号、电压电平、光信号等）。</li><li><strong>定义物理设备的规范</strong>（如电缆类型、连接器类型、引脚结构等），以及<strong>如何将数据转换为物理信号</strong>（如电磁波、光信号等）在介质上传输。</li><li><strong>处理数据的传输速率、传输模式（如半双工或全双工）和同步方法</strong></li></ul><h5 id="2）数据链路层"><a href="#2）数据链路层" class="headerlink" title="2）数据链路层"></a>2）数据链路层</h5><ul><li><strong>提供节点间的数据传输</strong>，并处理物理层传输过程中的<strong>误码检测与纠正</strong>。</li><li>负责建立、维护和释放数据链路连接，确保数据的可靠传输。包括<strong>帧的封装与解封装</strong>，和<strong>数据流的控制</strong>。</li><li>分为两个子层<ul><li><strong>逻辑链路控制子层（LLC）</strong>：负责<strong>错误检测和流量控制</strong>。</li><li><strong>介质访问控制子层（MAC）</strong>：负责对共享传输介质的访问控制，<strong>决定哪些设备可以在特定时间发送数据。</strong></li></ul></li></ul><h5 id="3）网络层"><a href="#3）网络层" class="headerlink" title="3）网络层"></a>3）网络层</h5><ul><li>负责数据包的路由选择与转发，确保<strong>数据从源节点正确传输到目标节点</strong>。</li><li>管理逻辑地址（如<strong>IP地址）和主机地址的映射关系</strong>，处理子网之间的通信</li><li>实现<strong>拥塞控制、流量控制和分段重组</strong>功能，以应对不同网络之间的差异。</li></ul><h5 id="4）传输层"><a href="#4）传输层" class="headerlink" title="4）传输层"></a>4）传输层</h5><ul><li>提供端到端的通信服务，确保数据从<strong>源到目的应用程序的可靠传输</strong>。</li><li>提供<strong>差错检测与纠正机制</strong>，确保数据的完整性和顺序性。</li><li>定义了两种主要的传输协议：<strong>传输控制协议（TCP）</strong>，提供面向连接的、可靠的传输；<strong>用户数据报协议（UDP）</strong>，提供无连接的、不可靠但高效的传输。</li><li>管理数据流的分段与重组，提供端口号来标识不同的应用程序</li></ul><h5 id="5）会话层"><a href="#5）会话层" class="headerlink" title="5）会话层"></a>5）会话层</h5><ul><li>负责在通信系统中<strong>建立、管理和终止会话（Session）</strong></li><li>通过同步和检查点恢复等机制，<strong>确保数据在传输过程中不中断或崩溃。</strong></li><li>提供全双工、半双工或单工模式的数据传输服务，管理会话层协议的对话控制和令牌管理。</li></ul><h5 id="6）表示层"><a href="#6）表示层" class="headerlink" title="6）表示层"></a>6）表示层</h5><ul><li><strong>负责数据的表示形式，提供格式化、加密和解密、数据压缩和解压缩功能</strong>，确保发送端和接收端以相同的格式处理数据。</li><li><strong>处理数据的语法和语义转换</strong>（如字符编码、数据结构转换），使不同系统之间能够进行无缝的数据交换。</li></ul><h5 id="7）应用层"><a href="#7）应用层" class="headerlink" title="7）应用层"></a>7）应用层</h5><ul><li>直接<strong>为用户或应用程序提供各种网络服务</strong>，如文件传输、电子邮件、远程登录、网络管理等。</li><li>提供<strong>用户与网络之间的接口</strong>，负责协议的建立和传输控制，以及终端设备的通信进程管理。</li><li>常见的应用层协议包括HTTP、FTP、SMTP、DNS等。</li></ul><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h4><h5 id="掌握程度："><a href="#掌握程度：" class="headerlink" title="掌握程度："></a><strong>掌握程度</strong>：</h5><ul><li>理解 TCP&#x2F;IP 模型通常被描述为 4 层，<strong>能够清晰地描述网络模型的层次结构。</strong></li><li><strong>能够解释每一层的作用</strong>，知道 TCP&#x2F;IP 模型的层次是如何与 OSI 模型相对应的。 </li><li><strong>能够举例说明每层使用的协议，对某些层次的深入理解</strong>，比如 TCP 的三次握手、四次挥手，IP 数据报的路由选择。 </li><li><strong>理解不同层次间的交互</strong>：了解数据是如何在这些层次之间流动的，以及每一层如何为数据的传输添加或移除其所需的头部信息。</li></ul><p>对于同⼀台设备上的进程间通信，有很多种⽅式，⽐如有<strong>管道、消息队列、共享内存、信号</strong>等⽅式，⽽对 于不同设备上的进程间通信，就需要⽹络通信，⽽设备是多样性的，所以要兼容多种多样的设备，就协商出了⼀套<strong>通⽤的⽹络协议</strong>。</p><h5 id="1）应用层"><a href="#1）应用层" class="headerlink" title="1）应用层"></a>1）应用层</h5><p>最上层的，也是我们能直接接触到的就是应⽤层（Application Layer），我们电脑或⼿机使⽤的应⽤软件都是在应⽤层实现。那么，当两个不同设备的应⽤需要通信的时候，应⽤就把应⽤数据传给下⼀层，也就是传输层。</p><p><strong>所以，应⽤层只需要专注于为⽤户提供应⽤功能，⽐如 HTTP、FTP、Telnet、DNS、SMTP等。</strong></p><p>应⽤层是不⽤去关⼼数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关⼼快递是如何被运输的。</p><h5 id="2）传输层"><a href="#2）传输层" class="headerlink" title="2）传输层"></a>2）传输层</h5><p>应⽤层的数据包会传给传输层，传输层（Transport Layer）是为应⽤层提供⽹络⽀持的。</p><p>在传输层会有两个传输协议，分别是 <strong>TCP 和 UDP。</strong></p><p><strong>TCP 的全称叫传输控制协议（Transmission Control Protocol）</strong>，⼤部分应⽤使⽤的正是 TCP 传输层协 议，⽐如 HTTP 应⽤层协议。TCP 相⽐  UDP 多了很多特性，⽐如<strong>流量控制、超时重传、拥塞控制</strong>等，这 些都是为了保证数据包能可靠地传输给对⽅。 </p><p><strong>UDP 相对来说就很简单，简单到只负责发送数据包</strong>，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率也⾼。</p><p>应⽤需要传输的数据可能会⾮常⼤，如果直接传输就不好控制，因此当<strong>传输层的数据包⼤⼩超过 MSS （TCP 最⼤报⽂段⻓度）</strong> ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新发送 这⼀个分块，⽽不⽤重新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 <strong>TCP 段（TCP  Segment）。</strong></p><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/%E6%95%B0%E6%8D%AE%E5%88%86%E4%B8%BATCP%E6%AE%B5.png" class=""><p>当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者 传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是<strong>端⼝</strong>。</p><p>⽐如 <strong>80 端⼝</strong>通常是 Web 服务器⽤的，22 端⼝通常是远程登录服务器⽤的。⽽对于浏览器（客户端）中的 每个标签栏都是⼀个独⽴的进程，操作系统会为这些进程分配临时的端⼝号。</p><p>由于传输层的报⽂中会携带端⼝号，因此接收⽅可以识别出该报⽂是发送给哪个应⽤。</p><h5 id="3）网络层-1"><a href="#3）网络层-1" class="headerlink" title="3）网络层"></a>3）网络层</h5><p>我们不希望传输层协议处理太多的事情，只需要服务好应⽤即可，让其作为应⽤间数据传输的 媒介，帮助实现应⽤到应⽤的通信，⽽实际的传输功能就交给下⼀层，也就是⽹络层（Internet Layer）。</p><p>⽹络层最常使⽤的是 <strong>IP 协议（Internet Protocol）</strong>，IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包 头组装成 IP 报⽂，如果 IP 报⽂⼤⼩超<strong>过 MTU（以太⽹中⼀般为 1500 字节）</strong>就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂。</p><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%95%B0%E6%8D%AE%E5%8C%85.png" class=""><p>⽹络层负责将数据从⼀个设备传输到另⼀个设备，世界上那么多设备，⼜该如何找到对⽅呢？因此，⽹络层需要有区分设备的编号。</p><p>我们⼀般⽤ IP 地址给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（⽐如， 192.168.100.1），每段是 8 位。只有⼀个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道⼀个⼀个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>⼀个是<strong>⽹络号</strong>，负责标识该 IP 地址是属于哪个「⼦⽹」的；</li><li>⼀个是<strong>主机号</strong>，负责标识同⼀「⼦⽹」下的不同主机；</li></ul><p>除了寻址能⼒， IP 协议还有另⼀个重要的能⼒就是<strong>路由</strong>。实际场景中，两台设备并不是⽤⼀条⽹线连接起来的，⽽是通过很多⽹关、路由器、交换机等众多⽹络设备连接起来的，那么就会形成很多条⽹络的路径，因此当数据包到达⼀个⽹络节点，就需要通过路由算法决定下⼀步⾛哪条路径。</p><p>所以，<strong>IP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」 选择路径。寻址更像在导航，路由更像在操作⽅向盘。</strong></p><h5 id="4）网络接口层"><a href="#4）网络接口层" class="headerlink" title="4）网络接口层"></a>4）网络接口层</h5><p>⽣成了 IP 头部之后，接下来要交给<strong>⽹络接⼝层（Link Layer）</strong>在IP头部的前⾯加上 MAC 头部，并封装成 <strong>数据帧（Data frame）</strong>发送到⽹络上。</p><p>IP 头部中的接收⽅ IP 地址表示⽹络包的⽬的地，通过这个地址我们就可以判断要将包发到哪⾥，<strong>但在以太⽹的世界中，这个思路是⾏不通的</strong>。</p><p>什么是以太⽹呢？电脑上的以太⽹接⼝，Wi-Fi接⼝，以太⽹交换机、路由器上的千兆，万兆以太⽹⼝，还 有⽹线，它们都是以太⽹的组成部分。<strong>以太⽹就是⼀种在「局域⽹」</strong>内，把附近的设备连接起来，使它们之间可以进⾏通讯的技术。</p><p>以太⽹在判断⽹络包⽬的地时和 IP 的⽅式不同，因此必须采⽤相匹配的⽅式才能在以太⽹中将包发往⽬的地，⽽ MAC 头部就是⼲这个⽤的，所以，在以太⽹进⾏通讯要⽤到 MAC 地址</p><p>MAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息，我们可以通过 ARP 协议 获取对⽅的 MAC 地址。</p><p>所以说，⽹络接⼝层主要为⽹络层提供「链路级别」传输的服务，负责在以太⽹、WiFi 这样的底层⽹络上 发送原始数据包，⼯作在⽹卡这个层次，使⽤ MAC 地址来标识⽹络上的设备。</p><h5 id="5）每⼀层的封装格式："><a href="#5）每⼀层的封装格式：" class="headerlink" title="5）每⼀层的封装格式："></a>5）每⼀层的封装格式：</h5><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F.png" class=""><p>⽹络接⼝层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段 （segment），HTTP 的传输单位则是消息或报⽂（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h4 id="从输入URL到页面展示发生了什么"><a href="#从输入URL到页面展示发生了什么" class="headerlink" title="从输入URL到页面展示发生了什么"></a>从输入URL到页面展示发生了什么</h4><p><strong>掌握程度</strong></p><ul><li><strong>基本要求</strong>：理解浏览器和服务器之间的交互工程，能够清晰地从输入URL到页面显示的整个流程。<ul><li>DNS解析：描述如何将域名转换为IP地址。</li><li>TCP连接建立：解释TCP三次握手的过程。</li><li>HTTP请求：说明浏览器如何构建HTTP请求，并发送到服务器。</li><li>服务器处理请求：描述服务器接收请求、处理请求并生成响应的过程。</li><li>HTTP响应：说明服务器如何将响应发送回浏览器。</li><li>TCP连接关闭：描述TCP四次挥手的过程。</li><li>浏览器渲染页面：描述浏览器如何解析HTML、CSS和javascript，以及构建DOM树和渲染树。</li><li>页面显示：解释浏览器如何将渲染树绘制到屏幕上。</li></ul></li><li>进阶要求：对每个步骤的关键点有所了解，如DNS解析、TCP&#x2F;IP连接、HTTP请求和响应、浏览器渲染等，引导面试官向具体的问题深入。</li><li>进阶要求：对页面加载性能优化有所了解，如减少DNS查询时间、使用CDN、压缩资源、利用缓存等。</li></ul><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL.png" class=""><h5 id="1）第一步：输入URL并解析"><a href="#1）第一步：输入URL并解析" class="headerlink" title="1）第一步：输入URL并解析"></a>1）第一步：输入URL并解析</h5><p>输入URL后，浏览器会解析出<strong>协议、主机、端口、路径</strong>等信息，并且构造一个<strong>HTTP请求</strong>（浏览器会根据请求头判断<strong>是否有HTTP缓存</strong>，并根据是否有缓存决定是从服务器获取资源还是使用缓存资源）</p><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/URL%E8%A7%A3%E6%9E%90.png" class=""><h5 id="2）第二步：DNS域名解析，将域名解析成对应的IP地址"><a href="#2）第二步：DNS域名解析，将域名解析成对应的IP地址" class="headerlink" title="2）第二步：DNS域名解析，将域名解析成对应的IP地址"></a>2）第二步：DNS域名解析，将域名解析成对应的IP地址</h5><p>通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给 Web 服务器。</p><p>但在发送之前，就是<strong>查询服务器域名对应的IP地址</strong>，就需要用到DNS域名解析。</p><h6 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h6><ol><li>客户端首先会发出一个DNS请求，问 &#96;&#96;<a href="http://www.server.com`/">www.server.com`</a> 的IP 是啥，并发给本地DNS服务器</li><li>本地域名服务器收到客户端请求后，<strong>如果缓存表格里能找到</strong> <code>www.server.com</code> ，则它直接返回IP地址<strong>。如果没有</strong>，本地DNS服务器回去问<strong>根域名服务器</strong>。根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。 </li><li>根DNS收到本地DNS的请求后，发现后置是<code>.com</code> ，会给出 <code>.com</code> 顶级域名服务器的地址</li><li>本地DNS收到顶级域名服务器的地址后，向其发起请求，问 <code>www.server.com</code>的IP地址</li><li><strong>顶级域名服务器</strong>给出<strong>权威DNS服务器</strong>地址</li><li>本地DNS服务器向权威DNS服务器询问</li><li>权威DNS服务器 查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。</li></ol><h5 id="3）第三步：建立起TCP连接之三次握手"><a href="#3）第三步：建立起TCP连接之三次握手" class="headerlink" title="3）第三步：建立起TCP连接之三次握手"></a>3）第三步：建立起TCP连接之三次握手</h5><h6 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h6><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/TCP%E5%8C%85%E5%A4%B4.png" class=""><ol><li>首先，<strong>源端口号</strong>和目的端口号是必不可少的，没有这两个端口号，就不知道该发给那个应用。</li><li>包的<strong>序号</strong>，解决包乱序的问题</li><li>确认号：目的是确认发出去对方是否有收到，如果没有收到，就应该重发，解决丢包问题</li><li>状态位：<strong>SYN 是发起一个连接， ACK 是回复， RST是重新连接， FIN 是结束连接等</strong>。TCP面向连接的，所以需要双方维护连接状态。</li><li>窗口大小，用于<strong>流量控制</strong>，标识自己当前能够处理的能力，别发太快，撑死，也别发太慢，饿死。</li></ol><h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><p>在 HTTP 传输数据之前，⾸先需要 TCP 建⽴连接，TCP 连接的建⽴，通常称为<strong>三次握⼿</strong>。</p><p> 这个所谓的「连接」，只是双⽅计算机⾥维护⼀个状态机，在连接建⽴的过程中，双⽅的状态变化时序图 就像这样</p><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class=""><ul><li>一开始，双方都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code>  状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code>和 <code>ACK</code> 之后，发送对 <code>SYN</code>的确认 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为他也一发一收了。</li></ul><h6 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h6><p><strong>所以三次握手的目的是保证双方都有发送和接收的能力</strong></p><h6 id="如何查看TCP的连接状态"><a href="#如何查看TCP的连接状态" class="headerlink" title="如何查看TCP的连接状态?"></a>如何查看TCP的连接状态?</h6><p>TCP的连接状态查看，在Linux可以通过<code>netstat -napt</code>命令查看。</p><h5 id="4）第四步：浏览器发送-HTTP-HTTPS-请求到服务器"><a href="#4）第四步：浏览器发送-HTTP-HTTPS-请求到服务器" class="headerlink" title="4）第四步：浏览器发送 HTTP&#x2F;HTTPS 请求到服务器"></a>4）第四步：浏览器发送 HTTP&#x2F;HTTPS 请求到服务器</h5><p>这一步也可以扩展很多问题，比如HTTP&#x2F;HTPS的区别?请求的方式?请求的状态码，凡是与HTTP请求的问题都可以问。</p><h5 id="5）第五步：服务器处理HTTP请求并返回HTTP报文"><a href="#5）第五步：服务器处理HTTP请求并返回HTTP报文" class="headerlink" title="5）第五步：服务器处理HTTP请求并返回HTTP报文"></a>5）第五步：服务器处理HTTP请求并返回HTTP报文</h5><p>HTTP响应报文和状态码也是常考的内容。</p><p>服务器会接受请求并将其传递给请求处理程序并发送HTTP相应。<strong>一般响应报文包含：请求的网页以及状态码，压缩类型，如何缓存的页面，设置的cookie。</strong></p><h5 id="6）第六步：浏览器渲染页面"><a href="#6）第六步：浏览器渲染页面" class="headerlink" title="6）第六步：浏览器渲染页面"></a>6）第六步：浏览器渲染页面</h5><h5 id="7）第七步：断开连接之TCP四次挥手"><a href="#7）第七步：断开连接之TCP四次挥手" class="headerlink" title="7）第七步：断开连接之TCP四次挥手"></a>7）第七步：断开连接之TCP四次挥手</h5><img src="/2024/09/13/%E5%85%AB%E8%82%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E5%9B%9E%E7%AD%94/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class=""><ul><li>假设<strong>客户端</strong>打算关闭连接，发送一个TCP首部 <code>FIN</code>被置1的 <strong><code>FIN</code>报文</strong>给服务端，此时<strong>客户端</strong>处于 <code>FIN_WAIT1</code> 状态。</li><li><strong>服务端</strong>收到以后，向<strong>客户端发送 <code>ACK</code> 应答报文</strong>，且把客户端的序列号值 + 1 作为 <code>ACK</code> 报文的序列号值，表示已经收到了客户端的报文了，此时<strong>客户端</strong>处于 <code>CLOSE_WAIT</code> 状态。</li><li>等待<strong>服务器处理完数据后</strong>，向客户端发送 <code>FIN</code> 报文。此时服务端处于 <code>LAST_ACK</code> 状态</li><li>客户端接收到 <code>FIN</code>报文后回一次 <code>ACK</code> 应答报文，之后客户端处于 <code>TIME_WAIT</code> 状态。</li></ul><p>服务器接收到<code>ACK</code>后，进入<code>CLOSE</code>状态，服务器完成连接关闭。客户端经过一段时间后，自动进入<code>CLOSE</code>状态。</p><h6 id="为什么挥手要四次"><a href="#为什么挥手要四次" class="headerlink" title="为什么挥手要四次"></a>为什么挥手要四次</h6><p>关闭连接时，客户端发送<code>FIN</code>报文，表示其不再发送数据，但还可以接收数据。</p><p>服务端收到<code>FIN</code>报文，可以直接发送<code>SYN+ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是关闭连接时，服务端可能还要数据需要处理和发送，所以先回一个<code>ACK</code>应答报文，等到其不再发送数据时，才发送<code>FIN</code>报文给客户端表示同意关闭连接。</p><p>从上面过程可知:服务端通常需要等待完成数据的发送和处理，所以服务端的<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++特性</title>
    <link href="/2024/09/11/C-%E7%89%B9%E6%80%A7/"/>
    <url>/2024/09/11/C-%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="C-八股"><a href="#C-八股" class="headerlink" title="C++八股"></a>C++八股</h1><h2 id="1、C-内存管理"><a href="#1、C-内存管理" class="headerlink" title="1、C++内存管理"></a>1、C++内存管理</h2><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>栈和堆都是用于存储程序数据的内存区域。</p><p>栈是一种有限的内存区域，用于存储局部变量、函数调用信息等。</p><p>堆是一种动态分配的内存区域，用于存储程序运行时动态分配。</p><p>栈上的变量生命周期与其所在函数的执行周期相同，而堆上的变量生命周期由程序员显示控制，可以（使用 <code>new</code> 或 <code>malloc</code>）和释放（使用 <code>delete</code> 和 <code>free</code>）。</p><p>栈上的内存分配和释放是自动的，速度较快。而堆上的内存分配和释放需要手动操作，速度相对较慢。</p><h3 id="C-内存分区"><a href="#C-内存分区" class="headerlink" title="C++内存分区"></a>C++内存分区</h3><p>C++程序运行时，内存被分为几个不同的区域，每个区域负责不同的任务。</p><img src="/2024/09/11/C-%E7%89%B9%E6%80%A7/C++%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" class=""><ol><li><p>栈</p><p>栈用于存储函数的局部变量、函数参数和函数调用信息的区域。函数调用和返回通过栈来管理</p></li><li><p>堆</p><p>堆用于存储动态分配的内存的区域，有程序员手动分配和释放。使用 <code>new</code> 和 <code>delete</code> 或 <code>malloc</code> 和 <code>free</code> 来进行堆内存的分配和释放</p></li><li><p>全局&#x2F;静态区</p><p>全局区存储全局变量和静态变量。生命周期是整个程序的运行期间。在程序启动时分配，程序结束时释放</p></li><li><p>常量区</p><p>常量区也被称为只读区。存储常量数据，如字符串常量</p></li><li><p>代码区</p><p>存储程序的代码</p></li></ol><h3 id="内存泄漏-？如何避免？"><a href="#内存泄漏-？如何避免？" class="headerlink" title="内存泄漏 ？如何避免？"></a>内存泄漏 ？如何避免？</h3><p>内容来自：代码随想录知识星球精华（最强⼋股⽂）第五版(C++篇).pdf P17</p><h4 id="1-什么是内存泄漏"><a href="#1-什么是内存泄漏" class="headerlink" title="1) 什么是内存泄漏"></a>1) 什么是内存泄漏</h4><p>内存泄漏（memory leak）是指由于疏忽或错误造成了 <strong>程序未能释放掉不再使用的内存的情况。</strong> 内存泄漏并非内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了堆该段内存的控制，因而造成了内存的浪费。</p><h4 id="2）-内存泄漏的分类"><a href="#2）-内存泄漏的分类" class="headerlink" title="2） 内存泄漏的分类"></a>2） 内存泄漏的分类</h4><ol><li><p>堆内存泄漏</p></li><li><p>系统资源泄漏</p><p>程序使用系统分配的资源比如 <code>Bitmap, handle, SOCKET</code> 等没有使用相应的函数释放掉，导致系统资源的浪费，</p></li><li><p>没有将基类的析构函数定义为虚函数</p><p>当基类的指针指向子类对象时，如果基类的析构函数不是virtual， 那么子类的析构函数将不会调用，子类的资源没有正确释放，因此造成内存泄漏</p></li></ol><h4 id="3）什么操作会导致内存泄漏"><a href="#3）什么操作会导致内存泄漏" class="headerlink" title="3）什么操作会导致内存泄漏"></a>3）什么操作会导致内存泄漏</h4><p>指针指向改变，未释放动态分配内存</p><h4 id="4）如何防止内存泄漏"><a href="#4）如何防止内存泄漏" class="headerlink" title="4）如何防止内存泄漏"></a>4）如何防止内存泄漏</h4><p>将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；</p><p>使用智能指针</p><p><strong>注意</strong>：当派生类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动态绑定，只会调用基类的析构函数，导致派生类资源无法释放，造成内存泄漏。构造函数则不应该被定义为虚构函数。</p><h2 id="2、C-面向对象"><a href="#2、C-面向对象" class="headerlink" title="2、C++面向对象"></a>2、C++面向对象</h2><h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>C++通过 <code>public、proected、private</code> 三个关键字来控制成员变量和成员函数的访问劝降，他们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p><p>在雷达内部（定义类的代码内部），无论成员被声明为 <code>public、protected、还是private</code>, 都是可以互相访问的，没有访问权限的限制</p><p>在类的外部，只能通过对象访问成员，并且通过对象只能访问 <code>public</code> 属性的成员，不能访问<code>private、protected</code> 属性的成员</p><p>无论<strong>共有继承、私有和保护继承</strong>，私有成员不能被“派生类”访问，基类中的共有和保护成员能被“派生类”访问。</p><p>对于<strong>共有继承</strong>，只有基类中的共有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象”访问。对于<strong>私有和保护继承</strong>，基类中的所有成员不能被“派生类对象”访问</p><h4 id="1）继承"><a href="#1）继承" class="headerlink" title="1）继承"></a>1）继承</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>让某种类型的对象获得另一个类型对象的属性和方法</p><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能实现扩展</p><h5 id="常见的继承有三种方式："><a href="#常见的继承有三种方式：" class="headerlink" title="常见的继承有三种方式："></a>常见的继承有三种方式：</h5><ol><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类提供实现的能力</li><li>可视继承：指子类使用基类的外观和实现代码的能力</li></ol><h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><p>将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，又可以在此基础上扩展跳舞、唱歌等特有的方法。</p><h4 id="2）封装"><a href="#2）封装" class="headerlink" title="2）封装"></a>2）封装</h4><h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>将数据和代码捆绑在一起，避免外界的干扰和不确定性访问</p><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，</p><h5 id="例如：-1"><a href="#例如：-1" class="headerlink" title="例如："></a>例如：</h5><p>公共的数据或方法使用 <code>public</code> 修饰，而不希望被访问的使用 <code>private</code> 修饰。</p><h4 id="3）多态"><a href="#3）多态" class="headerlink" title="3）多态"></a>3）多态</h4><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>同一事务表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）</p><h5 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h5><p>多态性是允许你将父对象设置成为和一个或多个的它的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作；</p><p><strong>简单一句话：允许将子类类型的指针赋值给父类类型的指针</strong></p><h5 id="实现多态的两种方式"><a href="#实现多态的两种方式" class="headerlink" title="实现多态的两种方式"></a>实现多态的两种方式</h5><ol><li><p><strong>覆盖（override）</strong>：是指子类重新定义父类的虚函数的做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">Class Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>重载（overload）</strong>：是指允许存在多个同名的函数，而这些函数的参数表不同（或者个数不同，或许参数的类型不同，或者都不同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="例如：-2"><a href="#例如：-2" class="headerlink" title="例如："></a>例如：</h5><p>基类是一个抽象对象——人，那学生、运动员也是人，而使用这个抽象对象既可以表示学生，也可以表示运动员</p><h3 id="C-的多态如何实现"><a href="#C-的多态如何实现" class="headerlink" title="C++的多态如何实现"></a>C++的多态如何实现</h3><p>C++中的多态性是通过虚函数（virtual function）和 虚函数表（vtable） 来实现的。多态性允许在基类类型的指针或引用上调用派生类对象的函数，以便在运行时选择正确的函数实现。</p><ol><li><p>基类声明虚函数：在基类中声明虚函数，使用 <code>virtual</code> 关键字，以便在派生类可以重写（override）这些函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 基类的默认实现</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>派生类重写虚函数：在派生类中重写基类中声明的虚函数，使用 <code>override</code> 关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 派生类实现</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>使用基类类型的指针或引用指向派生类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shape* shapePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br></code></pre></td></tr></table></figure></li><li><p>调用虚函数：通过基类指针或引用调用虚函数。在运行时，系统会根据对象的实际类型来选择正确的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">shapePtr-&gt;<span class="hljs-built_in">draw</span>();<span class="hljs-comment">// 调用的是 Circle 类的 draw（） 函数</span><br></code></pre></td></tr></table></figure></li><li><p>虚函数表：编译器在对象的内存布局中维护了一个虚函数表，其中存储了指向实际函数的指针。这个表在运行时用于动态查找调用的函数。</p></li></ol><h3 id="构造函数种类"><a href="#构造函数种类" class="headerlink" title="构造函数种类"></a>构造函数种类</h3><ol><li><p>默认构造函数</p></li><li><p>带参数的构造函数</p></li><li><p>拷贝构造函数：用于通过已存在的对象创建一个新对象，新对象是原对象的副本。参数通常是对同类型对象的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass &amp;other)<br>&#123;<br><span class="hljs-comment">// 进行深拷贝或者浅拷贝，根据实际情况</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>委托构造函数：在一个构造函数中调用另一个构造函数，减少代码重复。通过成员初始化列表或构造函数体内部调用其他构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>)<br>    &#123;<br>        <span class="hljs-comment">// 委托给带参数的构造函数</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value)<br>    &#123;<br>        <span class="hljs-comment">// 进行初始化操作</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h3 id="深拷贝和浅拷贝的区别-P49"><a href="#深拷贝和浅拷贝的区别-P49" class="headerlink" title="深拷贝和浅拷贝的区别  P49"></a>深拷贝和浅拷贝的区别  P49</h3><p><strong>主要区别在于如何处理对象内部的动态分配的资源</strong></p><h4 id="1）深拷贝"><a href="#1）深拷贝" class="headerlink" title="1）深拷贝"></a>1）深拷贝</h4><p>深拷贝是对对象的完全独立复制，包括对象内部动态分配的资源。在深拷贝中，不仅复制对象的值，还会复制对象所指向的堆上的数据。</p><h5 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h5><ul><li>复制对象及其所有成员变量的值</li><li><strong>动态分配的资源也会被复制，新对象拥有自己的一份资源副本</strong></li></ul><p>深拷贝通常涉及到手动内存分配，并在拷贝构造函数或赋值操作符中进行资源的复制</p><h4 id="2）浅拷贝"><a href="#2）浅拷贝" class="headerlink" title="2）浅拷贝"></a>2）浅拷贝</h4><p>浅拷贝仅复制对象的值，而不涉及对象内部动态分配的资源。在浅拷贝中，新对象和原对象共享相同的资源，而不是复制一份新的资源。</p><h5 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h5><ul><li>复制对象及其所有成员变量的值</li><li>对象内部动态分配的资源不会被复制，新对象和原对象共享同一份资源</li></ul><p>浅拷贝通常使用默认的拷贝构造函数和赋值操作符，因为他们会逐成员的复制原对象的值</p><h2 id="3、C-新特性"><a href="#3、C-新特性" class="headerlink" title="3、C++新特性"></a>3、C++新特性</h2><h3 id="C-11的新特性有哪些"><a href="#C-11的新特性有哪些" class="headerlink" title="C++11的新特性有哪些"></a>C++11的新特性有哪些</h3><h4 id="1）语法的改进"><a href="#1）语法的改进" class="headerlink" title="1）语法的改进"></a>1）语法的改进</h4><ol><li>统一的初始化方法</li><li>成员变量默认初始化</li><li><strong>auto关键字：允许编译器自动推断变量的类型，减少类型声明的冗余</strong></li><li>decltype 求表达式的类型</li><li><strong>智能指针</strong> <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code></li><li>空指针nullptr：提供了明确表示空指针的关键字，替代了传统的 <code>NULL</code></li><li>基于范围的 for 循环：简化遍历容器元素的语法</li><li>右值引用和move语义 引入右值引用和移动构造函数，允许高效地将资源从一个对象移动到另一个对象，提高性能</li></ol><h4 id="2）标准库扩充"><a href="#2）标准库扩充" class="headerlink" title="2）标准库扩充"></a>2）标准库扩充</h4><ol><li>无需容器（哈希表）用法和功能同map一摸一样，区别在于哈希表的效率更高</li><li>正则表达式 可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串</li><li>Lambda表达式：允许在代码中定义匿名函数</li></ol><h3 id="智能指针（重要）"><a href="#智能指针（重要）" class="headerlink" title="智能指针（重要）"></a>智能指针（重要）</h3><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><h4 id="1）auto"><a href="#1）auto" class="headerlink" title="1）auto"></a>1）auto</h4><p><strong>auto</strong>可以让编译器在编译器就推导出变量的类型</p><ol><li>auto的使用必须马上初始化，否则就无法推导出类型</li><li>auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败</li><li>auto不能用作函数参数</li><li>在类中auto不能作非静态成员变量</li><li>auto不能定义数组，可以定义指针</li><li>auto无法推导出模板参数</li><li>在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定</li><li>在声明为引用或者指针时，auto会保留等号右边的引用和cv属性</li></ol><h4 id="2）decltype"><a href="#2）decltype" class="headerlink" title="2）decltype"></a>2）decltype</h4><p>decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</p><p>对于 <code>decltype(exp)</code> 有：</p><ol><li><code>exp</code> 是表达式，decltype(exp)和exp类型相同</li><li><code>exp</code> 是函数调用，decltype(exp)和函数返回值类型相同</li><li>其他情况，若 <code>exp</code> 是左值，decltype(exp) 是 exp类型的左值</li></ol><p>auto和decltype的配合使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> t + u;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>左值右值</p><p>左值：可以放在等号左边，可以取地址并有名字正式工</p><p>右值：不可以放在等号左边，不能取地址，没有名字 临时工</p><p>字符串字面值 “abcd” 也是左值，不是右值</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++</span><span class="hljs-comment">i</span><span class="hljs-string">,</span> <span class="hljs-literal">--</span><span class="hljs-comment">i 是左值，   i</span><span class="hljs-literal">++</span><span class="hljs-string">,</span> <span class="hljs-comment">i</span><span class="hljs-literal">--</span> <span class="hljs-comment">是右值</span><br></code></pre></td></tr></table></figure><h4 id="1）将亡值"><a href="#1）将亡值" class="headerlink" title="1）将亡值"></a>1）将亡值</h4><p>将亡值是指C++11新增的和右值引用相关的表达式</p><p>将亡值可以理解为<strong>即将要销毁的值</strong>，通过“盗取”其他变量内存空间方式获取的值，在确保其他变量不再被使用或者即将销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务</p><h4 id="2）左值引用"><a href="#2）左值引用" class="headerlink" title="2）左值引用"></a>2）左值引用</h4><p>左值引用就是对左值进行引用的类型，是对象的一个别名</p><p>并不拥有所绑定对象的堆栈，所以必须立刻初始化。对于左值引用，等号右边的值可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式</p><h4 id="3）右值引用"><a href="#3）右值引用" class="headerlink" title="3）右值引用"></a>3）右值引用</h4><p>表达式等号右边的值需要是右值，可以使用std::move函数强制把左值转换为右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;r = i;<span class="hljs-comment">// 正确：r 引用 i</span><br><span class="hljs-type">int</span> &amp;&amp;rr = i;<span class="hljs-comment">// 错误：不能将一个右值引用绑定到一个左值上</span><br><span class="hljs-type">int</span> &amp;r2 = i * <span class="hljs-number">42</span>;<span class="hljs-comment">// 错误：i * 42 是一个右值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确： 可以将一个const的引用绑定到一个右值上</span><br><span class="hljs-type">int</span> &amp;&amp;rr2 = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确：将rr2 绑定到乘法结果上 </span><br></code></pre></td></tr></table></figure><h4 id="4）移动语义"><a href="#4）移动语义" class="headerlink" title="4）移动语义"></a>4）移动语义</h4><p>可以理解为转移所有权，对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不在拥有也不会再使用。</p><h4 id="5）完美转发"><a href="#5）完美转发" class="headerlink" title="5）完美转发"></a>5）完美转发</h4><p>写一个接收任意实参的函数模板，并转发到其他函数，目标函数会收到与转发函数完全相同的实参，通过 <code>std::forward()</code> 实现。</p><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>nullptr是代替NULL，一半C++会把NULL、0视为同一种东西，这取决编译器如何定义NULL，有的定义为 <code>((void*)0)</code>,有的定义为0；</p><p>C++不允许直接将 <code>void*</code> 隐式转换为其他类型，在进行C++重载时会发生混乱</p><p>C++11引入 <code>nullptr</code>关键字<strong>来区分空指针和0</strong>。nullptr的类型为nullptr_t，能够转换为任何指针或成员指针的类型，也可以进行相等或不等的比较。</p><h3 id="范围-for-循环"><a href="#范围-for-循环" class="headerlink" title="范围 for 循环"></a>范围 <code>for</code> 循环</h3><p>基于范围的迭代写法，<code>for(变量：对象)</code>表达式</p><p>对string对象的每个字符做一些操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">str</span> <span class="hljs-params">(<span class="hljs-string">&quot;some thing&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str)cout &lt;&lt; c &lt;&lt; endl;<span class="hljs-comment">// 输出字符串str中的每个字符</span><br></code></pre></td></tr></table></figure><p>对vector中的元素进行遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-keyword">for</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator i = arr.<span class="hljs-built_in">begin</span>(); i != arr.<span class="hljs-built_in">end</span>(); i++)<br>&#123;<br>std::cout &lt;&lt; *i &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 范围for循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;i : arr)<br>&#123;<br>    std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>C++定义了几种初始化方法，例如对一个int变量x初始化为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> x = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> x&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>采用花括号来进行初始化称为列表初始化，无论是初始化对象还是为对象赋新值</p><p>用于对内置类型变量时，如果使用列表初始化，且初始值存在丢失信息风险时，编译器会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> d = <span class="hljs-number">3.1415926536</span>;<br><span class="hljs-type">int</span> a = &#123;d&#125;;<span class="hljs-comment">// 存在丢失信息风险，转换未执行</span><br><span class="hljs-type">int</span> a = d;<span class="hljs-comment">// 确实丢失信息，转换执行</span><br></code></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式<strong>表示一个可调用的代码单元</strong>，没有命名的内联函数，不需要函数名因为我们直接（一次性的）用它，不需要其他地方调用它。</p><h4 id="1）lambda表达式的语法"><a href="#1）lambda表达式的语法" class="headerlink" title="1）lambda表达式的语法"></a>1）lambda表达式的语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (parameter list) -&gt; <span class="hljs-keyword">return</span> type &#123;function body&#125;<br><span class="hljs-comment">// [捕获列表] （参数列表） -&gt; 返回类型 &#123;函数体&#125;</span><br><span class="hljs-comment">// 只有 [capture list] 捕获列表和 &#123;function body &#125; 函数体是必选的</span><br><br><span class="hljs-keyword">auto</span> lam = []() -&gt; <span class="hljs-type">int</span> &#123;cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">88</span>; &#125;;<br><span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">lam</span>();<br>cout &lt;&lt; ret &lt;&lt; endl;  <span class="hljs-comment">// 输出88</span><br></code></pre></td></tr></table></figure><p>-&gt;int 表示此匿名函数返回 int ,大多数情况下 lambda 表达式的返回值可由编译器猜测得出，因此不需要我们指定返回值类型。</p><h4 id="2）lambda-表达式的特点"><a href="#2）lambda-表达式的特点" class="headerlink" title="2）lambda 表达式的特点"></a>2）lambda 表达式的特点</h4><h5 id="（1）变量捕获才是成就lambda卓越的秘方"><a href="#（1）变量捕获才是成就lambda卓越的秘方" class="headerlink" title="（1）变量捕获才是成就lambda卓越的秘方"></a>（1）变量捕获才是成就lambda卓越的秘方</h5><ol><li>[] 不捕获任何变量，这种情况下lambda表达式内部不能访问外部变量</li><li>[&amp;] 以引用的方式捕获所有变量（保证lambda执行时变量存在）</li><li>[&#x3D;] 用值的方式捕获所有变量（创建时拷贝，修改对lambda内对象无影响）</li><li>[&#x3D;, &amp;foo] 以引用捕获变量foo,但其余变量都靠值捕获</li><li>[&amp;, foo] 以值捕获foo，但其余变量都靠引用捕获</li><li>[bar] 以值方式捕获bar；不捕获其他变量</li><li>[this] 捕获所在类的this指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> lam2 = [&amp;, a]()<span class="hljs-comment">// b,c以引用捕获，a以值捕获</span><br>&#123;<br>    b = <span class="hljs-number">5</span>;<br>    c = <span class="hljs-number">6</span>;<span class="hljs-comment">// a = 1, a 不能赋值</span><br>    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;<span class="hljs-comment">// 输出1 5 6</span><br>&#125;;<br><span class="hljs-built_in">lam2</span>();<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span><span class="hljs-comment">// 值捕获</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> f = [v1] &#123;<span class="hljs-keyword">return</span> v1;&#125;;<br>    v1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> k = <span class="hljs-built_in">f</span>();<span class="hljs-comment">// j = 42, 创建时拷贝，修改对lambda内对象无影响</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">auto</span> f = [v1] () <span class="hljs-keyword">mutable</span> &#123;<span class="hljs-keyword">return</span> ++v1;&#125;;<span class="hljs-comment">// 修改值捕获可加 mutable</span><br>    v1 = <span class="hljs-number">0</span>；<br>    <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>();<span class="hljs-comment">// j = 43;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span><span class="hljs-comment">// 引用捕获</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<span class="hljs-comment">// 非 const </span><br>    <span class="hljs-keyword">auto</span> f = [&amp;v1] () &#123;<span class="hljs-keyword">return</span> ++v1;&#125;;<br>    v1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>();<span class="hljs-comment">// 注意此时 j = 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="（2）lambda最大的一个优势是在使用STL中的算法（algorithms）库"><a href="#（2）lambda最大的一个优势是在使用STL中的算法（algorithms）库" class="headerlink" title="（2）lambda最大的一个优势是在使用STL中的算法（algorithms）库"></a>（2）lambda最大的一个优势是在使用STL中的算法（algorithms）库</h5><p><strong>例如：数组排序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span><span class="hljs-comment">// 谓词函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>std::<span class="hljs-built_in">sort</span>(arr, arr + <span class="hljs-number">6</span>, compare);<br><br><span class="hljs-comment">// lambda形式</span><br>std::<span class="hljs-built_in">sort</span>(arr, arr + <span class="hljs-number">6</span>, [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)&#123;<span class="hljs-keyword">return</span> a &gt; b;&#125;);<span class="hljs-comment">// 降序</span><br><br>std::for_each(<span class="hljs-built_in">begin</span>(arr), <span class="hljs-built_in">end</span>(arr), [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;e)(cout &lt;&lt; <span class="hljs-string">&quot;After:&quot;</span> &lt;&lt; e &lt;&lt; endl;));<span class="hljs-comment">// 6 5 4 3 2 1</span><br></code></pre></td></tr></table></figure><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3>]]></content>
    
    
    
    <tags>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔试题目总结</title>
    <link href="/2024/09/03/%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/03/%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="秋招笔试题目"><a href="#秋招笔试题目" class="headerlink" title="秋招笔试题目"></a>秋招笔试题目</h1><h2 id="招银科技"><a href="#招银科技" class="headerlink" title="招银科技"></a>招银科技</h2><h3 id="最短连续字串"><a href="#最短连续字串" class="headerlink" title="最短连续字串"></a>最短连续字串</h3><p>有双人说话游戏， A先说一个长的英文句子，把所有小写字母和大写字母按照原来的顺序抽出来（不超过1000个字母），形成字符串 str1， B先说一个短的英文句子，把所有小写字母和大写字母按照原来的顺序抽出来（不超过1000个字母），形成字符串 str2， 请根据AB说出的英文句子，快速找出 str1 中包含了 str2 中的所有字符的最短连续子串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">string <span class="hljs-title">extractAlphabets</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span> </span>&#123;<br>    string result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(c)) &#123;  <span class="hljs-comment">// 仅提取英文大小写字母</span><br>            result += c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">findMinWindow</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str2.<span class="hljs-built_in">empty</span>() || str1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; str2_count;<span class="hljs-comment">// 统计str2中各字母出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str2) &#123;<br>        str2_count[c]++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> required = str2_count.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 记录str2中不同字符的数量</span><br>    <span class="hljs-type">int</span> formed = <span class="hljs-number">0</span>;<span class="hljs-comment">// 跟踪当前窗口中匹配了多少个字符，初始值为0</span><br><br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window_counts; <span class="hljs-comment">// 哈希表，用于记录当前窗口中各字符的频率</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<span class="hljs-comment">// 滑动窗口的左右界</span><br>    <span class="hljs-type">int</span> min_len = INT_MAX, start = <span class="hljs-number">0</span>;<span class="hljs-comment">// 用于记录最小字串的长度，和起始位置</span><br><br>    <span class="hljs-keyword">while</span> (r &lt; str1.<span class="hljs-built_in">size</span>()) &#123;<span class="hljs-comment">// 滑动窗口的右边界扩展</span><br>        <span class="hljs-type">char</span> c = str1[r];<br>        window_counts[c]++;<br>        <span class="hljs-comment">// 检查当前窗口中是否匹配目标字符</span><br>        <span class="hljs-keyword">if</span> (str2_count.<span class="hljs-built_in">count</span>(c) &amp;&amp; window_counts[c] == str2_count[c]) &#123;<br>            formed++; <span class="hljs-comment">// 如果当前字符 c 在 str2 中且其频率达到所需数量，formed 增加1。</span><br>        &#125;<br><span class="hljs-comment">// 缩小窗口以寻找最短子串</span><br>        <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; formed == required) &#123;<br>            c = str1[l];<br><span class="hljs-comment">// 检查当前窗口的大小，如果比当前记录的最小窗口还小，更新 min_len 和 start，记录最小子串的长度和起始位置。</span><br>            <span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &lt; min_len) &#123;<br>                min_len = r - l + <span class="hljs-number">1</span>;<br>                start = l;<br>            &#125;<br><br>            window_counts[c]--;<span class="hljs-comment">// 将窗口的左边界 l 右移，减少窗口的大小</span><br>            <span class="hljs-keyword">if</span> (str2_count.<span class="hljs-built_in">count</span>(c) &amp;&amp; window_counts[c] &lt; str2_count[c]) &#123;<br>                formed--;<span class="hljs-comment">// 并在 window_counts 中减少相应字符的计数。</span><br>            &#125;<br>            <span class="hljs-comment">// 左边界收缩</span><br>            l++;<br>        &#125;<br>        r++;<br>    &#125;<br>    <span class="hljs-comment">// 如果找不到满足条件的子串，返回空字符串；否则，返回最小窗口对应的子串。</span><br>    <span class="hljs-keyword">return</span> min_len == INT_MAX ? <span class="hljs-string">&quot;&quot;</span> : str1.<span class="hljs-built_in">substr</span>(start, min_len);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str1, str2;<br>   cin &gt;&gt; str1;<br>    cin &gt;&gt; str2;<br><br>    <span class="hljs-comment">// 提取英文大小写字母</span><br>    str1 = <span class="hljs-built_in">extractAlphabets</span>(str1);<br>    str2 = <span class="hljs-built_in">extractAlphabets</span>(str2);<br><br>    string result = <span class="hljs-built_in">findMinWindow</span>(str1, str2);<br><br>    <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">empty</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; result &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><h3 id="小美种树"><a href="#小美种树" class="headerlink" title="小美种树"></a>小美种树</h3><p>长度无限长的公路上，小美雇佣了 n 位工人来种树，每个点最多种一棵树。</p><p>从左向右数，工人所站的位置为 a1,a2,…,an 。已知每位工人都会将自己所在位置的右侧一段长度的区间种满树，且每位工人的种树区间长度相同。</p><p>现在小美希望公路上至少有 k棵树，为了节约成本，他希望每位工人种树的区间长度尽可能短，请你帮他求出，工人们的种树区间至少多长，才能使得公路被种上至少 k棵树。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><p>第一行输入两个正整数 n,k(1&lt;&#x3D;n,k&lt;&#x3D;2*10^5),分别表示工人的数量，以及小美要求树的最少数量。</p><p>第二行输入 n个正整数 a1,a2,…,an(1&lt;&#x3D;ai&lt;&#x3D;2*10^5)，表示每名工人的位置。</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>在一行上输出一个整数，代表工人们最短的种树区间长度。</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入<br>3 6<br>1 2 5<br>输出<br>3<br>说明<br>每位工人种树的区间长度至少为 3。<br>这样以来：<br>第一名工人种：1,2,3 点的树。<br>第二名工人种：2,3,4 点的树。<br>第三名工人种：5,6,7点的树。<br>由于每个位置最多种一棵树，因此共有：1,2,3,4,5,6,7 这些点有树，满足至少 <span class="hljs-attribute">k</span>=6棵树。<br><br>可以证明，不存在比 3 更小的答案。<br></code></pre></td></tr></table></figure><h4 id="思路和代码"><a href="#思路和代码" class="headerlink" title="思路和代码"></a>思路和代码</h4><p>二分答案。</p><p>我们来二分枚举每个人种树的区间，用一个check函数来判断种树的区间为x的适合，是否可以种k棵树？</p><p>首先将数组进行排序，对于每一个人可以种的树的逻辑是：尽量往后种，在不超过之前的覆盖的前提下。</p><p>bd记录的是上一次种到的边界，当前可以种的边界应该是 a+x，只要保证不会超过边界即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> A[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">// 记录当前情况下能够种植的总树数</span><br>    <span class="hljs-type">int</span> ed = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 上一次种树的最远边界</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-comment">// 如果当前的范围 a + x 能够种植一棵新树，且不与上一次种植的树重叠</span><br>        <span class="hljs-keyword">if</span>(A[i] + m &gt; <span class="hljs-built_in">max</span>(A[i], ed))<br>            cnt += (A[i] + m) - <span class="hljs-built_in">max</span>(A[i], ed);<br>        ed = <span class="hljs-built_in">max</span>(A[i] + m, ed);<span class="hljs-comment">// 更新当前种植的最远边界。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt &gt;= k;<span class="hljs-comment">//  函数返回 cnt 是否大于或等于 k，即是否能够种植至少 k 棵树。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; A[i];<br>    <br>    <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = N;<br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> != r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    cout &lt;&lt; r &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法，秋招笔试/面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识</title>
    <link href="/2024/08/05/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/08/05/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*********************************** 终端 *********************************** */</span><br>pwd<span class="hljs-comment">// 显示当前路径</span><br>rmdir   <span class="hljs-comment">// 删除空目录rm -rf 目录名</span><br>mkdir<span class="hljs-comment">// 创建文件夹</span><br>ls/ll<span class="hljs-comment">// 查看目录或文件信息-l 列出详细信息-a列出当前目录下的所有文件</span><br>vi<span class="hljs-comment">// 文本编辑器</span><br>i 进入编辑状态ESC 退出编辑:q! 不保存退出:wq 保存退出G 定位到文件末尾<br>cp<span class="hljs-comment">// 复制cp [选项] 文件名或目录 目标地址-R全部目录和文件</span><br>cp a.txt b.txt 将文件a复制并命令为b文件<br>mv<span class="hljs-comment">// 移动mv 文件名或目录 目标目录</span><br>rm<span class="hljs-comment">// 删除文件或目录-f 强制删除 -r 删除目录</span><br>grep<span class="hljs-comment">// 分析一行的信息，如果存在所需信息，打印输出 grep 字符串 文件名(grep band file)</span><br>find <span class="hljs-comment">// 查找文件find [路径] [选项]find . -name *log 在当前目录查找以.log结尾的文件</span><br>ps <span class="hljs-comment">// 查看进程（动态）-ef 显示所有运行进程，并显示启动进程的命令</span><br>netstat<span class="hljs-comment">// 查看网络状况（net status的简写）</span><br>netstat -apn 查看所有端口 -an 按一定顺序排列输出p 表示显示那个进程在调用<br>   -a所有的socket -p 显示正在使用socket的程序的名称-n 直接使用IP地址，而不通过域名服务器<br>|<span class="hljs-comment">// 管道符在命令之间建立管道，将前面命令的输出作为后面命令的输入</span><br>通过命令查找tomcat进程：ps -ef | grep tomcat <br>通过命令查找到占用此端口的进程编号：netstat -apn|grep <span class="hljs-number">8080</span><br>touch <span class="hljs-comment">// 创建一个空白文件-a 修改access(访问) 时间-m 修改modfiy(修改)时间</span><br>su<span class="hljs-comment">// 切换用户su root</span><br>chmod<span class="hljs-comment">// 权限赋予命令 -R 递归改变目录下所有子目录和文件的权限(可读可写可执行) r=4 w=2 x=1</span><br>chmod <span class="hljs-number">777</span> lemon<br>tar<span class="hljs-comment">// 解压,压缩</span><br>tar -czvf test.tar.gz test将test压缩 tar -xzvf test.tar.gz解压tast<br><br>which <span class="hljs-comment">// 查找文件、显示命令路径which pwd</span><br>whereis <span class="hljs-comment">// 定位可执行文件、帮助文件和原文件代码在系统中的位置</span><br>whereis [选项] [路径/目录名 -f] 文件名<br><br>cat <span class="hljs-comment">// 显示文本文件内容cat 文件名字</span><br>head <span class="hljs-comment">// 查看前几行head -n 5 文件名字</span><br>tail<span class="hljs-comment">// 从指定点开始将文件写到标准输出tail -n 5 文件名     查看后几行 tail -f</span><br>echo <span class="hljs-comment">// 打印文件内容或编辑文件内容</span><br>uname<span class="hljs-comment">// 查看系统-m 查看系统是几位操作系统 -r 查看系统的内核版本 -a 查看详细的系统内核版本和系统的操作系统</span><br>rz<span class="hljs-comment">// 上传</span><br>sz<span class="hljs-comment">// 下载</span><br>history<span class="hljs-comment">// 查看命令历史记录</span><br>ssh 用户名@ip地址:<span class="hljs-number">22</span>  <span class="hljs-comment">// ssh连接远程服务器   ssh zy@192.168.130.111:22</span><br>        <br><span class="hljs-comment">/*********************************** 线程相关 *********************************** */</span><br>ps –Lf pid   <span class="hljs-comment">// 查看指定进程的 LWP 号</span><br>        <span class="hljs-comment">// 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC使用</title>
    <link href="/2024/08/01/GCC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/08/01/GCC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GCC使用"><a href="#GCC使用" class="headerlink" title="GCC使用"></a>GCC使用</h1><p><a href="https://blog.csdn.net/qq_42037383/article/details/140217436">原文链接</a></p><p> GCC（GUN Compiler Collection）是一个开源的编译器套件，支持多种编程语言，包括 C、C++、Objective-C、Fortran、Ada 等。它是 Linux 和许多 Unix-like 系统中的默认编译器，也可以在 Windows 等平台上使用。</p><h2 id="GCC的基本用法"><a href="#GCC的基本用法" class="headerlink" title="GCC的基本用法"></a>GCC的基本用法</h2><h3 id="1、编译-C-程序"><a href="#1、编译-C-程序" class="headerlink" title="1、编译 C 程序"></a>1、编译 C 程序</h3><p>gcc编译器将c源文件到生成一个可执行程序，中间一共经历了四个步骤：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">                     c文件                 汇编文件          二进制文件      可执行文件<br><span class="hljs-function"><span class="hljs-title">hello</span>.c   ---&gt;</span>      <span class="hljs-function"><span class="hljs-title">hello</span>.i     ---&gt;</span>      <span class="hljs-function"><span class="hljs-title">hello</span>.s   ---&gt;</span>   <span class="hljs-function"><span class="hljs-title">hello</span>.o  ---&gt;</span>   a.out<br>         预处理（CPP）         编译器（gcc）          汇编器(<span class="hljs-keyword">as</span>)       链接器(ld)<br>         gcc -E                gcc -S                 gcc -c           gcc<br></code></pre></td></tr></table></figure><p>下面以hello.c为例介绍gcc的四个步骤:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E hello.c -o hello.i <span class="hljs-comment"># -E激活预处理，生成预处理后的文件</span><br>gcc -S hello.i -o hello.s <span class="hljs-comment"># —S激活预处理和编译，生成汇编代码</span><br>gcc -c hello.s -o hello.o <span class="hljs-comment"># -c激活预处理、编译和汇编，生成目标文件</span><br>gcc hello.o -o hello <span class="hljs-comment"># 执行所有阶段，生成可执行程序</span><br></code></pre></td></tr></table></figure><p>其实没必要指定每一个步骤，我们常常会这样用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c hello.c <span class="hljs-comment"># 生成目标文件，gcc会根据文件名hello.c生成hello.o</span><br>gcc hello.o -o hello <span class="hljs-comment"># 生成可执行程序hello，这里我们需要指定可执行程序的名称，否则会默认生成a.out</span><br></code></pre></td></tr></table></figure><p>一步生成最终的可执行程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc hello.c -o hello <span class="hljs-comment"># 编译链接，生成可执行程序hello</span><br></code></pre></td></tr></table></figure><h3 id="2、GCC常用参数选项"><a href="#2、GCC常用参数选项" class="headerlink" title="2、GCC常用参数选项"></a>2、GCC常用参数选项</h3><table><thead><tr><th align="center"><strong>gcc编译选项</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-E</td><td align="center">预处理指定的源文件，不进行编译</td></tr><tr><td align="center">-S</td><td align="center">编译指定的源文件，但是不进行汇编</td></tr><tr><td align="center">-C</td><td align="center">编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td align="center">-o [file1] [file2] &#x2F; [file2] -o [file1]</td><td align="center">将文件 file2 编译成可执行文件 file1</td></tr><tr><td align="center">-I directory</td><td align="center">指定include包含文件的搜索目录</td></tr><tr><td align="center">-g</td><td align="center">在编译的时候生成调试信息，该程序可以被调试器调试</td></tr><tr><td align="center">-D</td><td align="center">在程序编译的时候，指定一个宏</td></tr><tr><td align="center">-w</td><td align="center">不生成任何警告信息</td></tr><tr><td align="center">-Wall</td><td align="center">生成所有警告信息</td></tr><tr><td align="center">-On</td><td align="center">n的取值范围：0~3，编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td align="center">-l</td><td align="center">在程序编译时，指定使用的库</td></tr><tr><td align="center">-L</td><td align="center">指定编译的时候，搜索的库的路径</td></tr><tr><td align="center">-fPIC&#x2F;fpic</td><td align="center">生成与位置无关的代码</td></tr><tr><td align="center">-shared</td><td align="center">生成共享目标文件，通常用在建立共享库</td></tr><tr><td align="center">-std</td><td align="center">指定c方法，如：-std&#x3D;c99，gcc默认的方言时GNU C</td></tr></tbody></table><h2 id="GDB使用"><a href="#GDB使用" class="headerlink" title="GDB使用"></a>GDB使用</h2><h3 id="1、什么时GDB"><a href="#1、什么时GDB" class="headerlink" title="1、什么时GDB"></a>1、什么时GDB</h3><p> GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</p><p> 一般来说，GDB 主要帮助你完成下面四个方面的功能：</p><ul><li>启动程序，可以按照自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时程序中所发生的事</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG</li></ul><h3 id="2、怎么使用GDB"><a href="#2、怎么使用GDB" class="headerlink" title="2、怎么使用GDB"></a>2、怎么使用GDB</h3><p>通常，在为调试而编译时，我们会（）关掉编译器的优化选项（ -O ）， 并打开调试选项（ -g ）。 另外， -Wall 在尽量不影响程序行为的情况下选项打开所有 warning，也可以发现许多问题，避免 一些不必要的 BUG。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -Wall program.c -o program<br>gcc test.c -o <span class="hljs-built_in">test</span> -g<br></code></pre></td></tr></table></figure><p>-g 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代 码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</p><h3 id="3、GDB的命令"><a href="#3、GDB的命令" class="headerlink" title="3、GDB的命令"></a>3、GDB的命令</h3><table><thead><tr><th align="center">功能</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">启动<br />退出</td><td align="center">gdb 可执行程序<br />quit&#x2F;q</td></tr><tr><td align="center">给程序设置参数&#x2F;获取设置参数</td><td align="center">set args 10 20  &#x2F;   show args</td></tr><tr><td align="center">GDB使用帮助</td><td align="center">help</td></tr><tr><td align="center">查看当前文件代码</td><td align="center">list&#x2F;l  (从默认位置显示)<br />list&#x2F;l 行号  (从指定的行显示)<br />list&#x2F;l  函数名  （从指定的函数显示）</td></tr><tr><td align="center">查看非当前文件代码</td><td align="center">list&#x2F;l  文件名:行号&#x2F;函数名</td></tr><tr><td align="center">设置显示行数</td><td align="center">show list&#x2F;listsize<br />set list&#x2F;listsize 行数</td></tr><tr><td align="center">设置断点</td><td align="center">b&#x2F;break 行号<br />b&#x2F;break 函数名<br />b&#x2F;break 文件名:行号<br />b&#x2F;break 文件名:函数</td></tr><tr><td align="center">查看断点</td><td align="center">i&#x2F;info b&#x2F;break</td></tr><tr><td align="center">删除断点</td><td align="center">d&#x2F;del&#x2F;delete 断点编号</td></tr><tr><td align="center">设置断点无效</td><td align="center">dis&#x2F;disable 断点编号</td></tr><tr><td align="center">设置断点生效</td><td align="center">ena&#x2F;enable 断点编号</td></tr><tr><td align="center">设置条件断点（一般用在循环的位置）</td><td align="center">b&#x2F;break 10 if i&#x3D;&#x3D;5</td></tr><tr><td align="center">运行GDB程序</td><td align="center">start (程序停在第一行)<br />run (遇到断点才停)</td></tr><tr><td align="center">继续运行，到下一个断点</td><td align="center">c&#x2F;continue</td></tr><tr><td align="center">向下执行一行代码，不会进入函数体</td><td align="center">n&#x2F;next</td></tr><tr><td align="center">变量操作</td><td align="center">p&#x2F;print 变量名 （打印变量值）<br />ptype 变量名 （打印变量类型）</td></tr><tr><td align="center">向下单步调试（遇到函数进入函数体）</td><td align="center">s&#x2F;step<br />finish (跳出函数体)</td></tr><tr><td align="center">自动变量操作</td><td align="center">display 变量名<br />i&#x2F;info display<br />undisplay 编号</td></tr><tr><td align="center">其他操作</td><td align="center">set var 变量名&#x3D;变量值<br />until （跳出循环）</td></tr></tbody></table><h3 id="4、GDB多进程调试"><a href="#4、GDB多进程调试" class="headerlink" title="4、GDB多进程调试"></a>4、GDB多进程调试</h3><p>使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">设置调试父进程或者子进程<br><span class="hljs-built_in">set</span> follow-fork-mode [parent (默认) | child]<br><br>设置调试模式<br><span class="hljs-built_in">set</span> detach-on-fork [on | off]<br>默认为 on， 表示当前进程的时候，其他的进程继续运行，如果为off，调试当前进程的时候，其他进程被GDB挂起<br><br>查看当前调试的进程：  info inferiors<br>切换当前调试的进程： inferior <span class="hljs-built_in">id</span><br>使进程脱离GDB调试： detach inferiors <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex使用</title>
    <link href="/2024/07/12/Latex%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/12/Latex%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Latex使用"><a href="#Latex使用" class="headerlink" title="Latex使用"></a>Latex使用</h1><h2 id="1、如何在Overleaf中采用快速引用参考文献"><a href="#1、如何在Overleaf中采用快速引用参考文献" class="headerlink" title="1、如何在Overleaf中采用快速引用参考文献"></a>1、如何在Overleaf中采用快速引用参考文献</h2><p><a href="https://blog.csdn.net/qq_35831906/article/details/132767074">原文链接</a></p><h3 id="原来的参考文献格式"><a href="#原来的参考文献格式" class="headerlink" title="原来的参考文献格式"></a>原来的参考文献格式</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;thebibliography&#125;&#123;00&#125;<br><span class="hljs-keyword">\bibliography</span>&#123;references&#125;<br><span class="hljs-keyword">\bibitem</span>&#123;b1&#125; G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,&#x27;&#x27; Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.<br><span class="hljs-keyword">\bibitem</span>&#123;b2&#125; J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.<br><span class="hljs-keyword">\bibitem</span>&#123;b3&#125; I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,&#x27;&#x27; in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.<br><span class="hljs-keyword">\bibitem</span>&#123;b4&#125; K. Elissa, ``Title of paper if known,&#x27;&#x27; unpublished.<br><span class="hljs-keyword">\bibitem</span>&#123;b5&#125; R. Nicole, ``Title of paper with only first word capitalized,&#x27;&#x27; J. Name Stand. Abbrev., in press.<br><span class="hljs-keyword">\bibitem</span>&#123;b6&#125; Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,&#x27;&#x27; IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].<br><span class="hljs-keyword">\bibitem</span>&#123;b7&#125; M. Young, The Technical Writer&#x27;s Handbook. Mill Valley, CA: University Science, 1989.<br><span class="hljs-keyword">\end</span>&#123;thebibliography&#125;<br><br></code></pre></td></tr></table></figure><h3 id="新的快速参考方式"><a href="#新的快速参考方式" class="headerlink" title="新的快速参考方式"></a>新的快速参考方式</h3><h3 id="1-1-创建或导入-bib-文件"><a href="#1-1-创建或导入-bib-文件" class="headerlink" title="1.1 创建或导入  .bib 文件"></a>1.1 创建或导入  <code>.bib</code> 文件</h3><ol><li>在项目文件树中点击 “New File”。</li><li>输入 <code>.bib</code> 作为文件名（例如，<code>references.bib</code>）。</li><li>点击 “Upload” 并上传你的 <code>.bib</code> 文件。</li></ol><p>或者在谷歌学术中点击引用，选择 <code>BibTex</code> 格式</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex">@article&#123;b1,// 这里需要改为自己引用的序号<br>  title=&#123;The internet of things: An overview&#125;,<br>  author=&#123;Rose, Karen and Eldridge, Scott and Chapin, Lyman&#125;,<br>  journal=&#123;The internet society (ISOC)&#125;,<br>  volume=&#123;80&#125;,<br>  number=&#123;15&#125;,<br>  pages=&#123;1--53&#125;,<br>  year=&#123;2015&#125;,<br>  publisher=&#123;Reston, VA&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-在文档中引用参考文献"><a href="#1-2-在文档中引用参考文献" class="headerlink" title="1.2 在文档中引用参考文献"></a>1.2 在文档中引用参考文献</h3><p>使用cite包 方式在文档中引用参考文献</p><p>Bibtex 内部包含8种对参考文献排序的方式，通过 bibliographystyle 就可以达到按照自己想法对参考文献排序的目的。分别如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">plain，按字母的顺序排列，比较次序为作者、年度和标题<br>unsrt，样式同plain，只是按照引用的先后排序<br>alpha，用作者名首字母+年份后两位作标号，以字母顺序排序<br>abbrv，类似plain，将月份全拼改为缩写，更显紧凑<br>ieeetr，国际电气电子工程师协会期刊样式<br>acm，美国计算机学会期刊样式<br>siam，美国工业和应用数学学会期刊样式<br>apalike，美国心理学学会期刊样式<br>————————————————<br></code></pre></td></tr></table></figure><h4 id="1-2-1-在文件开头导入需要的包"><a href="#1-2-1-在文件开头导入需要的包" class="headerlink" title="1.2.1  在文件开头导入需要的包"></a>1.2.1  在文件开头导入需要的包</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;cite&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-在正文中添加参考文献：-cite-b1"><a href="#1-2-2-在正文中添加参考文献：-cite-b1" class="headerlink" title="1.2.2 在正文中添加参考文献：\cite{b1]}"></a>1.2.2 在正文中添加参考文献：\cite{b1]}</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">These “smart objects” require minimal human intervention to generate,   exchange, and utilize data with minimal human intervention<span class="hljs-keyword">\cite</span>&#123;b1&#125;. As a new generation of information technology, IoT is characterized by its high integration and comprehensive application. In recent years, the continuous advancements in satellite communication technology have led to the widespread use of satellite IoT as a crucial communication means.<br></code></pre></td></tr></table></figure><p>此处的 \cite{b1} 是ref.bib 文件中的第一条参考文献。</p><p>当文档某处需要引用多个参考文献时，可以使用逗号分隔引用标签，并将它们包含在 \cite{} 命令内。例如，如果你要引用文献 “r1”、”r2” 和 “r3”，可以这样做：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\cite</span>&#123;r1, r2, r3&#125;<br></code></pre></td></tr></table></figure><p>这将在文档中生成一个带有逗号分隔的引用列表，类似于 [1, 2, 3]，其中 “[1]” 表示文献 “r1”，”[2]” 表示文献 “r2”，”[3]” 表示文献 “r3”。</p><p>特例：如下</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\cite</span>&#123;r9, r10, r11, r12, r13&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-文章结尾部分加入：-bibliographystyle-ieeetr-bibliography-references"><a href="#1-2-3-文章结尾部分加入：-bibliographystyle-ieeetr-bibliography-references" class="headerlink" title="1.2.3  文章结尾部分加入：\bibliographystyle{ieeetr}     \bibliography{references},"></a>1.2.3  文章结尾部分加入：\bibliographystyle{ieeetr}     \bibliography{references},</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\bibliographystyle</span>&#123;ieeetr&#125;   <span class="hljs-comment">% 选择引用样式</span><br><span class="hljs-keyword">\bibliography</span>&#123;references&#125;          <span class="hljs-comment">% 参考文献存放目录ref.bib文件</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-编译、生成参考文献列表"><a href="#1-3-编译、生成参考文献列表" class="headerlink" title="1.3  编译、生成参考文献列表"></a>1.3  编译、生成参考文献列表</h3><p>在Overleaf中，你需要使用LaTeX编译器编译你的文档，以生成正确的参考文献列表和引用标记。通常，你需要运行LaTeX编译器多次以处理引用。</p><p> 在LaTeX文档中，使用 <code>\bibliography&#123;&#125;</code> 命令指定你的 <code>.bib</code> 文件名称，并使用 <code>\bibliographystyle&#123;&#125;</code> 命令选择引用的样式。然后，在文档的适当位置使用 <code>\bibliography&#123;&#125;</code> 命令生成参考文献列表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零实现TCP</title>
    <link href="/2024/07/11/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0TCP/"/>
    <url>/2024/07/11/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0TCP/</url>
    
    <content type="html"><![CDATA[<p>斯坦福计网大作业</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a><strong>STL基础</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector, 变长数组，倍增的思想<br>    <span class="hljs-built_in">size</span>()  返回元素个数<br>    <span class="hljs-built_in">empty</span>()  返回是否为空<br>    <span class="hljs-built_in">clear</span>()  清空<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br>    支持比较运算，按字典序<br><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br>string，字符串<br>    <span class="hljs-built_in">size</span>()/<span class="hljs-built_in">length</span>()  返回字符串长度<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">substr</span>(起始下标，(子串长度))  返回子串<br>    <span class="hljs-built_in">c_str</span>()  返回字符串所在字符数组的起始地址<br><br>queue, 队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向队尾插入一个元素<br>    <span class="hljs-built_in">front</span>()  返回队头元素<br>    <span class="hljs-built_in">back</span>()  返回队尾元素<br>    <span class="hljs-built_in">pop</span>()  弹出队头元素<br><br>priority_queue, 优先队列，默认是大根堆<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  插入一个元素<br>    <span class="hljs-built_in">top</span>()  返回堆顶元素<br>    <span class="hljs-built_in">pop</span>()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br>stack, 栈<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向栈顶插入一个元素<br>    <span class="hljs-built_in">top</span>()  返回栈顶元素<br>    <span class="hljs-built_in">pop</span>()  弹出栈顶元素<br><br>deque, 双端队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    <span class="hljs-built_in">push_front</span>()/<span class="hljs-built_in">pop_front</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br><br>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br><br>    set/<span class="hljs-function">multiset</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入一个数</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span>  查找一个数</span><br><span class="hljs-function">    </span><br><span class="hljs-function">            <span class="hljs-comment">//</span></span><br><span class="hljs-function">            map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator iter </span>= mapS.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(iter != mapS.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-comment">// 没找到就是返回的数据结构</span><br>            <br>        <span class="hljs-built_in">count</span>()  返回某一个数的个数<br>        <span class="hljs-built_in">erase</span>()<br>            (<span class="hljs-number">1</span>) 输入是一个数x，删除所有<span class="hljs-function">x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">    </span><br><span class="hljs-function">                <span class="hljs-comment">// set 集合容器</span></span><br><span class="hljs-function">                <span class="hljs-comment">// 初始化列表中的顺序会自动排序</span></span><br><span class="hljs-function">                set&lt;<span class="hljs-type">int</span>&gt; se</span>&#123; <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> &#125;;<br>                <span class="hljs-comment">// 删除元素 7</span><br>                se.<span class="hljs-built_in">erase</span>(<span class="hljs-number">7</span>);<br>    <br>        <span class="hljs-built_in">lower_bound</span>()/<span class="hljs-built_in">upper_bound</span>()<br>            <span class="hljs-built_in">lower_bound</span>(x)  返回大于等于x的最小的数的迭代器<br>            <span class="hljs-built_in">upper_bound</span>(x)  返回大于x的最小的数的迭代器<br>    map/<span class="hljs-function">multimap</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入的数是一个pair</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span>  输入的参数是pair或者迭代器</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(logn)</span></span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span><br><span class="hljs-function">    和上面类似，增删改查的时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">    不支持 <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span>， 迭代器的++，--</span><br><span class="hljs-function"></span><br><span class="hljs-function">bitset, 圧位</span><br><span class="hljs-function">    bitset&lt;10000&gt; s</span>;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    <span class="hljs-built_in">count</span>()  返回有多少个<span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">any</span>()  判断是否至少有一个<span class="hljs-number">1</span><br>    <span class="hljs-built_in">none</span>()  判断是否全为<span class="hljs-number">0</span><br><br>    <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>    <span class="hljs-built_in">reset</span>()  把所有位变成<span class="hljs-number">0</span><br>    <span class="hljs-built_in">flip</span>()  等价于~<br>    <span class="hljs-built_in">flip</span>(k) 把第k位取反<br><br></code></pre></td></tr></table></figure><h2 id="判断是否是回文串"><a href="#判断是否是回文串" class="headerlink" title="判断是否是回文串"></a>判断是否是回文串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(str[left] != str[right])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="洛谷刷题"><a href="#洛谷刷题" class="headerlink" title="洛谷刷题"></a>洛谷刷题</h1><p>产生长度为5的回文数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (d1 = <span class="hljs-number">1</span>; d1 &lt;= <span class="hljs-number">9</span>; d1+=<span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// 只有奇数才会是素数</span><br>     <span class="hljs-keyword">for</span> (d2 = <span class="hljs-number">0</span>; d2 &lt;= <span class="hljs-number">9</span>; d2++) &#123;<br>         <span class="hljs-keyword">for</span> (d3 = <span class="hljs-number">0</span>; d3 &lt;= <span class="hljs-number">9</span>; d3++) &#123;<br>           palindrome = <span class="hljs-number">10000</span>*d1 + <span class="hljs-number">1000</span>*d2 +<span class="hljs-number">100</span>*d3 + <span class="hljs-number">10</span>*d2 + d1;<span class="hljs-comment">//(处理回文数...)</span><br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>埃氏筛：给定整数n ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>二维vector的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><p>另外sort不能对二维数组进行排序</p><h1 id="力扣刷题"><a href="#力扣刷题" class="headerlink" title="力扣刷题"></a>力扣刷题</h1><h2 id="面试经典150题"><a href="#面试经典150题" class="headerlink" title="面试经典150题"></a>面试经典150题</h2><h3 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h3><h4 id="88、合并两个有序数组"><a href="#88、合并两个有序数组" class="headerlink" title="88、合并两个有序数组"></a>88、合并两个有序数组</h4><p>归并的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m+n)</span></span>;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[i] &lt;= nums2[j])<br>                res[k++] = nums1[i++];<br>            <span class="hljs-keyword">else</span><br>                res[k++] = nums2[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &lt; m)    res[k++] = nums1[i++];<br>        <span class="hljs-keyword">while</span>(j &lt; n)    res[k++] = nums2[j++];<br><br>        nums1 = res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>官方题解</strong></p><ol><li><p>直接合并后排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &lt; m + n; i++)<br>            nums1[i] = nums2[i - m];<br><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>双指针   就是归并的思想</p></li><li><p>逆向双指针      因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进 <em>nums</em>1 的最后面</p></li></ol><h4 id="27、移除元素"><a href="#27、移除元素" class="headerlink" title="27、移除元素"></a>27、移除元素</h4><p>由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p><ul><li>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li><li>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; right++)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(nums[right] != val)<br>            &#123;<br>                nums[left++] = nums[right]; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="26、删除有序数组中的重复项"><a href="#26、删除有序数组中的重复项" class="headerlink" title="26、删除有序数组中的重复项"></a>26、删除有序数组中的重复项</h4><p>双指针</p><p>定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> n; <br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">1</span>; right &lt; n; right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != nums[right - <span class="hljs-number">1</span>])  <br>            &#123;   nums[left] = nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="80、删除有序数组中的重复项Ⅱ"><a href="#80、删除有序数组中的重复项Ⅱ" class="headerlink" title="80、删除有序数组中的重复项Ⅱ"></a>80、删除有序数组中的重复项Ⅱ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">1</span>; right &lt; n; right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != nums[right - <span class="hljs-number">1</span>])<br>            &#123;<br>                cnt = <span class="hljs-number">1</span>;<br>                nums[left] = nums[right];<br>                left++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[right] == nums[right - <span class="hljs-number">1</span>] &amp;&amp; cnt == <span class="hljs-number">1</span>)<br>            &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                nums[left] = nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>自己思考的代码，运行部分用例出错，下面这个用例出错</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入<br>nums =<br><span class="hljs-string">[1,1,1,2,2,3]</span><br>输出<br><span class="hljs-string">[1,1,2,2,3,3]</span><br>预期结果<br><span class="hljs-string">[1,1,2,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>改进点</strong></p><ul><li>我们从数组的第三个元素（<code>left = 2</code>）开始遍历，因为前两个元素无论如何都应该保留。</li><li>每次比较 <code>nums[right]</code> 是否和 <code>nums[left - 2]</code> 相同。这样做是为了确保同一个元素最多保留两次。</li><li>如果当前 <code>nums[right]</code> 不等于 <code>nums[left - 2]</code>，我们将其保留到 <code>nums[left]</code> 位置，并更新 <code>left</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)  <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">2</span>; right &lt; n; right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != nums[left - <span class="hljs-number">2</span>])<br>            &#123;<br>                nums[left] = nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="169、多数元素"><a href="#169、多数元素" class="headerlink" title="169、多数元素"></a>169、多数元素</h4><p>很多种方法</p><ol><li>哈希表，分别统计每个出现的次数</li><li>排序，众数就是下标为 n &#x2F; 2的数</li><li>随机化，因为超过 ⌊2<em>n</em>⌋ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</li><li>分治，分别找到两边的众数，如果数 <code>a</code> 是数组 <code>nums</code> 的众数，如果我们将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数。</li><li>Boyer-Moore 投票算法，没了解</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/***********************   哈希        *************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            mp[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(mp[nums[i]] &gt;  nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>)<br>            &#123;<br>                res = nums[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/***********************   排序        *************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="189、轮转数组"><a href="#189、轮转数组" class="headerlink" title="189、轮转数组"></a>189、轮转数组</h4><p><strong>题目</strong>：给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p>我想出来的三种方法</p><ol><li>deque，deque支持双端操作</li><li>暴力for循环</li><li>数组分段，再合并数组</li></ol><p>下面是deque的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; mdq;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)    mdq.<span class="hljs-built_in">push_back</span>(nums[i]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = mdq.<span class="hljs-built_in">back</span>();<br>            mdq.<span class="hljs-built_in">pop_back</span>();<br>            mdq.<span class="hljs-built_in">push_front</span>(a);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            nums[i] = mdq.<span class="hljs-built_in">front</span>();<br>            mdq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解的方法</p><ol><li><p>使用额外数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    newArr[(i + k) % n] = nums[i];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>环状替换</p></li><li><p>数组反转：数组一共反转3次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">原数组：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br>第一次：<span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第二次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第三次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="121、买卖股票的最佳时机"><a href="#121、买卖股票的最佳时机" class="headerlink" title="121、买卖股票的最佳时机"></a>121、买卖股票的最佳时机</h4><p>记录一下最小值就行了</p><p>在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> min_price = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            min_price = <span class="hljs-built_in">min</span>(min_price, prices[i]);<br>            ans  = <span class="hljs-built_in">max</span>(prices[i] - min_price, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="122、买卖股票的最佳实际Ⅱ"><a href="#122、买卖股票的最佳实际Ⅱ" class="headerlink" title="122、买卖股票的最佳实际Ⅱ"></a>122、买卖股票的最佳实际Ⅱ</h4><h2 id="LeetCode热题100"><a href="#LeetCode热题100" class="headerlink" title="LeetCode热题100"></a>LeetCode热题100</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h4><p>两种方法</p><p>第一种遍历，for循环遍历两次</p><p>第二种哈希表，表格里的就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; myMap;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(myMap.<span class="hljs-built_in">find</span>(target - nums[i]) != myMap.<span class="hljs-built_in">end</span>())    <span class="hljs-comment">// 找到了</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                res.<span class="hljs-built_in">push_back</span>(myMap[target - nums[i]]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                myMap.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="49、字母异位词"><a href="#49、字母异位词" class="headerlink" title="49、字母异位词"></a>49、字母异位词</h4><p>ASCII 范围 0 - 127，最少 128 进制，经验上取 131 或 13331 冲突率低</p><p>两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p><p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p><p>以下的两种方法分别使用排序和计数作为哈希表的键。</p><p><strong>排序做哈希表的键</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; myMap;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str : strs)<br>        &#123;   <br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br><br>            myMap[key].<span class="hljs-built_in">push_back</span>(str);<br>            <br>        &#125;<br><br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">begin</span>(); it != myMap.<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="128、最长连续序列"><a href="#128、最长连续序列" class="headerlink" title="128、最长连续序列"></a>128、最长连续序列</h4><p><strong>题目</strong></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p><p><strong>思路</strong></p><p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n2 )（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)<br>        &#123;<br>            mySet.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : mySet)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(!mySet.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>))<span class="hljs-comment">// ***************  重点  *************</span><br>            &#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(mySet.<span class="hljs-built_in">count</span>(num + len))<br>                &#123;<br>                    len++;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, len);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="283、移动零"><a href="#283、移动零" class="headerlink" title="283、移动零"></a>283、移动零</h4><p>双指针的模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;  <span class="hljs-comment">// left 指 0 ， right 指 非 0</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right; right &lt; nums.<span class="hljs-built_in">size</span>(); right++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(nums[left] != <span class="hljs-number">0</span> &amp;&amp; left &lt; right)<br>            &#123;<br>                left++;<br>            &#125;<br><br>            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="11、盛水最多的容器"><a href="#11、盛水最多的容器" class="headerlink" title="11、盛水最多的容器"></a>11、盛水最多的容器</h4><p>证明过程很恼火，暂时忽略。</p><p>只需要知道 left &#x3D; 0， right &#x3D; size() - 1, 然后移动小的那个数字</p><p><strong>双指针代表了什么？</strong></p><p>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p><p><strong>为什么对应的数字较小的那个指针不可能再作为容器的边界了</strong>？</p><ul><li>求出当前双指针对应的容器的容量；</li><li>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-type">int</span> vol = <span class="hljs-built_in">min</span>(height[left], height[right]) * (right - left);<br>            res = <span class="hljs-built_in">max</span>(res, vol);<br>            <span class="hljs-keyword">if</span>(height[left] &lt;= height[right]) left++;<br>            <span class="hljs-keyword">else</span>    right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h4><p>如果我们直接使用三重循环枚举三元组，会得到 O(N^3) 个满足题目要求的三元组（其中 N 是数组的长度）时间复杂度至少为 O(N^3)。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。</p><p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p><ul><li>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</li><li>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</li></ul><p>要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p><p>答案表示为(a,b,c)。我们可以从小到大枚举 <em>b</em>，<strong>同时</strong>从大到小枚举 <em>c</em>，即<strong>第二重循环和第三重循环实际上是并列的关系</strong>。有了这样的发现，我们就可以保持第二重循环不变，而将<strong>第三重循环变成一个从数组最右端开始向左移动的指针</strong>，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; n; a++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span> &amp;&amp; nums[a] == nums[a - <span class="hljs-number">1</span>])     <span class="hljs-comment">// 枚举值要和上次不一样</span><br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> c = n - <span class="hljs-number">1</span>;      <span class="hljs-comment">// c 对应的指针初始化指向数组的最右端</span><br>            <span class="hljs-type">int</span> target = -nums[a];  <br>            <span class="hljs-comment">// 枚举b</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>; b &lt; n; b++)  <br>            &#123;<br>                <span class="hljs-keyword">if</span>(b &gt; a + <span class="hljs-number">1</span> &amp;&amp; nums[b] == nums[b - <span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 需要保证 b 的指针 在 c 的指针的左侧</span><br>                <span class="hljs-keyword">while</span>(b &lt; c &amp;&amp; nums[b] + nums[c] &gt; target)<br>                &#123;<br>                    c--;<br>                &#125;<br>                <span class="hljs-comment">// 如果指针重合，随着b后续的增加，就不会有满足条件a+b+c=0的，可以退出循环</span><br>                <span class="hljs-keyword">if</span>(b == c)  <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">if</span>(nums[b] + nums[c] == target)<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(&#123;nums[a], nums[b], nums[c]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>三种循环里面的后两层可以用双指针来替换，c指向某位，b指向a的下一位</p><h4 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h4><p>三种方法</p><ol><li><p>动态规划</p></li><li><p>单调栈</p></li><li><p>双指针</p><p>采用双指针的方法，建议去看题解里的示意图</p></li></ol><p>注意到下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。</p><p>维护两个指针 left 和 right，以及两个变量 leftMax 和 rightMax，初始时 left&#x3D;0,right&#x3D;n−1,leftMax&#x3D;0,rightMax&#x3D;0。指针 left 只会向右移动，指针 right 只会向左移动，在移动指针的过程中维护两个变量 leftMax 和 rightMax 的值。</p><p>当两个指针没有相遇时，进行如下操作：</p><ul><li>使用 height[left] 和 height[right] 的值更新 leftMax 和 rightMax 的值；</li><li>如果 height[left]&lt;height[right]，则必有 leftMax&lt;rightMax，下标 left 处能接的雨水量等于 leftMax−height[left]，将下标 left 处能接的雨水量加到能接的雨水总量，然后将 left 加 1（即向右移动一位）；</li><li>如果 height[left]≥height[right]，则必有 leftMax≥rightMax，下标 right 处能接的雨水量等于 rightMax−height[right]，将下标 right 处能接的雨水量加到能接的雨水总量，然后将 right 减 1（即向左移动一位）。</li></ul><p>当两个指针相遇时，即可得到能接的雨水总量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftmax = <span class="hljs-number">0</span>, rightmax = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            leftmax = <span class="hljs-built_in">max</span>(height[left], leftmax);<br>            rightmax = <span class="hljs-built_in">max</span>(height[right], rightmax);<br><br>            <span class="hljs-keyword">if</span>(leftmax &lt;= rightmax)<br>            &#123;<br>                result = result + (leftmax - height[left]);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result = result + (rightmax - height[right]);<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="3、无重复字符的最长子串"><a href="#3、无重复字符的最长子串" class="headerlink" title="3、无重复字符的最长子串"></a>3、无重复字符的最长子串</h4><p>题目：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>滑动窗口</strong></p><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk；</p><p>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</p><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p><p><strong>判断重复字符</strong></p><p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; myMap;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(r; r &lt; s.<span class="hljs-built_in">size</span>(); r++)<br>        &#123;   <br>            myMap[s[r]]++;<br><br>            <span class="hljs-keyword">while</span>(myMap[s[r]] == <span class="hljs-number">2</span>)<br>            &#123;<br>                myMap[s[l]]--;<br>                l++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用unordered_set修改代码，之前不用 set 是因为我忘记怎么从set里面删除了，</p><p>现在发现了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mySet.<span class="hljs-built_in">erase</span>(删除元素)<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 哈希集合，记录每个字符是否出现过</span><br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; occ;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br>        <span class="hljs-type">int</span> rk = <span class="hljs-number">-1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 左指针向右移动一格，移除一个字符</span><br>                occ.<span class="hljs-built_in">erase</span>(s[i - <span class="hljs-number">1</span>]);<span class="hljs-comment">//*************移除字符***********</span><br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; !occ.<span class="hljs-built_in">count</span>(s[rk + <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-comment">// 不断地移动右指针</span><br>                occ.<span class="hljs-built_in">insert</span>(s[rk + <span class="hljs-number">1</span>]);<br>                ++rk;<br>            &#125;<br>            <span class="hljs-comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br>            ans = <span class="hljs-built_in">max</span>(ans, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/227999/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br></code></pre></td></tr></table></figure><h4 id="438、找到字符串中所有字母异位词"><a href="#438、找到字符串中所有字母异位词" class="headerlink" title="438、找到字符串中所有字母异位词"></a>438、找到字符串中所有字母异位词</h4><p>这个不能用 set 来做，因为如下：</p><p>当前代码中，使用了 <code>set</code> 数据结构来比较字符集。但字母异位词不仅要求字符相同，还要求每个字符出现的次数相同，而 <code>set</code> 只存储唯一字符，无法区分字符频率。例如，<code>&quot;abb&quot;</code> 和 <code>&quot;aab&quot;</code> 在集合里看起来是一样的，但它们并不是异位词。</p><p>用数组存储p和滑动窗口内的字符数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = p.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(n &lt; m)   <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ();<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sCnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pCnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            pCnt[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sCnt[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(sCnt == pCnt)    res.<span class="hljs-built_in">push_back</span>(i);<br>            <br>            sCnt[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            sCnt[s[i + m] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sCnt == pCnt)    res.<span class="hljs-built_in">push_back</span>(n - m);<span class="hljs-comment">// 特例特判，最后一个相同</span><br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><h4 id="560、和为K的子数组"><a href="#560、和为K的子数组" class="headerlink" title="560、和为K的子数组"></a>560、和为K的子数组</h4><p>是要找连续非空的序列，所以不能用回溯算法</p><p>有两种方法，一种是暴力枚举，一种是前缀和加哈希表，这里用的是前缀和+哈希表法</p><p>建议去看图画就懂了</p><p>我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。</p><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/">https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pre += nums[i];<br><br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(pre - k) != mp.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                cnt += mp[pre - k];<br>            &#125;<br>            mp[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="239、滑动窗口的最大值"><a href="#239、滑动窗口的最大值" class="headerlink" title="239、滑动窗口的最大值"></a>239、滑动窗口的最大值</h4><p><strong>题目</strong>：给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>思路</strong></p><ol><li>优先队列</li><li>单调队列</li><li>分块+预处理</li></ol><p><strong>优先队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; mq;<span class="hljs-comment">/*******    最大堆  *******/</span><br>   <span class="hljs-comment">// 最小堆priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap</span><br><span class="hljs-comment">//  priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            mq.<span class="hljs-built_in">push</span>(&#123;nums[i], i&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;mq.<span class="hljs-built_in">top</span>().first&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)<br>        &#123;<br>            mq.<span class="hljs-built_in">push</span>(&#123;nums[i], i&#125;);<br>            <span class="hljs-keyword">while</span>(mq.<span class="hljs-built_in">top</span>().second &lt;= i - k)<br>            &#123;<br>                mq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(mq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优先队列会自动构建堆顶是最大元素，然后存入下标来判断最大值是否在滑动窗口内。</p><p><strong>单调队列</strong></p><p>队列里仅保存下标，</p><p>队尾比不过同龄人的删掉，队头超出时代区间的删掉，历史就是这么不断更迭的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        deque&lt;<span class="hljs-type">int</span>&gt; mq;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!mq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[mq.<span class="hljs-built_in">back</span>()])<br>            &#123;<br>                mq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            mq.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;nums[mq.<span class="hljs-built_in">front</span>()]&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!mq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[mq.<span class="hljs-built_in">back</span>()])<br>            &#123;<br>                mq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            mq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">while</span>(mq.<span class="hljs-built_in">front</span>() &lt;= i - k)<br>            &#123;<br>                mq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(nums[mq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="76、最小覆盖字串"><a href="#76、最小覆盖字串" class="headerlink" title="76、最小覆盖字串"></a>76、最小覆盖字串</h4><p><strong>题目</strong>：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>思路</strong></p><p>滑动窗口</p><p><strong>我们在 *s* 上滑动窗口，通过移动 *r* 指针不断扩张窗口。当窗口包含 *t* 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</strong></p><p>如何判断当前的窗口包含所有 t 所需的字符呢？我们可以用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; tm, sm;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : tm)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sm[p.first] &lt; p.second)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slen = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> tlen = t.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(slen &lt; tlen)   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : t) tm[c]++;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> len = INT_MAX, ansL = <span class="hljs-number">-1</span>, ansR = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(r &lt; slen)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tm.<span class="hljs-built_in">find</span>(s[++r]) != tm.<span class="hljs-built_in">end</span>()) <span class="hljs-comment">// r指针右移，只判断t中有的字符</span><br>            &#123;<br>                sm[s[r]]++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>() &amp;&amp; l &lt;= r)    <span class="hljs-comment">// 判断是否包含</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span> &lt; len)<br>                &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    ansL = l; <br>                &#125;<br>                <span class="hljs-keyword">if</span>(tm.<span class="hljs-built_in">find</span>(s[l]) != tm.<span class="hljs-built_in">end</span>())  <span class="hljs-comment">// 缩短序列</span><br>                &#123;<br>                    --sm[s[l]];<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ansL == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">string</span>() : s.<span class="hljs-built_in">substr</span>(ansL, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><h4 id="53、最大子数组和"><a href="#53、最大子数组和" class="headerlink" title="53、最大子数组和"></a>53、最大子数组和</h4><p>你在计算最大子数组和时，使用了前缀和，并试图通过找到最小的前缀和位置来计算最大和。但这个逻辑并不能适用于所有情况，特别是当输入数组只有一个负数时。你现在的代码会计算最小前缀和并在此基础上继续计算最大和，这会导致输出为0（因为空子数组的和是0），而实际上应该直接返回单个元素本身。</p><p><strong>问题:</strong></p><p>当前实现的问题是：在处理像 <code>[-1]</code> 这样的单元素负数数组时，程序默认会找到前缀和最小的情况并返回 <code>0</code>，因为代码试图计算的是从 <code>min_pos</code> 到 <code>n</code> 之间的最大和，而没有考虑到最优解可能是负数的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入<br>nums = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>]<br>输出<br><span class="hljs-number">0</span><br>预期结果<br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>正确思路</strong></p><ol><li>动态规划</li><li>分治</li></ol><p>动态规划的思路：转移过程为：<br>$$<br>f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>, max_value = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + nums[i], nums[i]);<br>            max_value = <span class="hljs-built_in">max</span>(max_value, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_value;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="56、合并区间"><a href="#56、合并区间" class="headerlink" title="56、合并区间"></a>56、合并区间</h4><p>做过相关题的，分为三种情况，只在 ed &lt; a[0] 的时候把线段加入答案</p><p>还有注意的一点就是这个lamba表达式，虽然默认的是按照第一个排序，但是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>           <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>       &#125;);<br></code></pre></td></tr></table></figure><p><strong>完整代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-comment">// 按照每个区间的第一个元素升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-type">int</span> st = <span class="hljs-number">-1</span>, ed = <span class="hljs-number">-1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : intervals) &#123;<br>            <span class="hljs-comment">// 如果当前区间不重叠，保存之前的区间并开始新的区间</span><br>            <span class="hljs-keyword">if</span> (ed &lt; a[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>                st = a[<span class="hljs-number">0</span>];<br>                ed = a[<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果区间重叠，更新右边界</span><br>                ed = <span class="hljs-built_in">max</span>(ed, a[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后一个区间需要单独加入结果</span><br>        <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="189、轮转数组-1"><a href="#189、轮转数组-1" class="headerlink" title="189、轮转数组"></a>189、轮转数组</h4><p><strong>题目</strong>：给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p>我想出来的三种方法</p><ol><li>deque，deque支持双端操作</li><li>暴力for循环</li><li>数组分段，再合并数组</li></ol><p>下面是deque的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; mdq;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)    mdq.<span class="hljs-built_in">push_back</span>(nums[i]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = mdq.<span class="hljs-built_in">back</span>();<br>            mdq.<span class="hljs-built_in">pop_back</span>();<br>            mdq.<span class="hljs-built_in">push_front</span>(a);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            nums[i] = mdq.<span class="hljs-built_in">front</span>();<br>            mdq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解的方法</p><ol><li><p>使用额外数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    newArr[(i + k) % n] = nums[i];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>环状替换</p></li><li><p>数组反转：数组一共反转3次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">原数组：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br>第一次：<span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第二次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第三次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="238、除自身以外数组的乘积"><a href="#238、除自身以外数组的乘积" class="headerlink" title="238、除自身以外数组的乘积"></a>238、除自身以外数组的乘积</h4><p>分三种情况讨论</p><ol><li>没有零：就是正常处理</li><li>有一个零：除零的哪一位有数，其他全是零</li><li>一个以上的零：全都是零</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> mux = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt_zero = <span class="hljs-number">0</span>, cnt_pos = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)<br>            &#123;<br>                mux *= nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cnt_zero++;<br>                cnt_pos = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span>(cnt_zero &gt; <span class="hljs-number">1</span>)&#123;&#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt_zero == <span class="hljs-number">1</span>)<br>            res[cnt_pos] = mux;<br>        <span class="hljs-keyword">else</span>       <br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                res[i] = mux / nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>额，才看到，不允许使用除法运算</p><p><strong>官方思路</strong></p><ol><li>左右乘积列表</li><li>空间复杂度为O(1)的方法</li></ol><p>左右乘积列表：初始化两个空数组 <code>L</code> 和 <code>R</code>。对于给定索引 <code>i</code>，<code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// L[i] 代表左侧所有数字的乘积</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">R</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// R[i] 代表右侧所有数字的乘积</span><br><br>        L[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) L[i] = L[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br><br>        R[n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) R[i] = R[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            res[i] = L[i] * R[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="41、缺失的第一个正数"><a href="#41、缺失的第一个正数" class="headerlink" title="41、缺失的第一个正数"></a>41、缺失的第一个正数</h4><p>有点难呢</p><p>算法的流程如下：</p><ul><li>我们将数组中所有小于等于 0 的数修改为 N+1；</li><li>我们遍历数组中的每一个数 x，它可能已经被打了标记，因此原本对应的数为 ∣x∣，其中 ∣∣ 为绝对值符号。如果 ∣x∣∈[1,N]，那么我们给数组中的第 ∣x∣−1 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；</li><li>在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1，否则答案是第一个正数的位置加 1。</li></ul><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.png" class=""><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/">https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= <span class="hljs-number">0</span>)    nums[i] = n + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;   <br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(num &lt;= n)<br>            &#123;<br>                nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="73、矩阵置零"><a href="#73、矩阵置零" class="headerlink" title="73、矩阵置零"></a>73、矩阵置零</h4><p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p><ul><li>一个直观的解决方案是使用  <code>O(*m**n*)</code> 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个仅使用常量空间的解决方案吗？</li></ul><p><strong>思路</strong></p><p> 使用第一行和第一列作为标记</p><p>通常我们会使用额外的两个数组来记录哪些行和列需要置零。但我们可以复用矩阵的第一行和第一列，将它们作为标记来记录哪些行和列需要置零。这就减少了空间的额外消耗。</p><p>为了达到这个目的，我们需要先处理两个特殊情况：</p><ul><li>第一行是否需要被置零？</li><li>第一列是否需要被置零？</li></ul><p>这两个问题单独处理，因为我们在用第一行和第一列作为标记时，不希望它们的内容被破坏。接下来，通过两步来完成整个算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> first_col_zero = <span class="hljs-literal">false</span>, first_row_zero = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)<br>            &#123;<br>                first_row_zero = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 记录第一行是否需要置零</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>            &#123;<br>                first_col_zero = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 记录第一列是否需要置零</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<span class="hljs-comment">// 使用第一行和第一列作为标记</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<span class="hljs-comment">// 从第二行第二列开始置零</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(first_row_zero)<span class="hljs-comment">// 处理第一行</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            &#123;<br>                matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(first_col_zero)<span class="hljs-comment">// 处理第一列</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="54、螺旋矩阵"><a href="#54、螺旋矩阵" class="headerlink" title="54、螺旋矩阵"></a>54、螺旋矩阵</h4><p><strong>第一种方法：模拟</strong></p><p>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p><p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。</p><p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p><p><strong>第二种方法：按层模拟</strong></p><p>这个问题的关键在于按照顺时针的螺旋顺序遍历一个矩阵，并返回矩阵中的所有元素。我们可以使用边界变量来控制遍历的范围：上边界 <code>top</code>，下边界 <code>bottom</code>，左边界 <code>left</code>，右边界 <code>right</code>，然后依次按照顺时针的顺序遍历矩阵。每次遍历一行或一列之后，相应的边界会向内收缩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(top &lt;= bottom &amp;&amp; left &lt;= right)<br>        &#123;<br>            <span class="hljs-comment">// 从左到右遍历上边</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>            &#125;<br>            top++;<span class="hljs-comment">// 上边界下移</span><br><span class="hljs-comment">// 从上到下遍历右边</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = top; i &lt;= bottom; i++)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            right--; <span class="hljs-comment">// 右边界左移</span><br><br>            <span class="hljs-keyword">if</span>(top &lt;= bottom)<br>            &#123;<span class="hljs-comment">// 从右到左遍历下边</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = right; i &gt;= left; i--)<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[bottom][i]);<br>                &#125;<br>                bottom--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt;= right)<br>            &#123;<span class="hljs-comment">// 从下到上遍历左边</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bottom; i &gt;= top; i--)<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>**<code>if (top &lt;= bottom)</code>**：</p><ul><li>这个判断是在完成从左到右、从上到下的遍历后，为了确保在遍历完顶部和右侧之后，矩阵的底部仍然是有效的。如果<code>top</code>已经大于<code>bottom</code>，说明顶部已经穿越到底部，矩阵的元素已经全部遍历完毕，底部已经不需要再遍历了，所以我们避免再继续处理底部的元素。</li></ul><p>**<code>if (left &lt;= right)</code>**：</p><ul><li>这个判断是在从右到左、从下到上的遍历之后进行的，确保在遍历完右侧和底部之后，矩阵的左边仍然是有效的。如果<code>left</code>已经大于<code>right</code>，说明左侧已经穿越到右侧，同理，矩阵的元素已经全部遍历完毕，左侧不再需要遍历。</li></ul><h4 id="48、旋转图像"><a href="#48、旋转图像" class="headerlink" title="48、旋转图像"></a>48、旋转图像</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>思路</strong></p><p>为了实现这一目标，我们可以分两个步骤来完成：</p><ol><li><p><strong>矩阵转置</strong>：将矩阵的行列进行交换。</p></li><li><p><strong>每一行翻转</strong>：将转置后的矩阵的每一行进行左右翻转。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br><br>        <span class="hljs-comment">// 矩阵转置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 同一行前后翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// reverse(matrix[i].begin(), matrix[i].end()); 用这个更简单</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt;= r)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][l], matrix[i][r]);<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="240、搜索二维矩阵Ⅱ"><a href="#240、搜索二维矩阵Ⅱ" class="headerlink" title="240、搜索二维矩阵Ⅱ"></a>240、搜索二维矩阵Ⅱ</h4><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/240_%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1.png" class=""><p>为了更高效地解决这个问题，可以利用矩阵的特性——每行从左到右递增，每列从上到下递增。我们可以从矩阵的右上角开始搜索，利用行列的单调性。如果当前值大于目标值，就向左移动；如果当前值小于目标值，就向下移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> col = n - <span class="hljs-number">1</span>, row = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[row][col] ==  target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target)<br>            &#123;<br>                row++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                col--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="160、相交链表"><a href="#160、相交链表" class="headerlink" title="160、相交链表"></a>160、相交链表</h4><p><strong>思路：</strong></p><ol><li>获取两个链表的长度：首先你可以遍历两个链表，获取它们的长度 <code>lenA</code> 和 <code>lenB</code>。根据这两个长度的差值，将较长的链表向前移动，使得两个链表的剩余长度相等。</li><li>对齐两个链表：如果两个链表的长度不相等，那么可以将较长的链表先向前移动 <code>lenA - lenB</code> 个节点（如果 <code>lenA</code> 比 <code>lenB</code> 长），或者将 <code>lenB - lenA</code> 个节点移除（如果 <code>lenB</code> 比 <code>lenA</code> 长）。</li><li>遍历两个链表：接下来，你可以同时遍历两个链表，当某个节点在两个链表中同时出现时，即为它们的交点。</li><li>特殊情况：如果两个链表没有相交，最终遍历完之后没有发现相同的节点，那么返回 <code>null</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        ListNode *curA = headA;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            curA = curA-&gt;next;<br>        &#125;<br><br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode *curB = headB;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            curB = curB-&gt;next;<br>        &#125;<br><br>        <br>        curA = headA;<br>        curB = headB;<br>        <br>        <span class="hljs-keyword">if</span>(m &gt; n)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - n; i++) curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++) curB = curB-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(curA != curB)<br>        &#123;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;  <br><br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="206、反转链表"><a href="#206、反转链表" class="headerlink" title="206、反转链表"></a>206、反转链表</h4><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode *cur = head;<br><br>        ListNode *ne;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = ne;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="234、回文链表"><a href="#234、回文链表" class="headerlink" title="234、回文链表"></a>234、回文链表</h4><p><strong>思路</strong></p><p>先反转链表，再依次判断是否相等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverses</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode *cur = head;<br><br>        ListNode *ne;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = ne;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        ListNode *headB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(head-&gt;val);<br>        ListNode *curB = headB;<br><br>        ListNode *cur = head-&gt;next;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            curB-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br><br>        headB = <span class="hljs-built_in">reverses</span>(headB);<br>        cur = head;<br>        curB = headB;<br><br>        <span class="hljs-keyword">while</span>(cur &amp;&amp; curB)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur-&gt;val != curB-&gt;val)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="141、环形链表"><a href="#141、环形链表" class="headerlink" title="141、环形链表"></a>141、环形链表</h4><p>两种方法;</p><ol><li><p>哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;ListNode*&gt; seen; <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></li><li><p>快慢指针</p><p>我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ListNode *fastcur = head-&gt;next;<br>        ListNode *cur = head;<br><br>        <span class="hljs-keyword">while</span>(cur != fastcur)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fastcur == <span class="hljs-literal">nullptr</span> || fastcur-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fastcur = fastcur-&gt;next-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="142、环形链表Ⅱ"><a href="#142、环形链表Ⅱ" class="headerlink" title="142、环形链表Ⅱ"></a>142、环形链表Ⅱ</h4><p>这个和上一题的区别是这个需要返回     开始入环的第一个节点</p><p>用到的是哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode *&gt; visited;<br><br>        ListNode *cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(cur))  <span class="hljs-keyword">return</span> cur;<br><br>            visited.<span class="hljs-built_in">insert</span>(cur);<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="21、合并两个有序链表"><a href="#21、合并两个有序链表" class="headerlink" title="21、合并两个有序链表"></a>21、合并两个有序链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *cur = dummy;<br><br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)<br>            &#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">nullptr</span>)    cur-&gt;next = list1;<br>        <span class="hljs-keyword">if</span>(list2 != <span class="hljs-literal">nullptr</span>)    cur-&gt;next = list2;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h4><p><strong>题目</strong>：</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>        ListNode *cur1 = l1, *cur2 = l2;<br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            cur1 = cur1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(cur2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            cur2 = cur2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(m &lt; n)   <span class="hljs-keyword">return</span> <span class="hljs-built_in">addTwoNumbers</span>(l2, l1);<br><br>        cur1 = l1, cur2 = l2;<br>        <span class="hljs-type">int</span> jin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span> &amp;&amp; cur2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> num = cur1-&gt;val + cur2-&gt;val + jin;<br>            cur1-&gt;val = num % <span class="hljs-number">10</span>;<br>            jin = num / <span class="hljs-number">10</span>;<br><br>            cur1 = cur1-&gt;next;<br>            cur2 = cur2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> num = cur1-&gt;val + jin;<br>            cur1-&gt;val = num % <span class="hljs-number">10</span>;<br>            jin = num / <span class="hljs-number">10</span>;<br><br>            cur1 = cur1-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(jin != <span class="hljs-number">0</span>)<br>        &#123;   <br>            cur1 = l1;<br>            <span class="hljs-keyword">while</span>(cur1-&gt;next != <span class="hljs-literal">nullptr</span>) cur1 = cur1-&gt;next;<br>            cur1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(jin);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简化代码的简化思路：</p><ol><li>哑节点 (dummy node)：使用哑节点 <code>dummyHead</code> 可以避免处理头节点的特殊情况，让代码更简洁和通用。最终返回时直接返回 <code>dummyHead-&gt;next</code>。</li><li>处理链表不同长度：在遍历链表时，使用 <code>p</code> 和 <code>q</code> 来分别指向 <code>l1</code> 和 <code>l2</code>，如果其中一个链表已经遍历完了，我们用 0 作为该链表的值，继续进行加法运算。</li><li>进位处理：每次相加时，将 <code>carry</code> 记录下来，之后的相加都包含这个 <code>carry</code>。如果最后还有进位，则在链表尾部追加一个新的节点。</li><li>遍历到链表末尾：使用 <code>p</code> 和 <code>q</code> 分别遍历 <code>l1</code> 和 <code>l2</code>，当其中一个链表提前结束时，继续处理另一个链表的剩余部分。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <br>        ListNode *head = <span class="hljs-literal">nullptr</span>, *tail = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>( l1 != <span class="hljs-literal">nullptr</span> || l2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> n1 = (l1 == <span class="hljs-literal">nullptr</span>) ? <span class="hljs-number">0</span> : l1-&gt;val;<br>            <span class="hljs-type">int</span> n2 = (l2 == <span class="hljs-literal">nullptr</span>) ? <span class="hljs-number">0</span> : l2-&gt;val;<br><br>            <span class="hljs-type">int</span> sum = n1 + n2 + carry;<br><br>            <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                head = tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>                tail = tail-&gt;next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">nullptr</span>)   l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">nullptr</span>)   l2 = l2-&gt;next;<br><br>            <span class="hljs-keyword">if</span>(carry &gt; <span class="hljs-number">0</span>)   tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="19、删除链表的倒数第N个节点"><a href="#19、删除链表的倒数第N个节点" class="headerlink" title="19、删除链表的倒数第N个节点"></a>19、删除链表的倒数第N个节点</h4><p>题目：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p><p>第一种方法：遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        ListNode *cur = head;<br><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        cur = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - n &amp;&amp; cur != <span class="hljs-literal">nullptr</span>; i++)  cur = cur-&gt;next;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)  cur-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第二种方法：快慢指针</p><p>可以使用 <strong>快慢指针法</strong>，只需遍历一次链表即可完成删除倒数第 <code>n</code> 个节点的操作。基本思路是设置两个指针 <code>fast</code> 和 <code>slow</code>，让 <code>fast</code> 指针先向前移动 <code>n</code> 步，然后再同时移动 <code>fast</code> 和 <code>slow</code>，直到 <code>fast</code> 指向链表的末尾。此时，<code>slow</code> 刚好指向要删除节点的前一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        ListNode *fast = dummy, *slow = dummy;<br>        <span class="hljs-keyword">while</span>(n--)<br>        &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(fast-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="十进制转任意进制"><a href="#十进制转任意进制" class="headerlink" title="十进制转任意进制"></a>十进制转任意进制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 【分析】</span><br><span class="hljs-comment">//  n = …… + a * (base)^5 + b * (base)^4 + c * (base)^3 + d * (base)^2 + e * (base)^1 + f * (base)^0</span><br><span class="hljs-comment">//  若base为正数，则n也必定为非负数</span><br><span class="hljs-comment">//  若base为负数，则n可为所有整数</span><br><br><span class="hljs-comment">// 【任意base的通用写法】</span><br><span class="hljs-function">string <span class="hljs-title">baseAny</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> base)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>    string ans;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 获取当前最低位</span><br>        <span class="hljs-type">int</span> r = n % base;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)     <span class="hljs-comment">// 说明 base 必为负数</span><br>            r -= base; <span class="hljs-comment">// 保证找到的余数在有效范围 [0, base - 1] 内</span><br>        n -= r;        <span class="hljs-comment">// 将最后一位抹零，保证后续是整除，从而保证不同语言通用</span><br>        <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">10</span>)<br>            ans += <span class="hljs-string">&#x27;A&#x27;</span> + r - <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">else</span><br>            ans += <span class="hljs-string">&#x27;0&#x27;</span> + r;<br><br>        <span class="hljs-comment">// 将n的进制表达式向右移一位</span><br>        n /= base;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>作者：Yvette<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/convert-to-base-2/solutions/2211859/jin-zhi-biao-da-shi-de-ben-zhi-bu-tong-y-1x4a/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="3-移除元素-双指针方法"><a href="#3-移除元素-双指针方法" class="headerlink" title="3.移除元素      双指针方法"></a>3.移除元素      双指针方法</h3><h4 id="884-比较含退格的字符串"><a href="#884-比较含退格的字符串" class="headerlink" title="884.比较含退格的字符串"></a>884.比较含退格的字符串</h4><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</p><p>若该字符为普通字符：</p><p>若 skip 为 0，则说明当前字符不需要删去；</p><p>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。</p><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = s,<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">// 处理#</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">// 如果遇到 #, 计数器+1，并且跳过这个#</span><br>                &#123;<br>                    skipS++, i--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipS &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">// 如果计数器 &gt; 0，则跳过下一个字符，计数器-1 </span><br>                &#123;<br>                    skipS--, i--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(t[j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    skipT++, j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipT &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    skipT--, j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(s[i] != t[j])    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//经过前面的处理，是没有#和删除的字符</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 如果两个不一样长，就k</span><br>            i--, j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5-长度最小的子数组"><a href="#5-长度最小的子数组" class="headerlink" title="5. 长度最小的子数组"></a>5. 长度最小的子数组</h3><h4 id="904水果成篮-滑动区间unordered-map使用"><a href="#904水果成篮-滑动区间unordered-map使用" class="headerlink" title="904水果成篮         滑动区间unordered_map使用"></a>904水果成篮         滑动区间unordered_map使用</h4><p><strong>问题：</strong>怎么判断滑动区间内元素种类？采用哈希表unordered_map来统计，或者构建数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个unordered_map，键是string类型，值是int类型</span><br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span>;<br>    myMap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">3</span>;<br>    myMap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 查找元素</span><br>    std::string fruit = <span class="hljs-string">&quot;banana&quot;</span>;<br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">find</span>(fruit) != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The number of &quot;</span> &lt;&lt; fruit &lt;&lt; <span class="hljs-string">&quot; is: &quot;</span> &lt;&lt; myMap[fruit] &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No information available for &quot;</span> &lt;&lt; fruit &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;orange&quot;</span>);<br><br>    <span class="hljs-comment">// 遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取unordered_map的长度</span><br>    cout &lt;&lt; myMap.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-螺旋数组Ⅱ"><a href="#6-螺旋数组Ⅱ" class="headerlink" title="6. 螺旋数组Ⅱ"></a>6. 螺旋数组Ⅱ</h3><h4 id="二维vector的定义"><a href="#二维vector的定义" class="headerlink" title="二维vector的定义"></a>二维vector的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>|| matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m * n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt; right; j++)   res[count++] = matrix[top][j];<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = top; i &lt;= bottom; i++)   res[count++] = matrix[i][right];<br><br>            <span class="hljs-keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>; j &gt; left; j--)   res[count++] = matrix[bottom][j];<br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bottom; i &gt; top; i--)   res[count++] = matrix[i][left];<br>            &#125;<br><br>            left++, right--, top++, bottom--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p><p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p><h3 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>dummyHead-&gt;next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span><br></code></pre></td></tr></table></figure><h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><p><strong>双指针法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>递归法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre,ListNode* cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>        <span class="hljs-comment">// pre = cur;</span><br>        <span class="hljs-comment">// cur = temp;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur,temp);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>        <span class="hljs-comment">// ListNode* cur = head;</span><br>        <span class="hljs-comment">// ListNode* pre = NULL;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>重点是推导的过程，详见代码随想录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" class=""><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">数组<br>set、unordered_set<br>map、unordered_<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1、KMP算法"><a href="#1、KMP算法" class="headerlink" title="1、KMP算法"></a>1、KMP算法</h3><h4 id="得到next-前缀表"><a href="#得到next-前缀表" class="headerlink" title="得到next 前缀表"></a>得到next 前缀表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/******************************** KMP伪代码 ****************************/</span><br><span class="hljs-comment">// 求 next 前缀表 数组步骤</span><br><span class="hljs-number">1</span>、初始化 <br>    <span class="hljs-comment">// 指针  i : 后缀末尾位置  j : 指向前缀末尾位置,   还代表了 当前 最长相等前后缀的长度</span><br>    j = <span class="hljs-number">0</span>, next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;&#125;<br><span class="hljs-number">2</span>、处理前后缀不同的情况<br>    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) <span class="hljs-comment">// 不等的时候，j 应该回退， 看前一位 前缀表里的值 可能会存在一直回退的情况，所以要用while </span><br>    j = ne[j - <span class="hljs-number">1</span>];<br><span class="hljs-number">3</span>、处理前后缀相同的情况<br>    <span class="hljs-keyword">if</span>(s[i] == s[j])  j++;<span class="hljs-comment">// 最长相等前后缀的长度 + 1</span><br><span class="hljs-number">4</span>、更新next数组<br>    ne[i] = j;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNest</span><span class="hljs-params">(<span class="hljs-type">int</span> *ne, <span class="hljs-type">const</span> string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = ne[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(s[i] == s[j])j++;<br>        ne[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用next数组做匹配"><a href="#使用next数组做匹配" class="headerlink" title="使用next数组做匹配"></a>使用next数组做匹配</h4><p>匹配过程和得到前缀和表的过程是相似的</p><p>在文本串s里 找是否出现过模式串t。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(needle.size())</span></span>;<br>        <span class="hljs-built_in">getNext</span>(&amp;next[<span class="hljs-number">0</span>], needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() ) &#123;<br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1、二叉树理论基础"><a href="#1、二叉树理论基础" class="headerlink" title="1、二叉树理论基础"></a>1、二叉树理论基础</h3><h4 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h4><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p><p><strong>满二叉树：</strong>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p><strong>完全二叉树：</strong>在完全二叉树中，除了最底层节点可能没填满外，其余<strong>每层节点数都达到最大值</strong>，并且最下面一层的节点都集中在<strong>该层最左边</strong>的若干位置。</p><p><strong>二叉搜索树：</strong>二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。（左  &lt;  根  &lt;  右）</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><strong>平衡二叉树：</strong>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的<strong>高度差</strong>的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>补充： <strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p><h4 id="二叉树存储方式"><a href="#二叉树存储方式" class="headerlink" title="二叉树存储方式"></a>二叉树存储方式</h4><p>1、链式存储：用指针</p><p>2、顺序存储：用数组，<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储的节点定义方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-comment">// 构造函数，初始化节点的值和子节点指针</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是构造函数，这么说吧C语言中的结构体是C++中类的祖先，所以C++结构体也可以有构造函数。</p><p>构造函数也可以不写，但是new一个新的节点的时候就比较麻烦。</p><p>例如有构造函数，定义初始值为9的节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TreeNode* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><p>没有构造函数的话就要这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">TreeNode* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>a-&gt;val = <span class="hljs-number">9</span>;<br>a-&gt;left = <span class="hljs-literal">NULL</span>;<br>a-&gt;right = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="2、二叉树的递归遍历"><a href="#2、二叉树的递归遍历" class="headerlink" title="2、二叉树的递归遍历"></a>2、二叉树的递归遍历</h3><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>前序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：由于 <code>vec</code> 是引用传递，因此对 <code>vec</code> 的任何修改都会保留，并且在递归调用中不断累积结果。</strong></p><h3 id="3、二叉树的迭代遍历"><a href="#3、二叉树的迭代遍历" class="headerlink" title="3、二叉树的迭代遍历"></a>3、二叉树的迭代遍历</h3><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p><strong>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br><br>        stack&lt;TreeNode *&gt; myStk;<br>        myStk.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = myStk.<span class="hljs-built_in">top</span>();<br>            myStk.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">NULL</span>)     myStk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)      myStk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><strong>再来看后序遍历，先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">=<br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">postorderTraversal</span>(TreeNode* root) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br><br>        stack&lt;TreeNode *&gt; myStk;<br>        myStk.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = myStk.<span class="hljs-built_in">top</span>();<br>            myStk.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)      myStk.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">////////</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">NULL</span>)     myStk.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">////////</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//////////</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; myStk;<br>        TreeNode *cur = root;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                myStk.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur = myStk.<span class="hljs-built_in">top</span>();<br>                myStk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4、二叉树的统一迭代法"><a href="#4、二叉树的统一迭代法" class="headerlink" title="4、二叉树的统一迭代法"></a>4、二叉树的统一迭代法</h3><h4 id="中旬遍历"><a href="#中旬遍历" class="headerlink" title="中旬遍历"></a>中旬遍历</h4><p><strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-comment">/*********************** 中序 ************************/</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                <br>                <span class="hljs-comment">/*********************** 前序 ************************/</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <br>                <span class="hljs-comment">/*********************** 后续 ************************/</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                <br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5、二叉树的层序遍历"><a href="#5、二叉树的层序遍历" class="headerlink" title="5、二叉树的层序遍历"></a>5、二叉树的层序遍历</h3><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣102题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        queue&lt;TreeNode *&gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> result;<br><br>        myQue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>                <br>                res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>                myQue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h4><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">力扣107题</a>——二叉树的层序遍历Ⅱ</p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历</p><p>解：在最后反转一下数组就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">力扣199题</a>——二叉树的右视图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        queue&lt;TreeNode *&gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root = <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 这里不能简写位 if(root)</span><br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode * tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">if</span> (i == (size - <span class="hljs-number">1</span>)) result.<span class="hljs-built_in">push_back</span>(tmp-&gt;val); <span class="hljs-comment">// 将每一层的最后元素放入result数组中</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">力扣637题</a>——二叉树的层平均值</p><p>简单，获取到每层的数量 size 后，结点总和 sum 加起来除以 size 就行</p><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">力扣429题</a>——N叉树的层序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br>    <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>        Node *tmp = myQue.<span class="hljs-built_in">front</span>();<br>        myQue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; tmp-&gt;children.<span class="hljs-built_in">size</span>(); j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(tmp-&gt;children[j])   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;children[j]);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>    &#125;<br>    result.<span class="hljs-built_in">push_back</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">力扣515题</a>——在每个数行中找最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> max = INT_MIN;<span class="hljs-comment">/////////////////// int的最小值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>    TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>    myQue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>    <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br><br>    <span class="hljs-keyword">if</span>(tmp-&gt;val &gt; max)  max = tmp-&gt;val;<br>&#125;<br>result.<span class="hljs-built_in">push_back</span>(max);<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">力扣116题</a>——填充每个节点的下一个右侧节点指针</p><p>本题依然是层序遍历，只不过在单层遍历的时候单独处理每层最后节点，使其指向NULL，其他弹出的节点就指向队头节点</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">力扣117题</a>——填充每个节点的下一个右侧节点指针Ⅱ</p><p>跟上一题一样</p><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣104题</a>——二叉树的最大深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>            deep++;   <span class="hljs-comment">//////////////////////////////////////</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣111题</a>——二叉树的最小深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            deep++;   <span class="hljs-comment">//////////////////////////////////////</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; tmp-&gt;right == <span class="hljs-literal">NULL</span>) <br>                    <span class="hljs-keyword">return</span> deep; <span class="hljs-comment">//////</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6、翻转二叉树"><a href="#6、翻转二叉树" class="headerlink" title="6、翻转二叉树"></a>6、翻转二叉树</h3><p><a href="https://leetcode.cn/problems/invert-binary-tree/">力扣226题</a></p><p>想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。</p><p>关键在于遍历顺序，前中后序应该选哪一种遍历顺序？</p><p>遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。</p><p><strong>注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果</strong></p><p><strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong></p><p>那么层序遍历可以不可以呢？<strong>依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！</strong></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><h5 id="深度优先遍历（看不太懂）"><a href="#深度优先遍历（看不太懂）" class="headerlink" title="深度优先遍历（看不太懂）"></a>深度优先遍历（看不太懂）</h5><p>C++代码迭代法（前序遍历）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>统一格式的迭代法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);          <span class="hljs-comment">// 节点处理逻辑</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>也就是层序遍历，层数遍历也是可以翻转这棵树的，因为层序遍历也可以把每个节点的左右孩子都翻转一遍，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 节点处理///////</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><span style="color: red; font-weight: bold;"><strong>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</strong></span></p><h3 id="7、周末总结"><a href="#7、周末总结" class="headerlink" title="7、周末总结"></a>7、周末总结</h3><h3 id="8、对称二叉树"><a href="#8、对称二叉树" class="headerlink" title="8、对称二叉树"></a>8、对称二叉树</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">力扣101题</a></p><p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p>那么遍历的顺序应该是什么样的呢？</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p><p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><h5 id="1）确定递归函数的参数和返回值"><a href="#1）确定递归函数的参数和返回值" class="headerlink" title="1）确定递归函数的参数和返回值"></a>1）确定递归函数的参数和返回值</h5><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p><p>返回值自然是bool类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span><br></code></pre></td></tr></table></figure><h5 id="2）确定终止条件"><a href="#2）确定终止条件" class="headerlink" title="2）确定终止条件"></a>2）确定终止条件</h5><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p><ul><li>左节点为空，右节点不为空，不对称，return false</li><li>左不为空，右为空，不对称 return false</li><li>左右都为空，对称，返回true</li></ul><p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><ul><li>左右都不为空，比较节点数值，不相同就return false</li></ul><p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 注意这里我没有使用else</span><br></code></pre></td></tr></table></figure><p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p><h5 id="3）确定单层递归的逻辑"><a href="#3）确定单层递归的逻辑" class="headerlink" title="3）确定单层递归的逻辑"></a>3）确定单层递归的逻辑</h5><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br><span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br><span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中（逻辑处理）</span><br><span class="hljs-keyword">return</span> isSame;<br></code></pre></td></tr></table></figure><p>如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。</p><p>最后递归的C++整体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right); <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);  <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;       <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><p>这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p><p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</p><p><strong>使用队列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    queue&lt;TreeNode *&gt; myQue;<br>    myQue.<span class="hljs-built_in">push</span>(root-&gt;left);<br>    myQue.<span class="hljs-built_in">push</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        TreeNode *nl = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>        TreeNode *nr = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span>(nl == <span class="hljs-literal">NULL</span> &amp;&amp; nr == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl != <span class="hljs-literal">NULL</span> &amp;&amp; nr == <span class="hljs-literal">NULL</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl == <span class="hljs-literal">NULL</span> &amp;&amp; nr != <span class="hljs-literal">NULL</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl-&gt;val != nr-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        myQue.<span class="hljs-built_in">push</span>(nl-&gt;left);<br>        myQue.<span class="hljs-built_in">push</span>(nr-&gt;right);<br>        myQue.<span class="hljs-built_in">push</span>(nl-&gt;right);<br>        myQue.<span class="hljs-built_in">push</span>(nr-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用栈</strong></p><p>细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。</p><p>只要把队列原封不动的改成栈就可以了，我下面也给出了代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; st; <span class="hljs-comment">// 这里改成了栈</span><br>        st.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        st.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* rightNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            TreeNode* leftNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;left);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h4><p><a href="https://leetcode.cn/problems/same-tree/">力扣100题</a>——相同的树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt;   myQue;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        myQue.<span class="hljs-built_in">push</span>(p);<br>        myQue.<span class="hljs-built_in">push</span>(q);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *np = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>            TreeNode *nq = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(!np &amp;&amp; !nq)  <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span>(!np || !nq || (np-&gt;val != nq-&gt;val))  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;right);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subtree-of-another-tree/">力扣572题</a>——另一棵树的子树</p><p>这道题在 <strong>相同的树</strong> 的基础上就很好做了，遍历原来树的每一个节点，与子树判断是否是相同的树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> &amp;&amp; subRoot == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        queue&lt;TreeNode *&gt; myQue;<br><br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>            myQue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSameTree</span>(tmp, subRoot))    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>            <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>        &#125;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt;   myQue;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        myQue.<span class="hljs-built_in">push</span>(p);<br>        myQue.<span class="hljs-built_in">push</span>(q);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *np = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>            TreeNode *nq = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(!np &amp;&amp; !nq)  <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span>(!np || !nq || (np-&gt;val != nq-&gt;val))  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;right);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9、二叉树的最大深度"><a href="#9、二叉树的最大深度" class="headerlink" title="9、二叉树的最大深度"></a>9、二叉树的最大深度</h3><p>前面做过的，层序遍历，遍历了有多少层，深度就是多少</p><h4 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h4><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣559题</a>——N叉树的最大深度</p><p>包含了N叉树的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        queue&lt;Node* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                Node *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; tmp-&gt;children.<span class="hljs-built_in">size</span>(); j++)<br>                    <span class="hljs-keyword">if</span>(tmp-&gt;children[j])   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;children[j]);<br>            &#125;<br>            deep++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10、二叉树的最小深度"><a href="#10、二叉树的最小深度" class="headerlink" title="10、二叉树的最小深度"></a>10、二叉树的最小深度</h3><p>这个也是前面做过的，</p><p>思路：只要判断出了一个节点的左右节点都为空，就是他的最小深度，即返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            deep++;   <span class="hljs-comment">//////////////////////////////////////</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; tmp-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> deep;  <span class="hljs-comment">///////////</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11、完全三叉树的节点个数"><a href="#11、完全三叉树的节点个数" class="headerlink" title="11、完全三叉树的节点个数"></a>11、完全三叉树的节点个数</h3><h4 id="普通二叉树的做法"><a href="#普通二叉树的做法" class="headerlink" title="普通二叉树的做法"></a>普通二叉树的做法</h4><p>迭代：层序遍历</p><p>低轨：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">![完全二叉树](刷题笔记/完全二叉树.png)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bianl</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftnum = <span class="hljs-built_in">bianl</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightnum = <span class="hljs-built_in">bianl</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> total = leftnum + rightnum + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">bianl</span>(root);<br>        <br>        <span class="hljs-keyword">return</span> num;<br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点</p><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" class=""><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><h5 id="第二部-终止条件"><a href="#第二部-终止条件" class="headerlink" title="第二部 终止条件"></a>第二部 终止条件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><span class="hljs-comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span><br>TreeNode* left = root-&gt;left;<br>TreeNode* right = root-&gt;right;<br><span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br><span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>    left = left-&gt;left;<br>    leftDepth++;<br>&#125;<br><span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>    right = right-&gt;right;<br>    rightDepth++;<br>&#125;<br><span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="第三步-单层递归的逻辑"><a href="#第三步-单层递归的逻辑" class="headerlink" title="第三步 单层递归的逻辑"></a>第三步 单层递归的逻辑</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> leftTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;left);       <span class="hljs-comment">// 左</span><br><span class="hljs-type">int</span> rightTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;right);     <span class="hljs-comment">// 右</span><br><span class="hljs-type">int</span> result = leftTreeNum + rightTreeNum + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>精简后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>        <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>            left = left-&gt;left;<br>            leftDepth++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>            right = right-&gt;right;<br>            rightDepth++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.png" class=""><h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><h4 id="1）什么是回溯"><a href="#1）什么是回溯" class="headerlink" title="1）什么是回溯"></a>1）什么是回溯</h4><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p><h4 id="2）回溯法的效率"><a href="#2）回溯法的效率" class="headerlink" title="2）回溯法的效率"></a>2）回溯法的效率</h4><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h4 id="3）回溯法解决的问题"><a href="#3）回溯法解决的问题" class="headerlink" title="3）回溯法解决的问题"></a>3）回溯法解决的问题</h4><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p><h4 id="4）如何理解回溯法"><a href="#4）如何理解回溯法" class="headerlink" title="4）如何理解回溯法"></a>4）如何理解回溯法</h4><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h4 id="5）回溯法模板"><a href="#5）回溯法模板" class="headerlink" title="5）回溯法模板"></a>5）回溯法模板</h4><p><strong>回溯的三部曲</strong></p><ul><li><p>回溯函数模板返回值以及参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></table></figure></li><li><p>回溯函数终止条件</p><p>既然是树形结构，那么我们在讲解<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (终止条件) &#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>回溯搜索的遍历过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p></li></ul><p>​分析完过程，回溯算法模板框架如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h3><p><a href="https://leetcode.cn/problems/combinations/">力扣77题</a>——组合</p><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt;= n - (k - res.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(i + <span class="hljs-number">1</span>, n, k);<br>            res.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>       <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">1</span>, n, k);<br>       <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3、组合优化"><a href="#3、组合优化" class="headerlink" title="3、组合优化"></a>3、组合优化</h3><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96.png" class=""><h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p><p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p><p>接下来看一下优化过程如下：</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p><p>所以优化之后的for循环是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) <span class="hljs-comment">// i为本次搜索的起始位置</span><br></code></pre></td></tr></table></figure><h3 id="4、组合总和Ⅲ"><a href="#4、组合总和Ⅲ" class="headerlink" title="4、组合总和Ⅲ"></a>4、组合总和Ⅲ</h3><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣216题</a>——组合总和Ⅲ</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        if(path.size() == k &amp;&amp; sum == n)// 这样写会出错， 因为这不能同时判断</span><br><span class="hljs-comment">        &#123;   // 不管sum 是否等于 0，  只要位数到了，就要返回</span><br><span class="hljs-comment">            result.push_back(path);</span><br><span class="hljs-comment">            return ;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(sum == n)<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            sum += i;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5、电话号码的字符组合"><a href="#5、电话号码的字符组合" class="headerlink" title="5、电话号码的字符组合"></a>5、电话号码的字符组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣17题</a>——电话号码的字母组合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//                 我的代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; result;<br><br>    string numToChar[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; digits, string str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">size</span>() == n)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numToChar[digits[str.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            str += numToChar[digits[str.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">2</span>][i];<br>            <span class="hljs-built_in">backtracking</span>(n, digits, str);<br>            str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = digits.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> result;<br><br>        <span class="hljs-built_in">backtracking</span>(n, digits, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>        <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/********************************  代码随想录  *******************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    string s;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; digits, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[index] - <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-comment">// 将index指向的数字转为int</span><br>        string letters = letterMap[digit];      <span class="hljs-comment">// 取数字对应的字符集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            s.<span class="hljs-built_in">push_back</span>(letters[i]);            <span class="hljs-comment">// 处理  ///////////////////</span><br>            <span class="hljs-built_in">backtracking</span>(digits, index + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 递归，注意index+1，一下层要处理下一个数字了</span><br>            s.<span class="hljs-built_in">pop_back</span>();                       <span class="hljs-comment">// 回溯///////////////</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        s.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6、周总结"><a href="#6、周总结" class="headerlink" title="6、周总结"></a>6、周总结</h3><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>。</p><p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下。</p><p>回溯算法能解决如下问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>本题我把回溯问题抽象为树形结构，可以直观的看出其搜索的过程：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong></p><p><strong>for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了</strong>。</p><p>回溯法抽象为树形结构后，其遍历过程就是：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p><h3 id="7、组合总和"><a href="#7、组合总和" class="headerlink" title="7、组合总和"></a>7、组合总和</h3><p><a href="https://leetcode.cn/problems/combination-sum/">力扣39题</a>——组合总和</p><p>这道题的难点在于，回溯得出所有结果后，对同一个数字具有相同个数的结果进行去重操作</p><p>比如说[2,2,3]和[2,3,2] 这是同一个结果，但是回溯，都不能识别为同一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/********************************  我的代码  *******************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">const</span> <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;= target)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum == target)<br>            &#123;<br>                <span class="hljs-built_in">sort</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>                res.<span class="hljs-built_in">insert</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = res.<span class="hljs-built_in">begin</span>(); it != res.<span class="hljs-built_in">end</span>(); ++it)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(*it);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">我的代码中，使用了 std::set 来存储结果以去重，这虽然有效，但效率可能不高。而且你期望的输出与实际输出不同的原因在于，每次递归都从头开始遍历 candidates，这可能导致重复组合。我们可以通过引入递归中的索引限制，确保组合是非递减顺序，从而避免重复组合。</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>上面这个是错误代码，不能通过测试用例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/********************************  代码随想录  *******************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum == target)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)<br>        &#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-comment">// // 不用i+1了，表示可以重复读取当前的  //////////// 重点， 重复取就是 i， </span><br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8、组合总和Ⅱ"><a href="#8、组合总和Ⅱ" class="headerlink" title="8、组合总和Ⅱ"></a>8、组合总和Ⅱ</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣39题</a>——组合总和Ⅱ</p><p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p><p>一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！</p><p>所以要在搜索的过程中就去掉重复组合。</p><p>这个去重为什么很难理解呢，<strong>所谓去重，其实就是使用过的元素不能重复选取。</strong> 这么一说好像很简单！</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><p>为了理解去重我们来举一个例子，candidates &#x3D; [1, 1, 2], target &#x3D; 3，（方便起见candidates已经排序了）</p><p><strong>强调一下，树层去重的话，需要对数组排序！</strong></p><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1.png" class=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="15、全排列"><a href="#15、全排列" class="headerlink" title="15、全排列"></a>15、全排列</h3><p><a href="https://leetcode.cn/problems/permutations/">力扣46题</a>——全排列</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。但排列问题需要一个used数组，标记已经选择的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*********************************  我的代码   *********************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;st)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-literal">false</span>)<br>            &#123;   <br>                st[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracing</span>(nums, st);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                st[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(nums, st);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*********************************  代码随想录   *********************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>大家此时可以感受出排列问题的不同：</p><ul><li>每层都是从0开始搜索而不是startIndex</li><li>需要used数组记录path里都放了哪些元素</li></ul><h3 id="21、解数独"><a href="#21、解数独" class="headerlink" title="21、解数独"></a>21、解数独</h3><p><a href="https://leetcode.cn/problems/permutations/">力扣37题</a>——解数独</p><h4 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h4><ul><li>递归函数以及参数</li></ul><p><strong>递归函数的返回值需要是bool类型，为什么呢？</strong></p><p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回， 相当于找根节点到叶子节点一条唯一路径，所以需要使用<code>bool</code>返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span><br></code></pre></td></tr></table></figure><ul><li>递归终止条件</li></ul><p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。（因为只有一个结果？）</p><p><strong>不用终止条件会不会死循环？</strong></p><p>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p><p>我们需要的是一个二维的递归 （一行一列）</p><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><p><strong>二维递归？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                    board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                    board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                           <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意这里return false的地方，这里放return false 是有讲究的</strong>。</p><p>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</p><p>那么会直接返回， <strong>这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！</strong></p><h4 id="判断棋盘是否合法"><a href="#判断棋盘是否合法" class="headerlink" title="判断棋盘是否合法"></a>判断棋盘是否合法</h4><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123; <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                        board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123; <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="1、贪心的理论基础"><a href="#1、贪心的理论基础" class="headerlink" title="1、贪心的理论基础"></a>1、贪心的理论基础</h3><h4 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h4><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p><h4 id="贪心一半解题步骤"><a href="#贪心一半解题步骤" class="headerlink" title="贪心一半解题步骤"></a>贪心一半解题步骤</h4><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h3 id="2、分发饼干"><a href="#2、分发饼干" class="headerlink" title="2、分发饼干"></a>2、分发饼干</h3><p><a href="https://leetcode.cn/problems/assign-cookies/">力扣455题</a>——分发饼干</p><p><strong>思路</strong></p><p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p><p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p><p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p><p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p><p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">// 用 index 表示了未分发的饼干x</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<span class="hljs-comment">// 这里采用了反向遍历小孩的胃口值</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i])<br>            &#123;<br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="基础数据结构和算法"><a href="#基础数据结构和算法" class="headerlink" title="基础数据结构和算法"></a>基础数据结构和算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1、堆"><a href="#1、堆" class="headerlink" title="1、堆"></a>1、堆</h3><p>[参考视频](【【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆】<a href="https://www.bilibili.com/video/BV1AF411G7cA?vd_source=8cc270f687a3e8776461d428d0e05aa9">https://www.bilibili.com/video/BV1AF411G7cA?vd_source=8cc270f687a3e8776461d428d0e05aa9</a>)</p><h3 id="2、红黑树与AVL树"><a href="#2、红黑树与AVL树" class="headerlink" title="2、红黑树与AVL树"></a>2、红黑树与AVL树</h3><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是一种自平衡的二叉搜索树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</p><p>通过对任何一条从根到叶子的路径上的路径上各个节点着色方式的限制，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡</p><p>红黑树是一种弱平衡二叉树，相对于要求严格的 <code>AVL</code> 树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p><p><strong>性质</strong></p><ol><li>每个节点非红即黑；</li><li>根节点是黑的；</li><li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的；</li><li>如果一个节点是红色的，则它的子节点必须是黑色的</li><li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点</li></ol><h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><p>红黑树是在AVL树的基础上提出来的</p><p>平衡二叉树又称AVL树，是一种特殊的二叉排序树</p><p>其左右子树都是平衡二叉树，且左右子树高度只差不超过1</p><p><strong>红黑树较AVL树的优点</strong></p><p><code>AVL</code> 树是高度自平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降</p><p>红黑树不是高度自平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p><p>所以红黑树在查找，插入删除的性能都是 <code>O(logn)</code> ，且性能稳定，所以STL里面很多结构包括 <code>set、map</code> 底层实现都是使用的红黑树。</p><h3 id="3、字典树（Trie树）"><a href="#3、字典树（Trie树）" class="headerlink" title="3、字典树（Trie树）"></a>3、字典树（Trie树）</h3><p>性质：</p><ol><li>根节点不保存字符，每个节点保存一个字符</li><li>从根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ol><p>应用：统计，排序，保存大量字符串</p><p>优点：利用字符的公共前缀减少查询时间，最大限度的减少无谓的字符串比较</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h3><h5 id="快速排序——基于分治（nlogn）"><a href="#快速排序——基于分治（nlogn）" class="headerlink" title="快速排序——基于分治（nlogn）"></a>快速排序——基于分治（<code>nlogn</code>）</h5><p><strong>快速排序的基本思想</strong></p><p>1、确定分界点   2、调整区间3、低轨处理左右两端</p><ol><li>确定分界点：最好取中间的元素，第一个和最后一个元素也可以</li><li>调整区间：通过一次排序将数组分为了两个部分，一半比分界点小，另一半比分界点大</li><li>低轨处理左右两端：低轨处理分界点左右两边的子数据进行快速排序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt;= r)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j)<span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick</span>(q, l, j);<br>    <span class="hljs-built_in">quick</span>(q, j + l, r);<br>    <span class="hljs-comment">//也可以改成i，quick_sort(q, l, i-1);  quick_sort(q, i, r);</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优势</strong></p><ol><li>时间效率高：平均比其他 <code>O(nlogn)</code>算法（归并、堆排序）更快</li><li><strong>原地排序</strong>：快速排序不需要额外的存储空间，适合处理大数据集</li><li>广泛应用：常用于各种场景中排序操作的实现（标准函数库实现）</li></ol><p><strong>劣势</strong></p><p>最坏情况退化为 <code>O(n^2)</code>:在特俗情况下（选择的分界点总是最大值或最小值），性能会退化</p><p>快速排序不稳定：快速排序不是稳定排序，元素相等时，元素的相对位置可能会改变。</p><h5 id="归并排序——基于分治（nlogn）"><a href="#归并排序——基于分治（nlogn）" class="headerlink" title="归并排序——基于分治（nlogn）"></a>归并排序——基于分治（<code>nlogn</code>）</h5><p><strong>归并排序的基本思想</strong></p><p>1、以数组中间为分界点 mid &#x3D; (left + right) &#x2F; 22、低轨排序left和right3、归并——合二为一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(l &gt;= r)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">mergeSort</span>(q, l, mid);<br>    <span class="hljs-built_in">mergeSort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, r = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 合并两个有序数组</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])<br>            tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span><br>            tmp[k++] = q[j++];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid)tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r)tmp[k++] = q[j++];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)q[i] = tmp[j]; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong></p><ol><li>稳定性：归并排序是稳定的排序算法，即相等元素的相对顺序不会改变</li><li>时间复杂度良好：无论数据的初始状态，始终为 <code>O(nlogn)</code></li><li>适用于大数据：对外部存储排序时，因为他是个稳定的线性时间排序算法</li></ol><p><strong>缺点</strong></p><ol><li><p>空间复杂度高：需要额外 <code>O(n)</code> 的空间</p></li><li><p>在小规模数据上效率不如快速排序</p></li></ol><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyWebServer</title>
    <link href="/2024/06/02/MyWebServer/"/>
    <url>/2024/06/02/MyWebServer/</url>
    
    <content type="html"><![CDATA[<h1 id="MyWebServer"><a href="#MyWebServer" class="headerlink" title="MyWebServer"></a>MyWebServer</h1><h2 id="webserver学习总结"><a href="#webserver学习总结" class="headerlink" title="webserver学习总结"></a>webserver学习总结</h2><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p>[1、小白视角：一文读懂社长的TinyWebServer(Raw_Version)](<a href="https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more">小白视角：一文读懂社长的TinyWebServer | HU (huixxi.github.io)</a>)</p><h3 id="Socket网络编程"><a href="#Socket网络编程" class="headerlink" title="Socket网络编程"></a>Socket网络编程</h3><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>使用webbench工具进行测试，直接运行因为权限问题不够找不到命令无法执行，使用下面的命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc webbench.c -o webbench<br></code></pre></td></tr></table></figure><p>重新编译该文件时遇到报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">webbench.c:<span class="hljs-number">21</span>:<span class="hljs-number">10</span>: fatal error: rpc/types.h: 没有那个文件或目录<br>   <span class="hljs-number">21</span> | <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rpc/types.h&gt;</span></span><br>      |          ^~~~~~~~~~~~~<br>解决方案：将&lt;rpc/typed.h&gt;改为&lt;sys/typed.h&gt;后重新编译<br></code></pre></td></tr></table></figure><p>然后在解压目录打开终端运行命令（<code>-c</code>表示客户端数， <code>-t</code>表示时间）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./webbench -c <span class="hljs-number">10001</span> -t <span class="hljs-number">5</span> http:<span class="hljs-comment">//127.0.0.1:9006/</span><br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Webbench - Simple Web Benchmark <span class="hljs-number">1.5</span><br>Copyright (c) Radim Kolar <span class="hljs-number">1997</span><span class="hljs-number">-2004</span>, GPL Open Source Software.<br><br>Benchmarking: GET http:<span class="hljs-comment">//127.0.0.1:9007/</span><br><span class="hljs-number">10001</span> clients, running <span class="hljs-number">5</span> sec.<br><br>Speed=<span class="hljs-number">503340</span> pages/min, <span class="hljs-number">939568</span> bytes/sec.<br>Requests: <span class="hljs-number">41945</span> susceed, <span class="hljs-number">0</span> failed.<br></code></pre></td></tr></table></figure><h4 id="Webbench是什么，介绍一下原理"><a href="#Webbench是什么，介绍一下原理" class="headerlink" title="Webbench是什么，介绍一下原理"></a>Webbench是什么，介绍一下原理</h4><p>WebBench 是一个简单、实用的 Web 压力测试工具。它主要用于测试 Web 服务器的性能，通过模拟大量客户端访问服务器，以评估服务器在高负载下的表现。</p><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p><h2 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h2><h3 id="添加一个HTML和CSS的登录界面"><a href="#添加一个HTML和CSS的登录界面" class="headerlink" title="添加一个HTML和CSS的登录界面"></a>添加一个HTML和CSS的登录界面</h3><p>HTML和CSS素材来自：<a href="https://mp.weixin.qq.com/s/0snX38O4LQsglgd_dsY57g">微信公众号</a></p><h4 id="代码中响应HTTP的逻辑部分"><a href="#代码中响应HTTP的逻辑部分" class="headerlink" title="代码中响应HTTP的逻辑部分"></a>代码中响应HTTP的逻辑部分</h4><p>该方法中可以根据HTML代码中的 <code>form</code> 中的 <code>action</code> 和 <code>post</code> 方法，来传输到服务器中进行逻辑判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>新用户<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务器代码中实现处理HTTP请求的方法在文件 <code>http_conn.cpp</code> 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理HTTP请求的方法</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::do_request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">strcpy</span>(m_real_file, doc_root);      <span class="hljs-comment">// 将 doc_root 的值复制到 m_real_file 中</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(doc_root);<br>    <span class="hljs-comment">//printf(&quot;m_url:%s\n&quot;, m_url);</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = <span class="hljs-built_in">strrchr</span>(m_url, <span class="hljs-string">&#x27;/&#x27;</span>);    <span class="hljs-comment">// 查找m_url中最后一个/字符的位置。</span><br><br>    <span class="hljs-comment">//处理cgi       如果cgi标志为1，并且URL中最后一个/后面紧跟的字符是&#x27;2&#x27;或&#x27;3&#x27;，进入处理CGI部分的代码块。</span><br>    <span class="hljs-keyword">if</span> (cgi == <span class="hljs-number">1</span> &amp;&amp; (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;2&#x27;</span> || *(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;3&#x27;</span>))   <br>    &#123;<br>        <span class="hljs-comment">//根据标志判断是登录检测还是注册检测</span><br>        <span class="hljs-type">char</span> flag = m_url[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取m_url中的第二个字符，存储在flag中。</span><br><br>        <span class="hljs-comment">// 动态分配200字节的内存给m_url_real，并将m_url从第三个字符开始的子串连接到/后面，</span><br>        <span class="hljs-comment">// 构建新的URL路径，最后将其复制到m_real_file中，并释放分配的内存。</span><br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-built_in">strcat</span>(m_url_real, m_url + <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">free</span>(m_url_real);<br><br>        <span class="hljs-comment">//将用户名和密码提取出来</span><br>        <span class="hljs-comment">//user=123&amp;passwd=123</span><br>        <span class="hljs-type">char</span> name[<span class="hljs-number">100</span>], password[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">5</span>; m_string[i] != <span class="hljs-string">&#x27;&amp;&#x27;</span>; ++i)<br>            name[i - <span class="hljs-number">5</span>] = m_string[i];<br>        name[i - <span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = i + <span class="hljs-number">10</span>; m_string[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i, ++j)<br>            password[j] = m_string[i];<br>        password[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">//如果是注册，先检测数据库中是否有重名的</span><br>        <span class="hljs-comment">//没有重名的，进行增加数据</span><br>        <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;3&#x27;</span>)<br>        &#123;<br>            <span class="hljs-type">char</span> *sql_insert = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>            <span class="hljs-built_in">strcpy</span>(sql_insert, <span class="hljs-string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, name);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, <span class="hljs-string">&quot;&#x27;, &#x27;&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, password);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, <span class="hljs-string">&quot;&#x27;)&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> (users.<span class="hljs-built_in">find</span>(name) == users.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                m_lock.<span class="hljs-built_in">lock</span>();<br>                <span class="hljs-type">int</span> res = <span class="hljs-built_in">mysql_query</span>(mysql, sql_insert);<br>                users.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, string&gt;(name, password));<br>                m_lock.<span class="hljs-built_in">unlock</span>();<br><br>                <span class="hljs-keyword">if</span> (!res)<br>                    <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/log.html&quot;</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/registerError.html&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/registerError.html&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果是登录，直接判断</span><br>        <span class="hljs-comment">//若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;2&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (users.<span class="hljs-built_in">find</span>(name) != users.<span class="hljs-built_in">end</span>() &amp;&amp; users[name] == password)<br>                <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/welcome.html&quot;</span>);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/logError.html&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)    <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;0&#x27;，处理注册页面请求：</span><br>    &#123;   <br>        <span class="hljs-comment">// 构建注册页面路径并复制到m_real_file中，然后释放动态分配的内存。</span><br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/register.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)   <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;1&#x27;，处理登录页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/log.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;5&#x27;</span>) <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;5&#x27;，处理图片页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/picture.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;6&#x27;</span>)  <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;6&#x27;，处理视频页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/video.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;7&#x27;</span>)   <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;7&#x27;，处理粉丝页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/fans.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 处理其他未明确指定的请求，直接将`m_url`复制到`m_real_file`中。</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 检查m_real_file是否存在。如果不存在，返回NO_RESOURCE错误</span><br>        <span class="hljs-keyword">return</span> NO_RESOURCE;<br><br>    <span class="hljs-keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))   <span class="hljs-comment">// 检查文件权限。如果文件不可读，返回`FORBIDDEN_REQUEST`错误。</span><br>        <span class="hljs-keyword">return</span> FORBIDDEN_REQUEST;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISDIR</span>(m_file_stat.st_mode))   <span class="hljs-comment">// 检查文件类型。如果是目录，返回BAD_REQUEST错误。</span><br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br><br>    <span class="hljs-comment">// 打开文件并将其映射到内存中，然后关闭文件描述符，返回`FILE_REQUEST`。</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(m_real_file, O_RDONLY);<br>    m_file_address = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> FILE_REQUEST;<br>&#125;<br></code></pre></td></tr></table></figure><p>用GPT生成了 <code>root</code> 目录下的 <code>style.css</code> 文件，修改了 <code>judge.html</code> 、<code>log.html</code> 、<code>register.html</code> 文件，使其符合要求</p><p>其中，有一部分不太明白，我觉得应该去看看HTML请求体的结构和内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;2CGISQL.cgi&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;required&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 这部分不太懂 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;登录密码&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;required&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 这部分不太懂 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基础知识学习"><a href="#基础知识学习" class="headerlink" title="基础知识学习"></a>基础知识学习</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="1、什么是进程？"><a href="#1、什么是进程？" class="headerlink" title="1、什么是进程？"></a>1、什么是进程？</h4><ul><li>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li><li>它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li><li>从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序 代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信 息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的 有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li><li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始 运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li><li>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li></ul><h4 id="2、并行和并发"><a href="#2、并行和并发" class="headerlink" title="2、并行和并发"></a>2、并行和并发</h4><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使 得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干 段，使多个进程快速交替的执行。</p><p><strong>并发是两个队列交替使用一台咖啡机。并行是两个队列同时使用两台咖啡机。</strong></p><h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 <strong>task_struct 结构体</strong>。结构体组成：</p><ul><li>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</li><li>进程的状态：有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录（Current Working Directory）</li><li>umask 掩码</li><li>文件描述符表，包含很多指向 file 结构体的指针</li><li>和信号相关的信息</li><li>用户 id 和组 id </li><li>会话（Session）和进程组 </li><li>进程可以使用的资源上限（Resource Limit）</li></ul><h4 id="3、进程的状态"><a href="#3、进程的状态" class="headerlink" title="3、进程的状态"></a>3、进程的状态</h4><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型 中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。</p><img src="/2024/06/02/MyWebServer/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" class=""><ul><li><p>运行态：进程占有处理器正在运行</p></li><li><p>就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必 要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常 将它们排成一个队列，称为就绪队列</p></li><li><p>阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程<strong>不具备运行条件，正在等待某个事件的完成</strong></p></li></ul><p><strong>在五态模型中</strong>，进程分为<strong>新建态</strong>、就绪态，运行态，阻塞态，终止态。</p><ul><li>新建态：进程刚被创建时的状态，尚未进入就绪队列</li><li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终 止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待 善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</li></ul><h4 id="4、进程的相关指令"><a href="#4、进程的相关指令" class="headerlink" title="4、进程的相关指令"></a>4、进程的相关指令</h4><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux / ajx<br>a：显示终端上的所有进程，包括其他用户的进程<br>u：显示进程的详细信息<br>x：显示没有控制终端的进程<br>j：列出与作业控制相关的信息<br><br>STAT参数意义<br>D 不可中断 Uninterruptible（usually IO）<br>R 正在运行，或在队列中的进程<br>S 处于休眠状态<br>T 停止或被追踪<br>Z 僵尸进程<br>W 进入内存交换（从内核2.6开始无效）<br>X 死掉的进程<br>&lt; 高优先级<br>N 低优先级<br>s 包含子进程<br>+ 位于前台的进程组<br></code></pre></td></tr></table></figure><p>实时显示进程动态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">top<br><br>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键<br>对显示的结果进行排序：<br>M 根据内存使用量排序<br>P 根据 CPU 占有率排序<br>T 根据进程运行时间长短排序<br>U 根据用户名来筛选进程<br>K 输入指定的 PID 杀死进程<br></code></pre></td></tr></table></figure><p>杀死进程 （kill名并不是去杀死一个进程，而是给进程发送某个信号）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> [-signal] pid<br><span class="hljs-built_in">kill</span> –l 列出所有信号<br><span class="hljs-built_in">kill</span> –SIGKILL 进程ID<br><span class="hljs-built_in">kill</span> -9 进程ID<br>killall name 根据进程名杀死进程<br></code></pre></td></tr></table></figure><h4 id="5、进程号相关函数"><a href="#5、进程号相关函数" class="headerlink" title="5、进程号相关函数"></a>5、进程号相关函数</h4><p>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一 的，但可以重用。当一个进程终止后，其进程号就可以再次使用。 </p><p>任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为 父进程号（PPID）。 </p><p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进 程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。 进程号和进程组相关函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">// 获取进程id</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;  <span class="hljs-comment">// 获取父进程id</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="6、进程的创建"><a href="#6、进程的创建" class="headerlink" title="6、进程的创建"></a>6、进程的创建</h4><h5 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h5><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;   <br><br></code></pre></td></tr></table></figure><p>返回值： </p><p>​成功：子进程中返回 0，父进程中返回子进程 ID </p><p>​失败：返回 -1 </p><p>失败的两个主要原因： </p><p>​当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN </p><p>​系统内存不足，这时 errno 的值被设置为 ENOMEM</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pid_t fork(void) I</span><br><span class="hljs-comment">函数的作用:用于创建子进程。</span><br><span class="hljs-comment">返回值:</span><br><span class="hljs-comment">fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。在父进程中返回创建的子进程的ID,</span><br><span class="hljs-comment">在子进程中返回日</span><br><span class="hljs-comment">如何区分父进程和子进程:通过fork的返回值。</span><br><span class="hljs-comment">在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 判断是父进程还是子进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid : %d\n&quot;</span>, pid);<br>        <span class="hljs-comment">//如果大于0，创建的是子进程编号</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parents process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-comment">// 当前是子进程代码</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="exec-函数族介绍"><a href="#exec-函数族介绍" class="headerlink" title="exec 函数族介绍"></a>exec 函数族介绍</h5><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就 是在调用进程内部执行一个可执行文件。</p><p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被 新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱 壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调 用点接着往下执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/* (char *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... <span class="hljs-comment">/* (char *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char * const</span></span><br><span class="hljs-comment"><span class="hljs-params">envp[] */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><br></code></pre></td></tr></table></figure><ul><li>l(list) 参数地址列表，以空指针结尾 </li><li>v(vector) 存有各参数地址的指针数组的地址 </li><li>p(path) 按 PATH 环境变量指定的目录搜索可执行文件 </li><li>e(environment) 存有环境变量字符串地址的指针数组的地址</li></ul><h4 id="7、GDB多进程调试"><a href="#7、GDB多进程调试" class="headerlink" title="7、GDB多进程调试"></a>7、GDB多进程调试</h4><p>使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">设置调试父进程或者子进程<br><span class="hljs-built_in">set</span> follow-fork-mode [parent (默认) | child]<br><br>设置调试模式<br><span class="hljs-built_in">set</span> detach-on-fork [on | off]<br>默认为 on， 表示当前进程的时候，其他的进程继续运行，如果为off，调试当前进程的时候，其他进程被GDB挂起<br><br>查看当前调试的进程：  info inferiors<br>切换当前调试的进程： inferior <span class="hljs-built_in">id</span><br>使进程脱离GDB调试： detach inferiors <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h4 id="8、进程控制"><a href="#8、进程控制" class="headerlink" title="8、进程控制"></a>8、进程控制</h4><h5 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;    <span class="hljs-comment">// 在退出前会多一个调用退出处理函数 和 刷星I/O缓冲、关闭文件描述符</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);  <span class="hljs-comment">// 进行运行 ---&gt; 调用_exit()系统调用 ---&gt; 进程终止运行</span><br></code></pre></td></tr></table></figure><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。</p><p> 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init （pid为1） ，而 init 进程会循环地 wait() 它 的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和 政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</p><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p><p> 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害， 应当避免。</p><h5 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h5><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其 保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间 等）。</p><p>父进程可以通过调用 wait 或 waitpid 得到它的退出状态同时彻底清除掉这个进程。</p><p>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞， waitpid() 还可以指定等待哪个子进程结束。</p><p>注意：一次 wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    pid_t wait(int *wstatus);</span><br><span class="hljs-comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程资源</span><br><span class="hljs-comment">        参数: int *wstatus</span><br><span class="hljs-comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="hljs-comment">        返回值:</span><br><span class="hljs-comment">            -成功:返回被回收的子进程的id</span><br><span class="hljs-comment">            -失败:-1(所有的子进程都结束，调用函数失败)</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒</span><br><span class="hljs-comment">    如果没有子进程，函数立刻返回， 返回-1；如果子进程都结束了，也会立刻返回，返回-1</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    pid_t waitpid(pid_t pid， int *wstatus, int options);</span><br><span class="hljs-comment">功能:回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="hljs-comment">参数:</span><br><span class="hljs-comment">-pid:</span><br><span class="hljs-comment">pid &gt; 0: 某个子进程的pid</span><br><span class="hljs-comment">pid = 0: 回收当前进程组的所有子进程</span><br><span class="hljs-comment">pid = -1: 回收所有的子进程，相当于 wait()</span><br><span class="hljs-comment">pid &lt; -1: 回收某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="hljs-comment">-options: 设置阻塞或者非阻塞</span><br><span class="hljs-comment">0 ：阻塞</span><br><span class="hljs-comment">WNOHANG ：非阻塞</span><br><span class="hljs-comment">-返回值 ：</span><br><span class="hljs-comment">&gt; 0 : 返回子进程的id</span><br><span class="hljs-comment">= 0 ：options=WNOHANG, 表示还有子进程或者</span><br><span class="hljs-comment">= -1：错误，或者没有子进程</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 有一个父进程，创建4哥子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)    <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// 防止产生很多孙子进程</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parenet, pid = %d\n&quot;</span>, getpid());<br><br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)   <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">if</span>(WIFEXITED(st))<br>            &#123;<br>                <span class="hljs-comment">// 是不是正常退出</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFSIGNALED(st))<br>            &#123;<br>                <span class="hljs-comment">// 是不是异常终止</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被那个信号干掉了：%d&quot;</span>, WTERMSIG(st));<br>            &#125;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br><br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;   <br>        <br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>, getpid());<br>        sleep(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>       <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>waitpid()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">     pid_t waitpid(pid_t pid， int *wstatus, int options);</span><br><span class="hljs-comment">功能:回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="hljs-comment">参数:</span><br><span class="hljs-comment">-pid:</span><br><span class="hljs-comment">pid &gt; 0: 某个子进程的pid</span><br><span class="hljs-comment">pid = 0: 回收当前进程组的所有子进程</span><br><span class="hljs-comment">pid = -1: 回收所有的子进程，相当于 wait()</span><br><span class="hljs-comment">pid &lt; -1: 回收某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="hljs-comment">-options: 设置阻塞或者非阻塞</span><br><span class="hljs-comment">0 ：阻塞</span><br><span class="hljs-comment">WNOHANG ：非阻塞</span><br><span class="hljs-comment">-返回值 ：</span><br><span class="hljs-comment">&gt; 0 : 返回子进程的id</span><br><span class="hljs-comment">= 0 ：options=WNOHANG, 表示还有子进程或者</span><br><span class="hljs-comment">= -1：错误，或者没有子进程 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 有一个父进程，创建4哥子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)    <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// 防止产生很多孙子进程</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;   <br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parenet, pid = %d\n&quot;</span>, getpid());<br><br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-comment">// int ret = waitpid(-1, &amp;st, 0);        // 阻塞</span><br>            <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, &amp;st, WNOHANG);  <span class="hljs-comment">// 非阻塞</span><br>            <br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)   <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(WIFEXITED(st))<br>                &#123;<br>                    <span class="hljs-comment">// 是不是正常退出</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(WIFSIGNALED(st))<br>                &#123;<br>                    <span class="hljs-comment">// 是不是异常终止</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被那个信号干掉了：%d&quot;</span>, WTERMSIG(st));<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;   <br>        <br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>       <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出信息相关宏函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">WIFEXITED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程正常退出<br><span class="hljs-function"><span class="hljs-title">WEXITSTATUS</span><span class="hljs-params">(status)</span></span> 如果上宏为真，获取进程退出的状态（exit的参数）<br><span class="hljs-function"><span class="hljs-title">WIFSIGNALED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程异常终止<br><span class="hljs-function"><span class="hljs-title">WTERMSIG</span><span class="hljs-params">(status)</span></span> 如果上宏为真，获取使进程终止的信号编号<br><span class="hljs-function"><span class="hljs-title">WIFSTOPPED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程处于暂停状态<br><span class="hljs-function"><span class="hljs-title">WSTOPSIG</span><span class="hljs-params">(status)</span></span> 如果上宏为真，获取使进程暂停的信号的编号<br><span class="hljs-function"><span class="hljs-title">WIFCONTINUED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程暂停后已经继续运行<br></code></pre></td></tr></table></figure><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="1、进程间通信概念"><a href="#1、进程间通信概念" class="headerlink" title="1、进程间通信概念"></a>1、进程间通信概念</h4><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC： Inter Processes Communication )。</p><p>进程间通信的目的：</p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程。 </li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程 终止时要通知父进程）。 </li><li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 </li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够 拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><h5 id="Linux进程间通信方式"><a href="#Linux进程间通信方式" class="headerlink" title="Linux进程间通信方式"></a>Linux进程间通信方式</h5><img src="/2024/06/02/MyWebServer/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" class=""><h4 id="2、管道"><a href="#2、管道" class="headerlink" title="2、管道"></a>2、管道</h4><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都 支持这种通信机制。</p><p>统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。  | 为管道符</p><h5 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h5><ul><li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大 小不一定相同。 </li><li>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储 数据。可以按照操作文件的方式对管道进行操作。 </li><li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以 读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 </li><li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一 样的。 </li><li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的</li><li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数 据，在管道中无法使用 lseek() 来随机的访问数据。 </li><li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li></ul><h5 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h5><p>创建匿名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span>;<br></code></pre></td></tr></table></figure><p>查看管道缓冲大小命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ulimit –a<br></code></pre></td></tr></table></figure><p>查看管道缓冲大小函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-title function_">fpathconf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> name)</span>;<br></code></pre></td></tr></table></figure><p>管道的非阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int pipe(int pipefd[2]);</span><br><span class="hljs-comment">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="hljs-comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="hljs-comment">            pipefd[0] 对应的是管道的读端</span><br><span class="hljs-comment">            pipefd[1] 对应的是管道的写端</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 子进程发送数据给父进程，父进程读取到数据输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    设置管道非阻塞</span><br><span class="hljs-comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag </span><br><span class="hljs-comment">    flags |= O_NONBLOCK;                // 修改flag的值</span><br><span class="hljs-comment">    fcntl(fd[0], F_SERFL, flags);       // 设置信道flag</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <br>        <span class="hljs-comment">// 从管道的读取端读取数据 </span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-comment">// 设置管道非阻塞</span><br>        <span class="hljs-type">int</span> flags = fcntl(pipefd[<span class="hljs-number">0</span>], F_GETFL);  <span class="hljs-comment">// 获取原来的flag </span><br>        flags |= O_NONBLOCK;                <span class="hljs-comment">// 修改flag的值</span><br>        fcntl(pipefd[<span class="hljs-number">0</span>], F_SETFL, flags);       <span class="hljs-comment">// 设置信道flag</span><br><br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;len : %d\n&quot;</span>, len);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);<br>            sleep(<span class="hljs-number">1</span>); <br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>            <span class="hljs-comment">//sleep(1);</span><br><br>            <span class="hljs-comment">// int len = read(pipefd[0], buf, sizeof(buf));</span><br>            <span class="hljs-comment">// printf(&quot;child recv : %s, pid : %d\n&quot;, buf, getpid());</span><br>            <span class="hljs-comment">// bzero(buf, 1024);</span><br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="有名管道（命名管道）"><a href="#有名管道（命名管道）" class="headerlink" title="有名管道（命名管道）"></a>有名管道（命名管道）</h5><p><strong>介绍</strong></p><ol><li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道 （FIFO），也叫命名管道、FIFO文件。</li><li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存 在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不 存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不 相关的进程也能交换数据。</li><li>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了 （如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取 数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</li><li>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：<ul><li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 </li><li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 </li><li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li></ul></li></ol><p><strong>使用</strong></p><p>通过命令创建有名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mkfifo 名字<br></code></pre></td></tr></table></figure><p>通过函数创建有名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><br></code></pre></td></tr></table></figure><p>一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I&#x2F;O 函数都可用于 fifo。如： close、read、write、unlink 等。 FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写 则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中写数据</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <span class="hljs-comment">// 2、创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 3、以只写的方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4、写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中读取数据</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2、读数据</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接了....\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有名管道的注意事项</strong>*</p><ol><li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开进程</li><li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开进程</li></ol><p>读管道：</p><ul><li>管道中有数据，read返回实际读到的字节数</li><li>管道中无数据：管道写端被全部关闭，read返回0，（相当于读到文件末尾）；写端没有全部被关闭，read阻塞等待</li></ul><p>写管道:</p><ul><li>管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号)</li><li>管道读端没有全部关闭:   管道已经满了，write会阻塞；管道没有满，write将数据写入，并返回实际写入的字节数。</li></ul><p><strong>有名管道的使用完成聊天功能</strong></p><img src="/2024/06/02/MyWebServer/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//     *****************************  chatA.c **********************************</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、判断管道是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    ret = access(<span class="hljs-string">&quot;fifo2&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo2&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、以只写的方式打开管道1</span><br>    <span class="hljs-type">int</span> fdw = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fdw == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 2、以只读的方式打开管道2</span><br>    <span class="hljs-type">int</span> fdr = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fdr == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-comment">// 4、循环的读写数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);    <br>        <span class="hljs-comment">// 获取标准输入的数据</span><br>        fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-comment">// 写数据</span><br>        ret = write(fdw, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 读管道数据</span><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        ret = read(fdr, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf : %s\n&quot;</span>, buf);<br>    &#125;<br><br>    close(fdw);<br>    close(fdr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//     *****************************  chatB.c **********************************</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、判断管道是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    ret = access(<span class="hljs-string">&quot;fifo2&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo2&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、以只读的方式打开管道1</span><br>    <span class="hljs-type">int</span> fdr = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fdr == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 2、以只写的方式打开管道2</span><br>    <span class="hljs-type">int</span> fdw = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fdw == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-comment">// 4、循环的读写数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 读管道数据</span><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        ret = read(fdr, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf : %s\n&quot;</span>, buf);<br><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);    <br>        <span class="hljs-comment">// 获取标准输入的数据</span><br>        fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-comment">// 写数据</span><br>        ret = write(fdw, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    close(fdw);<br>    close(fdr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、内存映射"><a href="#3、内存映射" class="headerlink" title="3、内存映射"></a>3、内存映射</h4><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br> <span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> </span><br><span class="hljs-params">offset)</span>;<br> <span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       void *mmap(void *addr, size_t length, int prot, int flags,</span><br><span class="hljs-comment">                  int fd, off_t offset);</span><br><span class="hljs-comment">            -功能： 映射一个文件或设备到内存之中，</span><br><span class="hljs-comment">            -参数：</span><br><span class="hljs-comment">                - void *addr: NULL, 由内核决定</span><br><span class="hljs-comment">                - length: 要映射数据的长度，不能为0。建议使用文件的长度</span><br><span class="hljs-comment">                        获取文件的长度：stat  lseek 函数</span><br><span class="hljs-comment">                - prot: 对申请的内存映射区的操作权限， </span><br><span class="hljs-comment">                    PROT_EXEC  Pages may be executed.</span><br><span class="hljs-comment">                    PROT_READ  Pages may be read.</span><br><span class="hljs-comment">                    PROT_WRITE Pages may be written.</span><br><span class="hljs-comment">                    PROT_NONE  Pages may not be accessed.</span><br><span class="hljs-comment">                    要操作映射区，必须要有读的权限</span><br><span class="hljs-comment">                    PROT_READ、 PROT_READ | PROT_WRITE</span><br><span class="hljs-comment">                - flags: </span><br><span class="hljs-comment">                    - MAP_SHARD: 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须设置这个选项</span><br><span class="hljs-comment">                    - MAP_PRIVATE: 不同步， 内存映射区的数据改变了，对原来文件不会修改，会重新创建一个新的文件。</span><br><span class="hljs-comment">                - fd: 需要映射的那个文件的文件描述符</span><br><span class="hljs-comment">                    - 通过open得到，open的是一个磁盘文件</span><br><span class="hljs-comment">                    - 注意： 文件大小不能为0，open指定的权限不能和prot参数有冲突</span><br><span class="hljs-comment">                        prot: PROT_READ     open: 只读/读写</span><br><span class="hljs-comment">                        prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="hljs-comment">                - offset: 偏移量，一般不用，必须指定是4k的整数值，0表示不偏移</span><br><span class="hljs-comment">            - 返回值：返回船舰的内存的首地址</span><br><span class="hljs-comment">                失败返回MAP_FAILED, (void *) -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        int munmap(void *addr, size_t length);</span><br><span class="hljs-comment">            - 功能： 释放内存映射</span><br><span class="hljs-comment">            - 参数：</span><br><span class="hljs-comment">                -addr: 要释放内存的首地址</span><br><span class="hljs-comment">                -length: 要释放的内存的大小，要和mmap函数中的length参数要一样</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用内存映射实现进程间通信</span><br><span class="hljs-comment">    1、有关系的进程（父子间）</span><br><span class="hljs-comment">        - 还没有子进程的时候</span><br><span class="hljs-comment">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="hljs-comment">        - 有了内存映射区以后，创建子进程</span><br><span class="hljs-comment">        - 父子进程共享创建的内存映射区</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2、没有关系的进程       </span><br><span class="hljs-comment">        - 准备一个大小不是0的磁盘文件</span><br><span class="hljs-comment">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 使用内存映射区通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：内存映射区通信，是非阻塞的</span><br><span class="hljs-comment">    通过同一个磁盘文件创建了内存映射区。</span><br><span class="hljs-comment">    这意味着这两个进程都将相同的文件内容映射到它们各自的地址空间中，并且对这个文件内容的任何更改都会在两个进程中可见。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);  <span class="hljs-comment">// 获取文件的大小</span><br><br>    <span class="hljs-comment">// 2、创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3、创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv: %s\n&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4、关闭内存映射区</span><br>    munmap(ptr, size);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内存映射的注意事项</strong></p><ol><li>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功？<br>答：可以对ptr进行++操作，但是munmap会错误，需要提前保存++前的内存地址</li><li>如果open时O_RDONLY, mmap时prot参数指定 PROT_READ | PROT_WRITE 会怎样？<br>答：错误， 会返回 MAP_FAILED （即，void* -1） open() 函数中的权限建议和prot参数的权限保持一致。</li><li>如果文件偏移量为1000会怎样？<br>答：偏移量必须是4k的整数倍， 返回MAP_FAILED (分页大小)</li><li>mmap什么情况下会调用失败？<ul><li>第二个参数： length &#x3D; 0</li><li>第三个参数： prot权限有问题<ul><li>只指定了写权限</li><li>prot PROT_READ | PROT_WRITE<br>第五个参数fd 通过open函数时 未指定 O_RDONLY | O_WRONLY</li></ul></li></ul></li><li>可以open的时候O_CREATE一个新文件来创建映射区吗？<ul><li>可以， 但是创建文件大小为0的话，肯定不行</li><li>可以对新的文件进行扩展<ul><li>lseek()</li><li>truncate()  &#x2F;&#x2F; 扩招新的文件的内存</li></ul></li></ul></li><li>mmap后关闭文件描述符，对mmap映射有没有影响？<br>答：int fd &#x3D; open(“xxx”)<br>mmap(,,, fd, 0);<br>close(fd);<br>映射区还存在， 创建映射区的fd被关闭， 没有任何影响</li><li>对ptr越界操作会怎样？<br>答：越界操作，操作的是非法内存，-&gt; 段错误</li></ol><h4 id="4、信号"><a href="#4、信号" class="headerlink" title="4、信号"></a>4、信号</h4><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中 断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的 进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。 </li><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。 比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 </li><li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者 该进程的某个子进程退出。 </li><li>运行 kill 命令或调用 kill 函数。</li></ul><p>使用信号的两个主要目的是：</p><ul><li>让进程知道已经发生了一个特定的事情。 </li><li>强迫进程执行它自己代码中的信号处理程序。</li></ul><p>信号的特点： </p><ul><li>简单 </li><li>不能携带大量信息 </li><li>满足某个特定条件才发送 </li><li>优先级比较高</li></ul><p>查看系统定义的信号列表：kill –l</p><table><thead><tr><th align="center">信号编号</th><th align="center">信号名称</th><th align="center">对应事件</th><th align="center">默认动作</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">SIGINT</td><td align="center">当用户按下了组合键时，用户终端向正在运行中 的由该终端启动的程序发出此信号</td><td align="center">终止进程</td></tr><tr><td align="center">3</td><td align="center">SIGQUIT</td><td align="center">用户按下组合键时产生该信号，用户终端向正在运 行中的由该终端启动的程序发出些信号</td><td align="center">终止进程</td></tr><tr><td align="center">9</td><td align="center">SIGKILL</td><td align="center">无条件终止进程。该信号不能被忽略，处理和阻塞</td><td align="center">终止进程，可以杀死任何进程</td></tr><tr><td align="center">11</td><td align="center">SIGSEGV</td><td align="center">指示进程进行了无效内存访问(段错误)</td><td align="center">终止进程 并产生 core文件</td></tr><tr><td align="center">13</td><td align="center">SIGPIPE</td><td align="center">Broken pipe向一个没有读端的管道写数据</td><td align="center">终止进程</td></tr><tr><td align="center">17</td><td align="center">SIGCHLD</td><td align="center">子进程结束时，父进程会收到这个信号</td><td align="center">忽略这个信号</td></tr><tr><td align="center">18</td><td align="center">SIGCONT</td><td align="center">如果进程已停止，则使其继续运行</td><td align="center">继续&#x2F;忽略</td></tr><tr><td align="center">19</td><td align="center">SIGSTOP</td><td align="center">停止进程的执行。信号不能被忽略，处理和阻塞</td><td align="center">为终止进 程</td></tr></tbody></table><h5 id="信号的-5-种默认处理动作"><a href="#信号的-5-种默认处理动作" class="headerlink" title="信号的 5 种默认处理动作"></a><strong>信号的 5 种默认处理动作</strong></h5><p>查看信号的详细信息：man 7 signal </p><p>信号的 5 中默认处理动作 </p><ul><li>Term 终止进程 </li><li>Ign 当前进程忽略掉这个信号 </li><li>Core 终止进程，并生成一个Core文件 </li><li>Stop 暂停当前进程 </li><li>Cont 继续执行当前被暂停的进程</li></ul><p>信号的几种状态：产生、未决、递达 </p><p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p><p><strong>信号相关函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 给任何的进程或者进程组pid，发送任何信号</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- pid：</span><br><span class="hljs-comment">&gt; 0: 将信号发送给指定的进程</span><br><span class="hljs-comment">= 0：将信号发送给当前的进程组</span><br><span class="hljs-comment">= -1: 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="hljs-comment">&lt; -1: 这个pid=这个进程组的ID取反（-12345）</span><br><span class="hljs-comment">- sig: 需要发送的信号的编号或者宏值，0表示不发送任何信号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能: 给当前进程发送信号</span><br><span class="hljs-comment">- 参数：  </span><br><span class="hljs-comment">- sig: 要发送的信号</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">- 成功 0</span><br><span class="hljs-comment">- 失败 非0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：设置定时器，函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发发送一个信号SIGALARM</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">    seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，也不会发送信号），取消一个定时器，通过alarm(0)</span><br><span class="hljs-comment">    - 返回值： </span><br><span class="hljs-comment">    - 之前没有定时器，返回0</span><br><span class="hljs-comment">    - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">- SIGALARM: 默认终止当前的进程，每一个进程都有且只有唯一的一个定时器</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">该函数时不阻塞的</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_val, <span class="hljs-keyword">struct</span> itimerval *old_value)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;sys/time.h&gt;</span><br><span class="hljs-comment">- 功能： 设置定时器（闹钟），可以替代alerm函数。精度达到us，可以实现周期性的定时</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">    - which: 定时器以什么时间计时</span><br><span class="hljs-comment">    ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM  常用</span><br><span class="hljs-comment">    ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="hljs-comment">    ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROT</span><br><span class="hljs-comment">    - new_val: 设置定时器属性</span><br><span class="hljs-comment">             struct itimerval &#123;// 定时器结构体</span><br><span class="hljs-comment">                   struct timeval it_interval; // 间隔时间 </span><br><span class="hljs-comment">                   struct timeval it_value;    // 延长多长时间会执行定时器 </span><br><span class="hljs-comment">               &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">               struct timeval &#123;// 时间的结构体</span><br><span class="hljs-comment">                   time_t      tv_sec;         // 秒数 </span><br><span class="hljs-comment">                   suseconds_t tv_usec;        /* 微秒 </span><br><span class="hljs-comment">               &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">               过10秒后，每个2秒定时一次</span><br><span class="hljs-comment">        - old_value: 记录上一次的计时参数，一般不使用，指定NULL</span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">    成功 0</span><br><span class="hljs-comment">    失败 -1，并设置错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a><strong>信号捕捉函数</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction </span><br><span class="hljs-params">*oldact)</span>; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- signum: 需要捕捉的信号的编号或者宏值，推荐宏值</span><br><span class="hljs-comment">- act: 捕捉信号之后的处理动作</span><br><span class="hljs-comment">- oldset: 上一次对信号捕捉相关的设置，一般不适用，传递NULL</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">成功 0</span><br><span class="hljs-comment">失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction &#123;</span><br><span class="hljs-comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="hljs-comment">               void     (*sa_handler)(int);</span><br><span class="hljs-comment">             // 不常用</span><br><span class="hljs-comment">               void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="hljs-comment">             // 临时阻塞信号集，信号捕捉函数执行过程中，临时阻塞某些信号</span><br><span class="hljs-comment">               sigset_t   sa_mask;</span><br><span class="hljs-comment">             // 使用哪个信号处理对捕捉到的信号进行处理</span><br><span class="hljs-comment">                // 可以是0， 表示使用sa_handler, 等</span><br><span class="hljs-comment">               int        sa_flags;</span><br><span class="hljs-comment">               // 被废弃掉了</span><br><span class="hljs-comment">               void     (*sa_restorer)(void);</span><br><span class="hljs-comment">           &#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="阻塞信号和未决信号集"><a href="#阻塞信号和未决信号集" class="headerlink" title="阻塞信号和未决信号集"></a><strong>阻塞信号和未决信号集</strong></h5><p>阻塞信号集是可以修改的，未决信号集不能修改</p><ol><li>用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</li><li>信号产生但是没有被处理 （未决）<ul><li>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</li><li>SIGINT信号状态被存储在第二个标志位上<ul><li>这个标志位的值为0， 说明信号不是未决状态</li><li>这个标志位的值为1， 说明信号处于未决状态</li></ul></li></ul></li><li>.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<ul><li>阻塞信号集默认不阻塞任何的信号</li><li>如果想要阻塞某些信号需要用户调用系统的API</li></ul></li><li>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<ul><li>如果没有阻塞，这个信号就被处理</li><li>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="hljs-comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - how : 如何对内核阻塞信号集进行处理</span><br><span class="hljs-comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="hljs-comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="hljs-comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="hljs-comment">                    mask &amp;= ~set</span><br><span class="hljs-comment">                SIG_SETMASK:覆盖内核中原来的值</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            - set ：已经初始化好的用户自定义的信号集</span><br><span class="hljs-comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">                设置错误号：EFAULT、EINVAL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigpending(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：获取内核中的未决信号集</span><br><span class="hljs-comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span><br><span class="hljs-comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 设置2、3号信号阻塞</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    <span class="hljs-comment">// 将2号和3号信号添加到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 修改内核中的阻塞信号集</span><br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        num++;<br>        <span class="hljs-comment">// 获取当前的未决信号集的数据</span><br>        <span class="hljs-type">sigset_t</span> pendingset;<br>        sigemptyset(&amp;pendingset);<br>        sigpending(&amp;pendingset);<br><br>        <span class="hljs-comment">// 遍历前32位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                perror(<span class="hljs-string">&quot;sigismember&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 解除阻塞</span><br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、共享内存"><a href="#5、共享内存" class="headerlink" title="5、共享内存"></a>5、共享内存</h4><p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会 称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 </p><p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快</p><p><strong>使用步骤</strong></p><ul><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的 共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 </li><li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要 使用由 shmat()  </li><li>调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是 可选的，并且在进程终止时会自动完成这一步。 </li><li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销 毁。只有一个进程需要执行这一步。</li></ul><p><strong>相关函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的表示。</span><br><span class="hljs-comment">新创建的内存段中的数据都会被初始化为0</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- key:  ket_t类型是一个整形，通过这个找到或者创建一个共享内存</span><br><span class="hljs-comment">一般使用16进制表示，非0值</span><br><span class="hljs-comment">- size： 共享内存的大小</span><br><span class="hljs-comment">- shmflg: 属性</span><br><span class="hljs-comment">- 访问权限</span><br><span class="hljs-comment">- 附加属性： 创建/判断共享内存是不是存在</span><br><span class="hljs-comment">- 创建： IPC_CREAT</span><br><span class="hljs-comment">- 判断共享内存是否存在： IPC_EXCL, 需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">IPC_CREAT | IPC_EXCL | 0664</span><br><span class="hljs-comment">- 返回值： </span><br><span class="hljs-comment">- 失败 -1 并设置错误号</span><br><span class="hljs-comment">- 成功 &gt;0 返回共享的引用的ID, 后面操作共享内存都是通过这个值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 和当前的进程进行关联</span><br><span class="hljs-comment">- 参数： </span><br><span class="hljs-comment">- shmid： 共享内存的表示（ID）,由shmget返回值获取</span><br><span class="hljs-comment">- shmaddr： 申请的共享内存的起始地址，指定NULL，由内核指定</span><br><span class="hljs-comment">- shmflg： 共享内存的操作</span><br><span class="hljs-comment">- 读： SHM_RDONLY, 必须要有读权限</span><br><span class="hljs-comment">- 读写： 0</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">- 成功 返回共享内存的起始地址/首地址</span><br><span class="hljs-comment">- 失败 (void *) -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 接触当前进程和共享内存的关联</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">shmaddr： 共享内存的首地址</span><br><span class="hljs-comment">- 返回值： 成功 0 失败 -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁了对共享内存没有任何影响</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- shmid： 共享内存的ID</span><br><span class="hljs-comment">- cmd： 要做的操作</span><br><span class="hljs-comment">- IPC_STAT : 获取共享内存当前的状态</span><br><span class="hljs-comment">- IPC_SET: 设置共享内存的状态</span><br><span class="hljs-comment">- IPC_RMID: 标记共享内存被销毁</span><br><span class="hljs-comment">- buf: 需要设置或者获取的共享内存的属性信息</span><br><span class="hljs-comment">- IPC_STAT: buf存储数据</span><br><span class="hljs-comment">- IPC_SET: buf中需要初始化数据，设置到内核中</span><br><span class="hljs-comment">- IPC_RMID: 没有用，NULL</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 根据指定的路径名，和int值，生成一个共享的key</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- pathname: 指定一个存在的路径</span><br><span class="hljs-comment">- proj_id: int 类型的值，但是这系统调用指挥使用其中的1个字节</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>问题</strong></p><ol><li>问题1：操作系统如何知道一块共享内存被多少个进程关联？<ul><li>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</li><li>shm_nattach 记录了关联的进程个数</li></ul></li><li>问题2：可不可以对共享内存进行多次删除 shmctl<ul><li>可以的</li><li>因为shmctl 标记删除共享内存，不是直接删除</li><li>什么时候真正删除呢?<ul><li>当和共享内存关联的进程数为0的时候，就真正被删除</li></ul></li><li>当共享内存的key为0的时候，表示共享内存被标记删除了<ul><li>如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</li></ul></li></ul></li></ol><p><strong>共享内存和内存映射的区别</strong></p><ol><li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li><li>共享内存效率更高</li><li>内存<ul><li>所有的进程操作的是同一块共享内存。</li><li>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li></ul></li><li>数据安全<ul><li>进程突然退出<ul><li>共享内存还存在</li><li>内存映射区消失</li></ul></li><li>运行进程的电脑死机，宕机了<ul><li>数据存在在共享内存中，没有了</li><li>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li></ul></li></ul></li><li>生命周期<ul><li>内存映射区：进程退出，内存映射区销毁</li><li>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机<ul><li>如果一个进程退出，会自动和共享内存进行取消关联。</li></ul></li></ul></li></ol><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>守护进程具备下列特征： </p><ul><li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 </li><li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li></ul><p>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd， Web 服务器 httpd 等。</p><p>执行一个 fork()，之后父进程退出，子进程继续执行。 </p><p>子进程调用 setsid() 开启一个新会话。 </p><p>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 </p><p>修改进程的当前工作目录，通常会改为根目录（&#x2F;）。 </p><p>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 </p><p>在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2()  使所有这些描述符指向这个设备。 </p><h3 id="线程（重点）"><a href="#线程（重点）" class="headerlink" title="线程（重点）"></a>线程（重点）</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可 以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中 包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一 个特例，该进程只包含一个线程） </p><p>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 </p><p>线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP 号：ps –Lf pid</p><h5 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><p>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通 信方式，在进程间进行信息交换。 </p><p>调用 fork() 来创建进程的代价相对较高，即便利用<strong>写时复制技术</strong>，仍然需要复制诸如内存页表和文件描 述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 </p><p>线程之间能够<strong>方便、快速地共享信息</strong>。只需将数据复制到共享（全局或堆）变量中即可。 </p><p>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复 制内存，也无需复制页表。</p><h5 id="线程之间共享和非共享的资源"><a href="#线程之间共享和非共享的资源" class="headerlink" title="线程之间共享和非共享的资源"></a>线程之间共享和非共享的资源</h5><img src="/2024/06/02/MyWebServer/linux%E5%86%85%E6%A0%B8.png" class=""><p>共享资源 </p><ul><li>进程 ID 和父进程 ID </li><li>进程组 ID 和会话 ID </li><li>用户 ID 和 用户组 ID </li><li>文件描述符表 </li><li>信号处置 </li><li>文件系统的相关信息：文件权限掩码（umask）、当前工作目录 </li><li>虚拟地址空间（除栈、.text） ，每个线程都占据总共的一部分资源。</li></ul><p>非共享资源 </p><ul><li>线程 ID </li><li>信号掩码 </li><li>线程特有数据 </li><li>error 变量 </li><li>实时调度策略和优先级 </li><li>n栈，本地变量和函数的调用链接信息</li></ul><h4 id="2、线程操作函数"><a href="#2、线程操作函数" class="headerlink" title="2、线程操作函数"></a>2、线程操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span> *</span><br><span class="hljs-params"> (*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">pthread_t</span> <span class="hljs-title function_">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_equal</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create()"></a><strong>pthread_create()</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一般情况下，main函数所在的线程我们称之为主线程（main线程），其余创建的线程称之为子线程</span><br><span class="hljs-comment">    程序中默认只有一个进程，fork()函数调用，2个进程</span><br><span class="hljs-comment">    程序中默认只有一个线程，pthread_create()函数调用，2个线程</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *</span><br><span class="hljs-comment">    (*start_routine) (void *), void *arg);</span><br><span class="hljs-comment">        - 功能： 创建一个子线程</span><br><span class="hljs-comment">        - 参数： </span><br><span class="hljs-comment">            - thread: 传出参数，线程创建成功后，子线程的线程ID被写到该变量中</span><br><span class="hljs-comment">            - attr: 设置线程的属性，一般使用默认值，NULL</span><br><span class="hljs-comment">            - start_routine: 函数指针，这个函数是子线程需要处理的逻辑代码</span><br><span class="hljs-comment">            - arg： 给第三个参数使用，传参</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 返回错误号，这个错误号和之前的error不太一样</span><br><span class="hljs-comment">            获取错误号的信息，   char * strerror(int errnum);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread... \n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arg value: %d\n&quot;</span>, * (<span class="hljs-type">int</span> *) arg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, (<span class="hljs-type">void</span> *) &amp;num);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i:%d\n&quot;</span>, i);<br>    &#125;<br>    sleep(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-equal-和-pthread-exit"><a href="#pthread-equal-和-pthread-exit" class="headerlink" title="pthread_equal 和 pthread_exit"></a><strong>pthread_equal 和 pthread_exit</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    void pthread_exit(void *retval);</span><br><span class="hljs-comment">        - 功能：终止一个线程，在那个线程中调用，就表示终止那个线程</span><br><span class="hljs-comment">        - 参数： </span><br><span class="hljs-comment">            - retval: 需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    pthread_t pthread_self(void);</span><br><span class="hljs-comment">        - 功能：获取到当前线程的线程ID</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_equal(pthread_t t1, pthread_t t2)</span><br><span class="hljs-comment">        -功能: 比较两个线程的ID是否相等</span><br><span class="hljs-comment">        不同的操作系统，pthread_t类型的实现不一定相等，有些是int。有些是结构体</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id:%ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>  <span class="hljs-comment">// pthread_exit(NULL);</span><br>&#125;<br><br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());<br>    <span class="hljs-comment">// 让主线成主动退出，当主线程主动退出了，不影响其他线程的执行</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a><strong>pthread_join()</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    int pthread_join(pthread_t thread, void **retval);</span><br><span class="hljs-comment">        - 功能： 和一个已经终止的线程进行连接</span><br><span class="hljs-comment">            回收子线程的资源</span><br><span class="hljs-comment">            这个函数是阻塞函数，调用一次只能回收一个子线程</span><br><span class="hljs-comment">            一般在主线程中使用</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - thread: 需要回收的子线程ID,</span><br><span class="hljs-comment">            - retval: 接受子线程退出的返回值</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 返回错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id:%ld\n&quot;</span>, pthread_self());<br>   <br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>    pthread_exit((<span class="hljs-type">void</span> *) &amp;value);  <span class="hljs-comment">// return (void *) &amp;value;一样</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());<br>    <br>    <span class="hljs-comment">// 主线程调用pthread_join()回收子线程的资源</span><br>    <span class="hljs-type">int</span> * thread_retval;<br>    ret = pthread_join(tid, (<span class="hljs-type">void</span> *)&amp;thread_retval);<br>    <br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit data : %d\n&quot;</span>, *thread_retval);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程资源释放成功\n&quot;</span>);<br><br>    <span class="hljs-comment">// 让主线成主动退出，当主线程主动退出了，不影响其他线程的执行</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    int pthread_detach(pthread_t thread);</span><br><span class="hljs-comment">        - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统</span><br><span class="hljs-comment">            1.不能多次分离，会产生不可预料的行为</span><br><span class="hljs-comment">            2.不能去连接一个已经分离的线程，会报错</span><br><span class="hljs-comment">        - 参数：需要分离的线程的ID</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：返回错误号</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 设置子线程分离，子线程分离后，子线程结束时对应的资源就不需要主线程释放了</span><br>    ret = pthread_detach(tid);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error2: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// // 设置分离后，不能对分离的子线程进行连接，pthread_join();  </span><br>    <span class="hljs-comment">// ret = pthread_join(tid, NULL);</span><br>    <span class="hljs-comment">// if(ret != 0)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     char * errstr = strerror(ret);</span><br>    <span class="hljs-comment">//     printf(&quot;error3: %s\n&quot;, errstr);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    phread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    int pthread_cancel(pthread_t thread);</span><br><span class="hljs-comment">        - 功能：取消线程（让线程终止）  杀毒软件可以让一些程序停止</span><br><span class="hljs-comment">            取消某个线程可以终止某个线程的运行，</span><br><span class="hljs-comment">            但是不是立刻终止，而是当子线程执行到一个取消点，线程才会终止。</span><br><span class="hljs-comment">            取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户到内核去的切换，这个位置称之为取消点</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - thread</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child i : %d\n&quot;</span>, i);<br> <br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// 取消线程</span><br>    pthread_cancel(tid);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());<br><br>    phread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程属性相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">线程属性类型 <span class="hljs-type">pthread_attr_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span>;<span class="hljs-comment">// 初始化线程属性变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span>;<span class="hljs-comment">// 销毁线程属性变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getdetachstate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> *detachstate)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：获取线程分离的状态属性</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- detachstate：</span><br><span class="hljs-comment">        PTHREAD_CREATE_DETACHED表示设置了线程分离</span><br><span class="hljs-comment">        PTHREAD_CREATE_JOINABLE</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> detachstate)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：设置线程分离的状态属性</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="3、线程同步（重点）"><a href="#3、线程同步（重点）" class="headerlink" title="3、线程同步（重点）"></a>3、线程同步（重点）</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多 个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 </p><p>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共 享资源的其他线程不应终端该片段的执行。 </p><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该 线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</p><h5 id="卖票程序"><a href="#卖票程序" class="headerlink" title="卖票程序"></a>卖票程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用多线程实现卖票的案例</span><br><span class="hljs-comment">    有3个窗口，一共是100张票</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(tickets &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>        tickets--;<span class="hljs-comment">// 临界数据</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 创建三个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2, tid3;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 回收子线程的资源, 阻塞</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 设置线程分离，好处，自动回收资源，不需要主线程去回收</span><br>    <span class="hljs-comment">// pthread_detach(tid1);</span><br>    <span class="hljs-comment">// pthread_detach(tid2);</span><br>    <span class="hljs-comment">// pthread_detach(tid3);</span><br><br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>表示出线程同步的问题，多个线程并发同时执行的代码，产生数据安全问题。</p><h5 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h5><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同 时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</p><p> 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。</p><p>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每 一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议</p><ul><li>针对共享资源锁定互斥量 </li><li>访问共享资源 </li><li>对互斥量解锁</li></ul><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示：</p><img src="/2024/06/02/MyWebServer/%E4%BA%92%E6%96%A5%E9%87%8F.png" class=""><p><strong>互斥量相关操作函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> 互斥量的类型 <span class="hljs-type">pthread_mutex_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> </span><br><span class="hljs-params"><span class="hljs-type">pthread_mutexattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    互斥量的类型 pthread_mutex_t</span><br><span class="hljs-comment">    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);// 初始化</span><br><span class="hljs-comment">        - 功能： 初始化互斥量</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - mutex: 需要初始化的互斥量变量</span><br><span class="hljs-comment">            - attr: 互斥量相关的属性，NULL</span><br><span class="hljs-comment">        - restrict: C语言的修饰符，被修饰的指针，不能由另外一个指针进行操作。</span><br><span class="hljs-comment">            pthread_mutex_t * restrict muutex = xxx;</span><br><span class="hljs-comment">            pthread_mutex_t * restrict mutex1 = mutex 会报错 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_mutex_destroy(pthread_mutex_t *mutex);   // 销毁</span><br><span class="hljs-comment">        - 功能： 释放互斥量的资源</span><br><span class="hljs-comment">    int pthread_mutex_lock(pthread_mutex_t *mutex);// 上锁</span><br><span class="hljs-comment">        - 功能： 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_mutex_trylock(pthread_mutex_t *mutex);// </span><br><span class="hljs-comment">        - 功能： 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="hljs-comment">        - 功能： 解锁</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用多线程实现卖票的案例</span><br><span class="hljs-comment">    有3个窗口，一共是100张票</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 加锁         在临界区之前加上锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(tickets &gt; <span class="hljs-number">0</span>)<br>        &#123;   <br>            usleep(<span class="hljs-number">60000</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>            tickets--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;   <br>            <span class="hljs-comment">// 解锁</span><br>            pthread_mutex_unlock(&amp;mutex);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建三个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2, tid3;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 回收子线程的资源, 阻塞</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br>    pthread_mutex_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="死锁（重点）"><a href="#死锁（重点）" class="headerlink" title="死锁（重点）"></a>死锁（重点）</h5><p>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。</p><p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用， 它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p><p>死锁的几种场景：</p><ul><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占资源</li></ul><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形， 当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想<strong>读取</strong>这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就<strong>无法读访问共享资源</strong>了，但是实际上多个线程同时<strong>读</strong>访问共享资源并不会导致问题。</p><p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够<strong>允许多个读出，但只允许一个写入的需求</strong>，线程提供了读写锁来实现。</p><p>读写锁特点：</p><ul><li>如果有其他线程读数据，则允许其它线程执行读操作，但不允许写操作</li><li>如果有其他线程写数据，则其他线程都不允许读、写操作</li><li>写是独占的，写的优先级高    (写锁先加，有写锁，则读锁阻塞，等待写锁完成)</li></ul><p><strong>读写锁相关函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">读写锁的类型 <span class="hljs-type">pthread_rwlock_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_init</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *<span class="hljs-keyword">restrict</span> rwlock, <span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_rdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_tryrdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_wrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_trywrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    读写锁的类型 pthread_rwlock_t</span><br><span class="hljs-comment">    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</span><br><span class="hljs-comment">    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    案列：8个线程操作同一个全局变量</span><br><span class="hljs-comment">    3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _XOPEN_SOURCE 500  </span><br><br><span class="hljs-comment">// 创建一个共享数据</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 创建读写锁</span><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">writeNum</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_rwlock_wrlock(&amp;rwlock);<br>        num++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++write, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">readNum</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_rwlock_rdlock(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;===read, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建三个读线程、五个写线程</span><br>    <span class="hljs-type">pthread_t</span> wtids[<span class="hljs-number">3</span>], rtids[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)      pthread_create(&amp;wtids[i], <span class="hljs-literal">NULL</span>, writeNum, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)      pthread_create(&amp;rtids[i], <span class="hljs-literal">NULL</span>, readNum, <span class="hljs-literal">NULL</span>);<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)      pthread_detach(wtids[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)      pthread_detach(rtids[i]);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    pthread_rwlock_destory(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>pthread_rwlock_t 未定义的问题:</strong></p><p>最近在linux上次编译时出现pthread_rwlock_t没有定义的现象.但是已经include了pthread.h,网上查了一些资料后发现,原因竟然是因为显示使用了-std&#x3D;c99参数导致.</p><p> 在c99没有完全实现时,如果不显示指定-std, 则gcc默认使用gnu89(或gnu90)标准.</p><p>一般而言,</p><p>​        gnuXX标准 &#x3D; cXX标准 + GNU extension</p><p> 而pthread_rwlock_t正好就是GNU extension的一部分. 所以指定使用c99就会把GNU extension禁用,造成pthread_rwlock_t未定义的问题.</p><h5 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h5><img src="/2024/06/02/MyWebServer/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png" class=""><p>生产者和消费者模型中的对象</p><ol><li>生产者</li><li>消费者</li><li>容器</li></ol><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>配合互斥量去使用，实现线程同步</p><p>条件变量（<code>cond</code>）是多线程编程中一种重要的同步机制，用于让线程等待某个特定的条件满足，然后继续执行。它通常与互斥锁（<code>mutex</code>）结合使用，以确保线程在访问共享资源时能够正确地同步。条件变量的主要作用是协调线程之间的执行顺序，使得线程在等待某些条件时能够有效地阻塞，直到条件满足后被唤醒。</p><p><strong>条件变量的作用</strong></p><ol><li><strong>线程等待某个条件</strong>:<ul><li>条件变量允许一个线程等待某个条件（如队列不为空，或某个标志变量被设置）。在条件满足之前，该线程会被阻塞，而不会消耗 CPU 资源。</li><li>当其他线程改变了与该条件相关的状态（例如向队列中添加了一个新元素），它们可以通知等待的线程，使其继续执行。</li></ul></li><li><strong>避免忙等待</strong>:<ul><li>条件变量可以防止线程通过忙等待（不断检查某个条件是否满足）来浪费 CPU 资源。相反，线程可以高效地等待条件满足时被唤醒。</li><li>这种机制通过让线程进入休眠状态直到被唤醒，显著提高了程序的性能和资源利用率。</li></ul></li><li><strong>与互斥锁结合使用</strong>:<ul><li>条件变量通常与互斥锁一起使用，以确保对共享资源的安全访问。</li><li>线程在等待条件变量时，通常会先锁定一个互斥锁，进入等待状态时释放互斥锁，以便其他线程可以修改条件。当条件满足并唤醒等待线程时，线程会重新锁定互斥锁以检查条件并执行相应操作。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">条件变量的类型 <span class="hljs-type">pthread_cond_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<span class="hljs-comment">// 初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<span class="hljs-comment">// 释放资源</span><br><span class="hljs-comment">//  等待唤醒，调用了该函数，线程会阻塞</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex)</span>;<br><span class="hljs-comment">// 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *<span class="hljs-keyword">restrict</span> abstime)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<span class="hljs-comment">// 唤醒一个或部分等待的线程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<span class="hljs-comment">// 唤醒全部等待的线程</span><br></code></pre></td></tr></table></figure><p><strong>代码示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    生产者消费者模型(粗略版本)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-comment">// 创建条件变量</span><br><span class="hljs-type">pthread_cond_t</span> cond;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 头节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器里面添加内容， 不断创建新的节点，添加到链表中</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());<br><br>        <span class="hljs-comment">// 只要生产一个，就通知消费者消费</span><br>        pthread_cond_signal(&amp;cond);<br><br>        pthread_mutex_unlock(&amp;mutex);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器中去除内容</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">tmp</span> =</span> head;<br>            head = head-&gt;next;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());<br>            <span class="hljs-built_in">free</span>(tmp);<br>            pthread_mutex_unlock(&amp;mutex);<br>            usleep(<span class="hljs-number">1000</span>); <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 没有数据，需要等待</span><br>            <span class="hljs-comment">// 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞时，会重新加锁</span><br>            pthread_cond_wait(&amp;cond, &amp;mutex);       <br>            pthread_mutex_unlock(&amp;mutex);<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    pthread_cond_init(&amp;cond, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建5个生产者线程和5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptids[<span class="hljs-number">5</span>], ctids[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ptids[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ctids[i], <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ptids[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ctids[i]);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    pthread_mutex_destroy(&amp;mutex);<br>    pthread_cond_destroy(&amp;cond);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>通过信号量里面的值，使线程阻塞的，比如5个等都灭了，那就不能接受新的线程了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">信号量的类型 <span class="hljs-type">sem_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<span class="hljs-comment">// value 多少个灯</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_timedwait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_getvalue</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> *sval)</span>;<br></code></pre></td></tr></table></figure><p>代码示例：信号量实现生产者和消费者模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    信号量的类型 sem_t</span><br><span class="hljs-comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);// value 多少个灯</span><br><span class="hljs-comment">        - 功能： 初始化信号量</span><br><span class="hljs-comment">        - 参数： </span><br><span class="hljs-comment">            - sem:  信号量变量的地址</span><br><span class="hljs-comment">            - pshared:  0 用在线程间 非0 用在进程间  </span><br><span class="hljs-comment">            - value:  信号量中的值</span><br><span class="hljs-comment">        - 返回值</span><br><span class="hljs-comment">        - 0 成功</span><br><span class="hljs-comment">        - -1 失败</span><br><span class="hljs-comment">    int sem_destroy(sem_t *sem);</span><br><span class="hljs-comment">        - 功能： 释放资源</span><br><span class="hljs-comment">    int sem_wait(sem_t *sem);</span><br><span class="hljs-comment">        - 功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span><br><span class="hljs-comment">    int sem_trywait(sem_t *sem);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="hljs-comment">    int sem_post(sem_t *sem);</span><br><span class="hljs-comment">        - 功能：对信号量解锁，调用一次对信号量的值+1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">    sem_t psem;</span><br><span class="hljs-comment">    sem_t csem;</span><br><span class="hljs-comment">    init(psem, 0, 8);</span><br><span class="hljs-comment">    init(csem, 0, 0);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    producer()</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;psem);</span><br><span class="hljs-comment">        sem_post(&amp;csem);    </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    customer()</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;csem);</span><br><span class="hljs-comment">        sem_post(&amp;psem)</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    生产者消费者模型(粗略版本)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-comment">// 创建两个信号量</span><br><span class="hljs-type">sem_t</span> psem, csem;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 头节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器里面添加内容， 不断创建新的节点，添加到链表中</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        sem_wait(&amp;psem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());<br><br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;csem);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器中去除内容</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        sem_wait(&amp;csem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">tmp</span> =</span> head;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());<br>        <span class="hljs-built_in">free</span>(tmp);<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;psem);<br>        usleep(<span class="hljs-number">1000</span>); <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    sem_init(&amp;psem, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>    sem_init(&amp;csem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 创建5个生产者线程和5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptids[<span class="hljs-number">5</span>], ctids[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ptids[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ctids[i], <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ptids[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ctids[i]);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    sem_destroy(&amp;csem);<br>    sem_destroy(&amp;psem);<br>    pthread_mutex_destroy(&amp;mutex);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络编程（八股）"><a href="#网络编程（八股）" class="headerlink" title="网络编程（八股）"></a>网络编程（八股）</h3><h4 id="1、网络结构模式"><a href="#1、网络结构模式" class="headerlink" title="1、网络结构模式"></a>1、网络结构模式</h4><h5 id="C-S结构"><a href="#C-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h5><p><strong>简介</strong></p><p>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。C&#x2F;S 结构通常采取两层结构。<strong>服务器负责数据的管理，客户机负责完成与用户的交互任务</strong>。客户机是因特网上访问别人信息的机器，服务器则是提供信息供人访问的计算机。 </p><p>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行 操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用 户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务器，这就对服务器的硬件处理数据能力提出了很高的要求。 </p><p>在C&#x2F;S结构中，应用程序分为两部分：<strong>服务器部分和客户机部分</strong>。服务器部分是多个用户共享的信 息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</p><p><strong>优点</strong></p><ol><li>能充分发挥客户端 PC 的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 C&#x2F;S 结构客户端响应速度快； </li><li>操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求； </li><li>C&#x2F;S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程；</li><li>安全性较高，C&#x2F;S 一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强，一般高度机密的信息系统采用 C&#x2F;S 结构适宜。</li></ol><p><strong>缺点</strong></p><ol><li>客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病 毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高；</li><li>对客户端的操作系统一般也会有限制，不能够跨平台。</li></ol><h5 id="B-S结构"><a href="#B-S结构" class="headerlink" title="B&#x2F;S结构"></a>B&#x2F;S结构</h5><p><strong>简介</strong></p><p>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），是 WEB 兴起后的一种网络结构模式，WEB  浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服 务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 Internet  Explorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据 库进行数据交互。</p><p><strong>优点</strong></p><p>B&#x2F;S 架构最大的优点是总体拥有<strong>成本低、维护方便、 分布性强、开发简单</strong>，可以<strong>不用安装任何专门的软件</strong>就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</p><p><strong>缺点</strong></p><ol><li>通信开销大、系统和数据的安全性较难保障; </li><li>个性特点明显降低，无法实现具有个性化的功能要求； </li><li>协议一般是固定的：http&#x2F;https </li><li>客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低。</li></ol><h4 id="2、MAC地址"><a href="#2、MAC地址" class="headerlink" title="2、MAC地址"></a>2、MAC地址</h4><p>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网 络接口卡NIC。其拥有 MAC 地址，<strong>属于 OSI 模型的第 2 层</strong>，它使得用户可以通过电缆或无线相互连接。</p><p>每一个网卡都有一个被称为 MAC 地址的独一无二的 <strong>48 位串行号</strong>。</p><p><strong>网卡的主要功能：</strong></p><ol><li>数据的封装与解封装、</li><li>链路管理、</li><li>数据编码与译码。</li></ol><p>MAC地址（Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址、 以太网地址、物理地址或硬件地址，它是一个用来确认网络设备位置的位址，由网络设备制造商生产时烧录在网卡中。<strong>在 OSI 模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 。</strong>MAC 地址用于在网络中唯一标识一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。</p><p>MAC 地址的长度为 48 位（6个字节），通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就 是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由  IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。 形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性</p><h4 id="3、IP地址"><a href="#3、IP地址" class="headerlink" title="3、IP地址"></a>3、IP地址</h4><p><strong>简介</strong></p><p><strong>IP 协议是为计算机网络相互连接进行通信而设计的协议</strong>。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守 IP 协议就可以与因特网互连互通。各个厂家生产的网络系统和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议软件，它把各种不同“帧”<strong>统一转换成“IP 数据报”格式</strong>，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“因特网 协议”。</p><p><strong>IP 地址（Internet Protocol Address）是指互联网协议地址</strong>，又译为网际协议地址。IP 地址是 IP  协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>IP 地址是一个 <strong>32 位</strong>的<strong>二进制</strong>数，通常被分割为 4 个“ 8 位二进制数”（也就是 4 个字节）。IP 地址 通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。 例：点分十进IP地址（100.4.5.6），实际上是 32 位二进制数 （01100100.00000100.00000101.00000110）。</p><p><strong>IP地址编址方式</strong></p><p>最初设计互联网络时，为了便于寻址以及层次化构造网络，每个 IP 地址包括两个标识码（ID），即网络  ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工 作站，服务器和路由器等）有一个主机 ID 与其对应。Internet 委员会定义了 5 种 IP 地址类型以适合不 同容量的网络，即 A 类~ E 类。 其中 A、B、C 3类（如下表格）由 InternetNIC 在全球范围内统一分配，D、E 类为特殊地址。</p><img src="/2024/06/02/MyWebServer/IP%E5%9C%B0%E5%9D%80%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" class=""><p><strong>D类IP地址</strong></p><p>D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命 名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从 224.0.0.0 - 239.255.255.255。</p><p><strong>特殊的网址</strong></p><p>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机； IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址； IP 地址中凡是以 “11110”  开头的 E 类 IP 地址都保留用于将来和实验使用。 IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测 试，如：127.0.0.1可以代表本机IP地址。</p><p><strong>子网掩码</strong></p><p>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地 址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存 在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和 主机地址两部分。 子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP  地址是在局域网上，还是在广域网上</p><h4 id="4、端口"><a href="#4、端口" class="headerlink" title="4、端口"></a>4、端口</h4><p><strong>简介</strong></p><p>“端口” 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP&#x2F;IP协议中的端口，是逻辑意义上的端口。例如计算机中的80 端口、21 端口、23 端口等。物理端口又称为接口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插 口也属于物理端口的范畴。 </p><p>如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP  地址的端口可以有 65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数， 范围是从 0  到65535（2^16-1）。</p><p><strong>端口类型</strong></p><ol><li><p>周知端口</p><p>周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，<strong>范围从 0 到 1023</strong>，它们紧密 绑定于一些特定的服务。例如 <strong>80 端口分配给 WWW 服务</strong>，<strong>21 端口分配给 FTP 服务</strong>，23 端口分配给  Telnet服务等等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下  WWW 服务的端口是 “80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏 上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口号。比如使用 “8080” 作为 WWW  服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改 变的，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信，不能手动改变。</p></li><li><p>注册端口</p><p><strong>端口号从 1024 到 49151</strong>，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是 用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。</p></li><li><p>动态端口&#x2F;私有端口</p><p><strong>动态端口的范围是从 49152 到 65535</strong>。之所以称为动态端口，是因为它一般不固定分配某种服务，而是 动态分配。</p></li></ol><h4 id="5、网络模型"><a href="#5、网络模型" class="headerlink" title="5、网络模型"></a>5、网络模型</h4><h5 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h5><p>七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参 考模型或七层模型</p><p>它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。</p><img src="/2024/06/02/MyWebServer/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class=""><h5 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h5><p>现在 Internet（因特网）使用的主流协议族是 TCP&#x2F;IP 协议族，它是一个分层、多协议的通信体 系。TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用 层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p><img src="/2024/06/02/MyWebServer/TCP_IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class=""><h4 id="6、协议"><a href="#6、协议" class="headerlink" title="6、协议"></a>6、协议</h4><p><strong>简介</strong></p><p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连 接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语 法、语义、时序。 </p><p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议 （protocol），它最终体现为在网络上传输的数据包的格式。 </p><p>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。</p><p><strong>常见协议</strong></p><p><strong>应用层</strong>常见的协议有：FTP协议（File Transfer Protocol 文件传输协议）、HTTP协议（Hyper Text  Transfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。 </p><p><strong>传输层</strong>常见协议有：TCP协议（Transmission Control Protocol 传输控制协议）、UDP协议（User  Datagram Protocol 用户数据报协议）。</p><p><strong>网络层</strong>常见协议有：IP 协议（Internet Protocol 因特网互联协议）、ICMP 协议（Internet Control  Message Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特 网组管理协议）。 </p><p><strong>网络接口层</strong>常见协议有：ARP协议（Address Resolution Protocol 地址解析协议）、RARP协议 （Reverse Address Resolution Protocol 反向地址解析协议）。</p><p><strong>UDP协议</strong></p><img src="/2024/06/02/MyWebServer/UDP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>源端口号：发送方端口号 </li><li>目的端口号：接收方端口号 </li><li>长度：UDP用户数据报的长度，<strong>最小值是8</strong>（仅有首部） </li><li>校验和：检测UDP用户数据报在传输中是否有错，有错就丢弃</li></ol><p><strong>TCP协议</strong></p><img src="/2024/06/02/MyWebServer/TCP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>源端口号：发送方端口号 </li><li>目的端口号：接收方端口号 </li><li>序列号：本报文段的数据的第一个字节的序号 </li><li>确认序号：期望收到对方下一个报文段的第一个数据字节的序号 </li><li>首部长度（数据偏移）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长 度。单位：32位，即以 4 字节为计算单位 </li><li>保留：占 6 位，保留为今后使用，目前应置为 0 </li><li>紧急 URG ：此位置 1 ，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送 </li><li>确认 ACK：仅当 ACK&#x3D;1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须 把 ACK 置1 </li><li>推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立 即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方  TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH &#x3D; 1 的报文段，就尽快地 （即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付 </li><li>复位 RST：用于复位相应的 TCP 连接 </li><li>同步 SYN：仅在三次握手建立 TCP 连接时有效。当 SYN &#x3D; 1 而 ACK &#x3D; 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN &#x3D; 1 和 ACK &#x3D; 1。因此，SYN 置  1 就表示这是一个连接请求或连接接受报文</li><li>终止 FIN：用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要 求释放运输连接 </li><li>窗口：指发送本报文段的一方的接收窗口（而不是自己的发送窗口） </li><li>校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头 部 </li><li>紧急指针：仅在 URG &#x3D; 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就 是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据</li><li>选项：长度可变，最长可达 40 字节，当没有使用选项时，TCP 首部长度是 20 字节</li></ol><p><strong>IP协议</strong></p><img src="/2024/06/02/MyWebServer/IP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>版本：IP 协议的版本。通信双方使用过的 IP 协议的版本必须一致，目前最广泛使用的 IP 协议版本 号为 4（即IPv4) </li><li>首部长度：单位是 32 位（4 字节） </li><li>服务类型：一般不适用，取值为 0 </li><li>总长度：指首部加上数据的总长度，单位为字节 </li><li>标识（identification）：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1， 并将此值赋给标识字段 </li><li>标志（flag）：目前只有两位有意义。 标志字段中的最低位记为 MF。MF &#x3D; 1 即表示后面“还有分片”的数据报。MF &#x3D; 0 表示这已是若干数据报片中的最后一个。 标志字段中间的一位记为 DF，意思是“不能分片”，只有当 DF &#x3D; 0 时才允许分片 </li><li>片偏移：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以 8 字节为偏移单位。 </li><li>生存时间：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个 字段。路由器在转发数据之前就把 TTL 值减一，当 TTL 值减为零时，就丢弃这个数据报。 </li><li>协议：指出此数据报携带的数据时使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程，常用的 ICMP(1)，IGMP(2)，TCP(6)，UDP(17)，IPv6（41） </li><li>首部校验和：只校验数据报的首部，不包括数据部分。 </li><li>源地址：发送方 IP 地址 </li><li>目的地址：接收方 IP 地址</li></ol><p><strong>以太网帧协议</strong></p><img src="/2024/06/02/MyWebServer/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%8D%8F%E8%AE%AE.png" class=""><p>类型：0x800表示 IP、0x806表示 ARP、0x835表示 RARP</p><p><strong>ARP协议</strong></p><img src="/2024/06/02/MyWebServer/ARP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>硬件类型：1 表示 MAC 地址 </li><li>协议类型：0x800 表示 IP 地址 </li><li>硬件地址长度：6 </li><li>协议地址长度：4 </li><li>操作：1 表示 ARP 请求，2 表示 ARP 应答，3 表示 RARP 请求，4 表示 RARP 应答</li></ol><p><strong>封装</strong></p><p>上层协议是如何使用下层协议提供的服务的呢？其实这是通过<strong>封装（encapsulation）实现</strong>的。应用<strong>程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递</strong>。每层协议都将<strong>在上层数据的基础上加上自己的头部信息</strong>（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p><img src="/2024/06/02/MyWebServer/%E5%B0%81%E8%A3%85.png" class=""><p><strong>分用</strong></p><p>当帧到达目的主机时，将沿着协议栈<strong>自底向上依次传递</strong>。各层协议依次处理帧中本层负责的头部数据， 以获取所需的信息，并最终<strong>将处理后的帧交给目标应用程序</strong>。这个过程称为分用（demultiplexing）。 </p><p>分用是依靠头部信息中的类型字段实现的。</p><img src="/2024/06/02/MyWebServer/%E5%88%86%E7%94%A8.png" class=""><h4 id="7、网络通信过程"><a href="#7、网络通信过程" class="headerlink" title="7、网络通信过程"></a>7、网络通信过程</h4><h5 id="数据包封装-解封装"><a href="#数据包封装-解封装" class="headerlink" title="数据包封装-解封装"></a>数据包封装-解封装</h5><img src="/2024/06/02/MyWebServer/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" class=""><h5 id="arp工作流程"><a href="#arp工作流程" class="headerlink" title="arp工作流程"></a>arp工作流程</h5><img src="/2024/06/02/MyWebServer/arp%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class=""><h4 id="8、socket介绍"><a href="#8、socket介绍" class="headerlink" title="8、socket介绍"></a>8、socket介绍</h4><p>所谓 socket（套接字），就是对网络中不同主机上的<strong>应用进程之间</strong>进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的</strong>，提供向应用层进程传送数据包的机制。</p><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示<strong>进程间网络通信</strong>的特殊文件类型。本质为 内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用<strong>文件描述符引用套接字</strong>。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是<strong>管道主要应用于本地进程间通信</strong>，<strong>而套接字多应用于网络进程间数据的传递</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 套接字通信分两部分：</span><br>- 服务器端：被动接受连接，一般不会主动发起连接<br>- 客户端：主动向服务器发起连接<br>    <br>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。<br></code></pre></td></tr></table></figure><h4 id="9、字节序"><a href="#9、字节序" class="headerlink" title="9、字节序"></a>9、字节序</h4><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 <strong>4  字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题</strong>。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。</p><p><span style="color: red; font-weight: bold;">字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数 据当然就无需谈顺序的问题了。</span></p><p>字节序分为<strong>大端字节序</strong>（Big-Endian） 和<strong>小端字节序</strong>（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；<strong>小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</strong></p><h5 id="字节序举例"><a href="#字节序举例" class="headerlink" title="字节序举例"></a>字节序举例</h5><ul><li><p>小端字节序（大部分采用的）</p><p>0x 01 02 03 04 –   ff &#x3D; 255</p><p> 内存的方向—–&gt;</p></li></ul><p>​内存的低位    ——&gt;    内存的高位</p><p>​04 03 02 01</p><img src="/2024/06/02/MyWebServer/%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F.png" class=""><p>​存储的结果： 0x 11 22 33 44 12 34 56 78</p><ul><li><p>大端字节序</p><p>内存的方向—–&gt;</p><p>内存的高位    ——&gt;    内存的低位</p><img src="/2024/06/02/MyWebServer/%E5%A4%A7%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F.png" class=""></li></ul><p>​存储的结果： 0x 11 22 33 44 12 34 56 78</p><h5 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h5><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的 方法是：<strong>发送端总是把要发送的数据转换成大端字节序数据后再发送</strong>，而接收端知道对方传送过来的数据总是<strong>采用大端字节序</strong>，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p><p><strong>网络字节顺序</strong>是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，<strong>网络字节顺序采用大端排序方式</strong>。</p><p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">h   - host 主机，主机字节序<br>to  - 转换成什么<br>n   - network  网络字节序<br>s   - <span class="hljs-type">short</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span><br>l   - <span class="hljs-type">long</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br> <span class="hljs-comment">// 转换端口</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;     <span class="hljs-comment">// 主机字节序 - 网络字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span>;      <span class="hljs-comment">// 网络子节序 - 主机字节序</span><br><br><span class="hljs-comment">// 转IP</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;      <span class="hljs-comment">// 主机字节序 - 网络字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;       <span class="hljs-comment">// 网络子节序 - 主机字节序</span><br>  <br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    网络通信时，需要将主机字节序装换成网络字节序（大端）</span><br><span class="hljs-comment">    另外一段获取到数据以后根据情况将网络字节序转化成主机字节序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;arpa/inet.h&gt;</span><br><span class="hljs-comment">    // 转换端口</span><br><span class="hljs-comment">    uint16_t htons(uint16_t hostshort);     // 主机字节序 - 网络字节序</span><br><span class="hljs-comment">    uint16_t ntohs(uint16_t netshort);      // 网络子节序 - 主机字节序</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 转IP</span><br><span class="hljs-comment">    uint32_t htonl(uint32_t hostlong);      // 主机字节序 - 网络字节序</span><br><span class="hljs-comment">    uint32_t ntohl(uint32_t netlong);       // 网络子节序 - 主机字节序</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;       <br>    <span class="hljs-comment">// htons  转换端口</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> a = <span class="hljs-number">0x0102</span>; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> b = htons(a);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a : %x\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b : %x\n&quot;</span>, b);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;===========================\n&quot;</span>);<br>    <br>    <span class="hljs-comment">// htonl  转换IP</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">192</span>, <span class="hljs-number">168</span>, <span class="hljs-number">200</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span> *)buf;<br>    <span class="hljs-type">int</span> sum = htonl(num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *)&amp;sum;  <span class="hljs-comment">// 取地址</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="hljs-number">1</span>), *(p+<span class="hljs-number">2</span>), *(p+<span class="hljs-number">3</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;===========================\n&quot;</span>);<br><br>    <span class="hljs-comment">// ntohl</span><br>    <span class="hljs-type">char</span> buf1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">168</span>, <span class="hljs-number">192</span>&#125;;   <span class="hljs-comment">// 大端</span><br>    <span class="hljs-type">int</span> num1 = *(<span class="hljs-type">int</span> *)buf1;<br>    <span class="hljs-type">int</span> sum1 = ntohl(num1);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p1 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;sum1;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1+<span class="hljs-number">1</span>), *(p1+<span class="hljs-number">2</span>), *(p1+<span class="hljs-number">3</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10、socket地址"><a href="#10、socket地址" class="headerlink" title="10、socket地址"></a>10、socket地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个</span><br>socket地址。<br><span class="hljs-comment">// 客户端 -&gt;  服务器（IP, Port）</span><br></code></pre></td></tr></table></figure><h5 id="通用socket地址（IP和端口信息）"><a href="#通用socket地址（IP和端口信息）" class="headerlink" title="通用socket地址（IP和端口信息）"></a>通用socket地址（IP和端口信息）</h5><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br><span class="hljs-type">sa_family_t</span>  sa_family;<br> <span class="hljs-type">char</span>sa_data[<span class="hljs-number">14</span>];<br> &#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">sa_family_t</span>;<br></code></pre></td></tr></table></figure><p> sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：</p><table><thead><tr><th align="center">协议族</th><th align="center">地址族</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PF_UNIX</td><td align="center">AF_UNIX</td><td align="center">UNIX本地域协议族</td></tr><tr><td align="center">PF_INET</td><td align="center">AF_INET</td><td align="center">TCP&#x2F;IPv4协议族</td></tr><tr><td align="center">PF_INET6</td><td align="center">AF_INET6</td><td align="center">TCP&#x2F;IPv6协议族</td></tr></tbody></table><p>宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混 用。</p><p>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所 示：</p><table><thead><tr><th align="center">协议族</th><th align="center">地址值含义和长度</th></tr></thead><tbody><tr><td align="center">PF_UNIX</td><td align="center">文件的路径名，长度可以达到108字节</td></tr><tr><td align="center">PF_INET</td><td align="center">16 bit 端口号和32 bit地址，共6字节</td></tr><tr><td align="center">PF_INET6</td><td align="center">16 bit 端口号，32 bit 流标识，128 bit IPv6地址，32 bit 范围ID, 共26字节</td></tr></tbody></table><p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的 通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">sa_family_t</span> sa_family;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __ss_align;<br><span class="hljs-type">char</span> __ss_padding[ <span class="hljs-number">128</span> - <span class="hljs-keyword">sizeof</span>(__ss_align) ];<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-type">sa_family_t</span>;<br></code></pre></td></tr></table></figure><h5 id="专用-socket-地址"><a href="#专用-socket-地址" class="headerlink" title="专用 socket 地址"></a>专用 socket 地址</h5><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现 在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是  sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p><p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">sa_family_t</span> sin_family;<br><span class="hljs-type">char</span> sun_path[<span class="hljs-number">108</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p> TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和  IPv6：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">sa_family_t</span> sin_family;     <span class="hljs-comment">/* __SOCKADDR_COMMON(sin_) */</span><br><span class="hljs-type">in_port_t</span> sin_port;         <span class="hljs-comment">/* Port number.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>    <span class="hljs-comment">/* Internet address.  */</span><br> <span class="hljs-comment">/* Pad to size of `struct sockaddr&#x27;. */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sin_zero[<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE <br><span class="hljs-title function_">sizeof</span> <span class="hljs-params">(<span class="hljs-type">in_port_t</span>)</span> - <span class="hljs-title function_">sizeof</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr)</span>];<br> &#125;;  <br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-type">in_addr_t</span> s_addr;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span></span><br><span class="hljs-class">&#123;</span><br> <span class="hljs-type">sa_family_t</span> sin6_family;<br> <span class="hljs-type">in_port_t</span> sin6_port;    <span class="hljs-comment">/* Transport layer port # */</span><br><span class="hljs-type">uint32_t</span> sin6_flowinfo; <span class="hljs-comment">/* IPv6 flow information */</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>  <span class="hljs-comment">/* IPv6 address */</span><br> <span class="hljs-type">uint32_t</span> sin6_scope_id; <span class="hljs-comment">/* IPv6 scope-id */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>  <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    <span class="hljs-type">uint32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> <span class="hljs-type">in_port_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">in_addr_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span><br></code></pre></td></tr></table></figure><p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地 址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p><h4 id="11、IP地址转换（字符串ip-整数，-主机-网络字节序的转换）"><a href="#11、IP地址转换（字符串ip-整数，-主机-网络字节序的转换）" class="headerlink" title="11、IP地址转换（字符串ip-整数， 主机-网络字节序的转换）"></a>11、IP地址转换（字符串ip-整数， 主机-网络字节序的转换）</h4><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们<strong>转化为整数（二进制数）</strong>方能使用。而记录日志时则相反，我们要把整数表示的 <strong>IP 地址转化为可读的字符串</strong>。下面 3 个函数可用于用<strong>点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cp)</span>;<span class="hljs-comment">//   转换成int类型的整数，网络字节序</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cp, <span class="hljs-keyword">struct</span> in_addr *inp)</span>;<span class="hljs-comment">// 转换成网络字节序，保存在inp里</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr in)</span>;<span class="hljs-comment">// </span><br></code></pre></td></tr></table></figure><p>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// p:点分十进制的IP字符串，</span><br><span class="hljs-comment">// n:表示network，网络字节序的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br> <span class="hljs-comment">// af:地址族： AF_INET  AF_INET6</span><br> <span class="hljs-comment">// src:需要转换的点分十进制的IP字符串</span><br><span class="hljs-comment">// dst:转换后的结果保存在这个里面</span><br><br><span class="hljs-comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>;<br><span class="hljs-comment">// af:地址族： AF_INET  AF_INET6</span><br> <span class="hljs-comment">// src: 要转换的ip的整数的地址</span><br><span class="hljs-comment">// dst: 转换成IP地址字符串保存的地方</span><br><span class="hljs-comment">// size：第三个参数的大小（数组的大小）</span><br><span class="hljs-comment">// 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 创建一个IP字符串，点分十进制的IP地址字符串</span><br>    <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;192.168.1.1&quot;</span>;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span><br>    inet_pton(AF_INET, buf, &amp;num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="hljs-number">1</span>), *(p+<span class="hljs-number">2</span>), *(p+<span class="hljs-number">3</span>));<br><br>    <span class="hljs-comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span><br>    <span class="hljs-type">char</span> ip[<span class="hljs-number">16</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * str = inet_ntop(AF_INET, &amp;num, ip, <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str: %s\n&quot;</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ip: %s\n&quot;</span>, ip);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12、TCP通信流程"><a href="#12、TCP通信流程" class="headerlink" title="12、TCP通信流程"></a>12、TCP通信流程</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// TCP 和 UDP  -&gt; 传输层的协议</span><br><span class="hljs-symbol">UDP:</span>用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠<br><span class="hljs-symbol">TCP:</span>传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否创建连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠</td><td align="center">可靠</td></tr><tr><td align="center">连接的对象个数</td><td align="center">一对一、一对多<br />多对一、多对多</td><td align="center">支持一对一</td></tr><tr><td align="center">传输的方式</td><td align="center">面向数据报</td><td align="center">面向字节流</td></tr><tr><td align="center">首部开销</td><td align="center">8个字节</td><td align="center">最少20个字节</td></tr><tr><td align="center">适用场景</td><td align="center">实时应用（视频会议、直播）</td><td align="center">可靠性高的应用（文件传输）</td></tr></tbody></table><img src="/2024/06/02/MyWebServer/TCP%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" class=""><h5 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h5><p><strong>服务器端</strong></p><ol><li>创建一个用于监听的套接字<ul><li>监听：监听有有客户端的连接</li><li>套接字：这个套接字其实就是一个文件描述符</li></ul></li><li>将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）<ul><li>客户端连接服务器的时候使用的就是这个IP和端口</li></ul></li><li>设置监听，监听的fd开始工作</li><li>阻塞等待，当有客户端发起连接，接触阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</li><li>通信<ul><li>接收数据</li><li>发送数据</li></ul></li><li>通信结束，断开连接</li></ol><p><strong>客户端</strong></p><ol><li>创建一个用于通信的套接字（fd）</li><li>连接服务器，需要指定连接的服务器和IP和端口</li><li>连接成功，客户端可以直接和服务器通信<ul><li>接收数据</li><li>发送数据</li></ul></li><li>通信结束，断开连接</li></ol><h4 id="13、套接字函数"><a href="#13、套接字函数" class="headerlink" title="13、套接字函数"></a>13、套接字函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span>  <span class="hljs-comment">// 包含了这个头文件，上面两个就可以省略</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;   <br><span class="hljs-comment">/*- 功能：创建一个套接字</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - domain: 协议族</span><br><span class="hljs-comment">            AF_INET : ipv4</span><br><span class="hljs-comment">            AF_INET6 : ipv6</span><br><span class="hljs-comment">            AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="hljs-comment">        - type: 通信过程中使用的协议类型</span><br><span class="hljs-comment">            SOCK_STREAM : 流式协议</span><br><span class="hljs-comment">            SOCK_DGRAM  : 报式协议</span><br><span class="hljs-comment">        - protocol : 具体的一个协议。一般写0</span><br><span class="hljs-comment">            - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="hljs-comment">            - SOCK_DGRAM  : 报式协议默认使用 UDP</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="hljs-comment">            - 失败：-1     */</span>  <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>; <br><span class="hljs-comment">// socket命名</span><br><span class="hljs-comment">/*  - 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">            - sockfd : 通过socket函数得到的文件描述符</span><br><span class="hljs-comment">            - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="hljs-comment">            - addrlen : 第二个参数结构体占的内存大小</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;    <span class="hljs-comment">// /proc/sys/net/core/somaxconn</span><br><span class="hljs-comment">/*- 功能：监听这个socket上的连接</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="hljs-comment">- backlog : 未连接的和已经连接的和的最大值， 5</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">/*- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接 </span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- sockfd : 用于监听的文件描述符</span><br><span class="hljs-comment">- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="hljs-comment">- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">- 成功 ：用于通信的文件描述符</span><br><span class="hljs-comment">         - 失败 ：-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">/*- 功能： 客户端连接服务器</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- sockfd : 用于通信的文件描述符</span><br><span class="hljs-comment">- addr : 客户端要连接的服务器的地址信息</span><br><span class="hljs-comment">- addrlen : 第二个参数的内存大小</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">成功 0， 失败 -1</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;   <span class="hljs-comment">// 写数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;          <span class="hljs-comment">// 读数据</span><br></code></pre></td></tr></table></figure><p><strong>代码示例：服务器客户端通信</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//TCP通信的客户端</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 1、建立套接字</span><br>    <span class="hljs-type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sockfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2、连接服务器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span><br>    clientaddr.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;clientaddr.sin_addr.s_addr);<br>    clientaddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    <span class="hljs-type">int</span> ret = connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clientaddr, <span class="hljs-keyword">sizeof</span>(clientaddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 3、发送数据</span><br>        <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;hello, i am client.&quot;</span>;<br>        write(sockfd, data, <span class="hljs-built_in">strlen</span>(data));<br>        sleep(<span class="hljs-number">1</span>);<br>    <br>        <span class="hljs-comment">// 4、接收数据</span><br>        <span class="hljs-type">ssize_t</span> len = read(sockfd, recvbuf, <span class="hljs-keyword">sizeof</span>(recvbuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv client data : %s\n&quot;</span>, recvbuf);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 表示客户端断开连接 </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server closed .....\n&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5、关闭套接字</span><br>    close(sockfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//TCP通信的服务器端</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 1、 创建socket套接字</span><br>    <span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2、 绑定套接字 IP 和 端口</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_family = AF_INET;<br>    <span class="hljs-comment">// inet_pton(AF_INET, &quot;0.0.0.0&quot;, saddr.sin_addr.s_addr);</span><br>    <span class="hljs-comment">// INADDR_ANY 是一个在网络编程中常用的宏，</span><br>    <span class="hljs-comment">// 它通常被用于绑定一个套接字（socket）到所有可用的网络接口上。</span><br>    <span class="hljs-comment">// 这意味着服务器可以接收任何网络接口上的数据包，</span><br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br><br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3、 监听</span><br>    ret = listen(lfd, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span><br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(clientaddr);<br>    <span class="hljs-comment">// 4、接收客户端连接</span><br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4、输出客户端的信息   网络字节序  -》 主机字节序</span><br>    <span class="hljs-type">char</span> clientip[<span class="hljs-number">16</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientip, <span class="hljs-keyword">sizeof</span>(clientip));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> clientport = ntohs(clientaddr.sin_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client ip : %s, prot : %d\n&quot;</span>, clientip, clientport);<br><br>    <span class="hljs-comment">// 5、通信</span><br>    <span class="hljs-comment">// 获取客户端的数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">ssize_t</span> len1 = read(cfd, recvbuf, <span class="hljs-keyword">sizeof</span>(recvbuf));<br>        <span class="hljs-keyword">if</span>(len1 == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len1 &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv client data : %s\n&quot;</span>, recvbuf);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len1 == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 表示客户端断开连接 </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed .....\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 给客户端发送数据</span><br>        <span class="hljs-type">char</span> * data = <span class="hljs-string">&quot;hello, i am server.&quot;</span>;<br>        write(cfd, data, <span class="hljs-built_in">strlen</span>(data));<br>    &#125;<br>    <br><br>    <span class="hljs-comment">// 关闭文件描述符</span><br>    close(cfd);<br>    close(lfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14、TCP三次握手"><a href="#14、TCP三次握手" class="headerlink" title="14、TCP三次握手"></a>14、TCP三次握手</h4><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连 接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程 中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。 </p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手 来关闭一个连接。 </p><p>三次握手的目的是保证双方互相之间建立了连接。 </p><p>三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手。</p><img src="/2024/06/02/MyWebServer/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class=""><p><strong>第一次握手</strong></p><ol><li>客户端将 SYN 标志位置为1</li><li>生成一个随机的32位的序号 seq&#x3D;j，这个序号后边是可以携带数据（数据的大小）</li></ol><p><strong>第二次握手</strong></p><ol><li>服务器端接收客户端的连接  ACK &#x3D; 1</li><li>服务器会会发一个确认序号  ack &#x3D; 客户端的序号 + 数据长度 + SYN&#x2F;FIN（按一个字节算），一般是ack &#x3D; j + 1</li><li>服务器端会向客户端发起连接请求：SYN &#x3D; 1</li><li>服务器会生成一个随机序号 seq &#x3D; K</li></ol><p><strong>第三次握手</strong></p><ol><li>客户端应答服务器的连接请求：ACK &#x3D; 1</li><li>客户端回复收到了服务器端的数据： ack&#x3D;服务端的序号 + 数据长度 + SYN&#x2F;FIN（按一个字节算）</li></ol><h4 id="15、TCP滑动窗口"><a href="#15、TCP滑动窗口" class="headerlink" title="15、TCP滑动窗口"></a>15、TCP滑动窗口</h4><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的 拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种 技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。</p><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于 接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0  时，发送方一般不能再发送数据报。</p><p>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。</p><p>窗口理解为缓冲区的大小 </p><p>滑动窗口的大小会随着发送数据和接收数据而变化。 </p><p>通信的双方都有发送缓冲区和接收数据的缓冲区</p><p>服务器</p><ul><li>发送缓冲区（发送缓冲区的窗口） </li><li>接收缓冲区（接收缓冲区的窗口）</li></ul><p>客户端</p><ul><li>发送缓冲区（发送缓冲区的窗口） </li><li>接收缓冲区（接收缓冲区的窗口）</li></ul><img src="/2024/06/02/MyWebServer/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">发送方的缓冲区：<br>    白色格子：空闲的空间<br>    灰色格子：数据已经被发送出去了，但是还没有被接收<br>    紫色格子：还没有发送出去的数据<br>接收方的缓冲区：<br>    白色格子：空闲的空间<br>    紫色格子：已经接收到的数据<br></code></pre></td></tr></table></figure><img src="/2024/06/02/MyWebServer/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A32.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span><br><span class="hljs-meta"># win: 滑动窗口</span><br><span class="hljs-number">1.</span> 客户端向服务器发起连接，客户单的滑动窗口是<span class="hljs-number">4096</span>，一次发送的最大数据量是<span class="hljs-number">1460</span><br><span class="hljs-number">2.</span> 服务器接收连接情况，告诉客户端服务器的窗口大小是<span class="hljs-number">6144</span>，一次发送的最大数据量是<span class="hljs-number">1024</span><br><span class="hljs-number">3.</span> 第三次握手<br><span class="hljs-number">4.</span> <span class="hljs-number">4</span><span class="hljs-number">-9</span> 客户端连续给服务器发送了<span class="hljs-number">6</span>k的数据，每次发送<span class="hljs-number">1</span>k<br><span class="hljs-number">5.</span> 第<span class="hljs-number">10</span>次，服务器告诉客户端：发送的<span class="hljs-number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="hljs-number">2</span>k,窗口大小是<span class="hljs-number">2</span>k<br><span class="hljs-number">6.</span> 第<span class="hljs-number">11</span>次，服务器告诉客户端：发送的<span class="hljs-number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="hljs-number">4</span>k,窗<br>口大小是<span class="hljs-number">4</span>k<br><span class="hljs-number">7.</span> 第<span class="hljs-number">12</span>次，客户端给服务器发送了<span class="hljs-number">1</span>k的数据<br><span class="hljs-number">8.</span> 第<span class="hljs-number">13</span>次，客户端主动请求和服务器断开连接，并且给服务器发送了<span class="hljs-number">1</span>k的数据<br><span class="hljs-number">9.</span> 第<span class="hljs-number">14</span>次，服务器回复ACK <span class="hljs-number">8194</span>, a:同意断开连接的请求 b:告诉客户端已经接受到方才发的<span class="hljs-number">2</span>k的数据 <br>c:滑动窗口<span class="hljs-number">2</span>k<br><span class="hljs-number">10.</span>第<span class="hljs-number">15</span>、<span class="hljs-number">16</span>次，通知客户端滑动窗口的大小<br><span class="hljs-number">11.</span>第<span class="hljs-number">17</span>次，第三次挥手，服务器端给客户端发送FIN,请求断开连接<br><span class="hljs-number">12.</span>第<span class="hljs-number">18</span>次，第四次回收，客户端同意了服务器端的断开请求<br></code></pre></td></tr></table></figure><h4 id="16、TCP四次挥手"><a href="#16、TCP四次挥手" class="headerlink" title="16、TCP四次挥手"></a>16、TCP四次挥手</h4><p>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。 客户端和服务器端都可以主动发起断开连接，<strong>谁先调用close()谁就是发起</strong>。 因为在TCP连接的时候，采用三次握手建立的的连接是双向的，<strong>在断开的时候需要双向断开</strong>。</p><img src="/2024/06/02/MyWebServer/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class=""><h4 id="17、TCP通信并发"><a href="#17、TCP通信并发" class="headerlink" title="17、TCP通信并发"></a>17、TCP通信并发</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。<br>思路：<br><span class="hljs-bullet">1.</span> 一个父进程，多个子进程<br>2.父进程负责等待并接受客户端的连接<br>3.子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信。<br></code></pre></td></tr></table></figure><h4 id="18、TCP状态转换"><a href="#18、TCP状态转换" class="headerlink" title="18、TCP状态转换"></a>18、TCP状态转换</h4><img src="/2024/06/02/MyWebServer/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" class=""><img src="/2024/06/02/MyWebServer/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A22.png" class=""><ul><li><p>2MSL(Maximum Segment Lifetime)</p><p>主动断开连接的一方，最后进入一个TIME_WAIT状态，这个状态会持续：2msl</p><ul><li>msl：官方建议：2分钟，实际是30s</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方<br>必须处于TIME_WAIT 状态并持续 2MSL 时间。<br><br>这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。<br><br>主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，<br>被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是<br>重传 FIN 直到它收到一个最终的 ACK。<br></code></pre></td></tr></table></figure></li><li><p>半关闭</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">当 TCP 链接中 <span class="hljs-selector-tag">A</span> 向 <span class="hljs-selector-tag">B</span> 发送 FIN 请求关闭，另一端 <span class="hljs-selector-tag">B</span> 回应 ACK 之后（<span class="hljs-selector-tag">A</span> 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 <span class="hljs-selector-tag">A</span>，<span class="hljs-selector-tag">A</span> 方处于半连接状态（半开关），此时 <span class="hljs-selector-tag">A</span> 可以接收 <span class="hljs-selector-tag">B</span> 发送的数据，但是 <span class="hljs-selector-tag">A</span> 已经不能再向 <span class="hljs-selector-tag">B</span> 发送数据。<br></code></pre></td></tr></table></figure><p>从程序的角度，可以使用 API 来控制实现半连接状态：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> how)</span>;<br>sockfd: 需要关闭的socket的描述符<br>how:    允许为shutdown操作选择以下几种方式:<br>SHUT_RD(<span class="hljs-number">0</span>)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。<br>该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。<br>SHUT_WR(<span class="hljs-number">1</span>):  关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。<br>SHUT_RDWR(<span class="hljs-number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以<br>SHUT_WR。<br></code></pre></td></tr></table></figure><p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用 计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。 </p><p>注意:</p><ol><li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用 进程都调用了 close，套接字将被释放。  </li><li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。 但如果一个进程 close(sfd) 将不会影响到其它进程</li></ol><h4 id="19、端口复用"><a href="#19、端口复用" class="headerlink" title="19、端口复用"></a>19、端口复用</h4><p>端口复用最常用的用途是: </p><ul><li>防止服务器重启时之前绑定的端口还未释放 </li><li>程序突然退出而系统没有释放端口</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br> <span class="hljs-comment">// 设置套接字的属性（不仅仅能设置端口复用）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> </span><br><span class="hljs-params">optlen)</span>;<br>参数：<br>        - sockfd : 要操作的文件描述符<br>        - level : 级别 - SOL_SOCKET (端口复用的级别)<br>        - optname : 选项的名称<br>            - SO_REUSEADDR<br>            - SO_REUSEPORT<br>        - optval : 端口复用的值（整形）<br>            - <span class="hljs-number">1</span> : 可以复用<br>            - <span class="hljs-number">0</span> : 不可以复用<br>        - optlen : optval参数的大小<br><br>端口复用，设置的时机是在服务器绑定端口之前。<br>setsockopt();<br> bind();<br></code></pre></td></tr></table></figure><h4 id="20、I-O多路复用（I-O多路转接）"><a href="#20、I-O多路复用（I-O多路转接）" class="headerlink" title="20、I&#x2F;O多路复用（I&#x2F;O多路转接）"></a>20、I&#x2F;O多路复用（I&#x2F;O多路转接）</h4><p><strong>I&#x2F;O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能</strong>，Linux 下实现 I&#x2F;O 多路复用的 系统调用主要有 select、poll 和 epoll。</p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>主旨思想：</p><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中，</li><li>调用一个系统函数，监听列表中的文件描述符，直到这些描述符中的一个或者多个进行I&#x2F;O操作时，该函数才返回。<ol><li>这个函数时阻塞的</li><li>函数对文件描述符的检测的操作是由内核完成的</li></ol></li><li>在返回时，他会告诉进程有多少那些描述符要进行I&#x2F;O操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// sizeof(fd_set) = 128     1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br> <span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span><br><span class="hljs-params">           fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br>- 参数：<br>        - nfds：委托内核检测的最大文件描述符的值 + <span class="hljs-number">1</span><br>        - readfds:要检测的文件描述符的读的集合，委托内核检测那些文件描述符的读的属性<br>            - 一般检测读操作<br>            - 对应的时对方发送过来的数据，因为读数被动的接受数据，检测的就是读缓冲区<br>            - 是一个传入传出参数<br>        - writefds:要检测的文件描述符的些的集合，委托内核检测那些文件描述符的写的属性<br>            - 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）<br>        - exceptfds: 检测发生异常的文件描述符的集合<br>        - timeout：设置的超时时间<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>&#123;</span><br>            <span class="hljs-type">long</span> tv_sec;<span class="hljs-comment">// seconds</span><br>                <span class="hljs-type">long</span> tv_usec<span class="hljs-comment">// microseconds</span><br>            &#125;;<br>- <span class="hljs-literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化<br>             - tv_sec = <span class="hljs-number">0</span> tv_usec = <span class="hljs-number">0</span>， 不阻塞<br>             - tv_sec &gt; <span class="hljs-number">0</span> tv_usec &gt; <span class="hljs-number">0</span>， 阻塞对应的时间<br>- 返回值：<br>        - <span class="hljs-number">-1</span>：失败<br>        - &gt;<span class="hljs-number">0</span>(n): 检测的集合中有n个文件描述符发生了变化<br>        <br><span class="hljs-comment">// 将参数文件描述符fd对应的标志位设置为0</span><br> <span class="hljs-type">void</span> FD_CLR(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span><br> <span class="hljs-type">int</span>  <span class="hljs-title function_">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>;<br> <span class="hljs-comment">// 将参数文件描述符fd 对应的标志位，设置为1</span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *<span class="hljs-built_in">set</span>)</span>;<br> <span class="hljs-comment">// fd_set一共有1024 bit, 全部初始化为0</span><br> <span class="hljs-type">void</span> <span class="hljs-title function_">FD_ZERO</span><span class="hljs-params">(fd_set *<span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>select服务端代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port = htos(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br><br>    listen(lfd, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 创建一个fd_set集合，这里面是需要检测的文件描述符</span><br>    fd_set rdset, tmp;<br>    FD_ZERO(&amp;rdset);<br>    FD_SET(lfd, &amp;rdset);<br>    <span class="hljs-type">int</span> maxfd = lfd;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        tmp = rdset;<br><br>        <span class="hljs-comment">// 调用 select 系统函数，让内核帮检测那些文件描述符有数据</span><br>        <span class="hljs-type">int</span> ret = select(maxfd + <span class="hljs-number">1</span>, &amp;tmp, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;select&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span><br>            <span class="hljs-keyword">if</span>(FD_ISSET(lfd, &amp;tmp))<br>            &#123;<br>                <span class="hljs-comment">// 表示有新的客户端连接进来了</span><br>                <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>                <br>                <span class="hljs-comment">// 将新的文件描述符加入到集合中</span><br>                FD_SET(cfd, &amp;rdset);<br><br>                <span class="hljs-comment">// 更新最大的文件描述符</span><br>                maxfd = maxfd &gt; cfd? maxfd : cfd;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = lfd + <span class="hljs-number">1</span>; i &lt;= maxfd; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(FD_ISSET(i, &amp;tmp))<br>                &#123;<br>                    <span class="hljs-comment">// 说明这个文件描述符对应的客户端发来了数据</span><br>                    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>                    <span class="hljs-type">int</span> len = read(i, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>                    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)<br>                    &#123;<br>                        perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed...\n&quot;</span>);<br>                        close(i);<br>                        FD_CLR(i, &amp;rdset);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv data : %s\n&quot;</span>, buf);<br>                        write(i, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br> <span class="hljs-type">int</span>   fd;          <span class="hljs-comment">/* 委托内核检测的文件描述符 */</span><br><span class="hljs-type">short</span> events;      <span class="hljs-comment">/* 委托内核检测文件描述符的什么事件 */</span><br><span class="hljs-type">short</span> revents;     <span class="hljs-comment">/* 文件描述符实际发生的事件 */</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">myfd</span>;</span><br>myfd.fd = <span class="hljs-number">5</span>;<br>myfd.events = POLLIN | POLLOUT;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span>;<br>- 参数：<br>        - fds : 是一个<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span><br><span class="hljs-class">        - <span class="hljs-title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="hljs-number">1</span><br>        - timeout : 阻塞时长<br>    <span class="hljs-number">0</span> : 不阻塞<br>            <span class="hljs-number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞<br>        &gt;<span class="hljs-number">0</span> : 阻塞的时长<br>     - 返回值：<br>            <span class="hljs-number">-1</span> : 失败<br>            &gt;<span class="hljs-number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化   <br></code></pre></td></tr></table></figure><img src="/2024/06/02/MyWebServer/poll%E4%BA%8B%E4%BB%B6.png" class=""><p>poll服务端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port = htos(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br><br>    listen(lfd, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 初始化检测的文件描述符数组</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>[1024];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++)<br>    &#123;<br>        fds[i].fd = <span class="hljs-number">-1</span>;<br>        fds[i].events = POLLIN;<br>    &#125;<br><br>    fds[<span class="hljs-number">0</span>].fd = lfd;<br><br>    <span class="hljs-type">int</span> nfds = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123; <br>        <span class="hljs-comment">// 调用 poll 系统函数，让内核帮检测那些文件描述符有数据</span><br>        <span class="hljs-type">int</span> ret = poll(fds, nfds + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;poll&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span><br>            <span class="hljs-keyword">if</span>(fds[<span class="hljs-number">0</span>].revents &amp; POLLIN)<br>            &#123;<br>                <span class="hljs-comment">// 表示有新的客户端连接进来了</span><br>                <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>                <br>                <span class="hljs-comment">// 将新的文件描述符加入到集合中</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1024</span>; i++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(fds[i].fd == <span class="hljs-number">-1</span>)<br>                    &#123;<br>                        fds[i].fd = cfd;<br>                        fds[i].events = POLLIN;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 更新最大的文件描述符</span><br>                nfds = nfds &gt; cfd? nfds : cfd;<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nfds; i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(fds[i].revents &amp; POLLIN)<br>                &#123;<br>                    <span class="hljs-comment">// 说明这个文件描述符对应的客户端发来了数据</span><br>                    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>                    <span class="hljs-type">int</span> len = read(fds[i].fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>                    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)<br>                    &#123;<br>                        perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed...\n&quot;</span>);<br>                        close(fds[i].fd);<br>                        fds[i].fd = <span class="hljs-number">-1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv data : %s\n&quot;</span>, buf);<br>                        write(fds[i].fd, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br>- 参数：<br>size : 目前没有意义了。随便写一个数，必须大于<span class="hljs-number">0</span><br>    - 返回值：<br>         <span class="hljs-number">-1</span> : 失败<br>&gt; <span class="hljs-number">0</span> : 文件描述符，操作epoll实例的<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span> &#123;</span><span class="hljs-comment">// 内部只有一个能存在 union</span><br><span class="hljs-type">void</span>*ptr;<br> <span class="hljs-type">int</span>       fd;<br><span class="hljs-type">uint32_t</span>     u32;<br><span class="hljs-type">uint64_t</span>     u64;<br>&#125;<span class="hljs-type">epoll_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br><span class="hljs-type">uint32_t</span>     events;      <span class="hljs-comment">/* Epoll events */</span><br><span class="hljs-type">epoll_data_t</span> data;        <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br><br>常见的Epoll检测事件：<br>    - EPOLLIN<br>    - EPOLLOUT<br>    - EPOLLERR<br>    <br><span class="hljs-comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br>    - 参数：<br>            - epfd : epoll实例对应的文件描述符<br>            - op : 要进行什么操作<br>                EPOLL_CTL_ADD:  添加<br>                EPOLL_CTL_MOD:  修改<br>                EPOLL_CTL_DEL:  删除<br>            - fd : 要检测的文件描述符<br>            - event : 检测文件描述符什么事情<br><br><span class="hljs-comment">// 检测函数                </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> </span><br><span class="hljs-params">timeout)</span>;<br>    - 参数：<br>        - epfd : epoll实例对应的文件描述符<br>        - events : 传出参数，保存了发送了变化的文件描述符的信息<br>        - maxevents : 第二个参数结构体数组的大小<br>        - timeout : 阻塞时间<br>            - <span class="hljs-number">0</span> : 不阻塞<br>            - <span class="hljs-number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞<br>            - &gt; <span class="hljs-number">0</span> : 阻塞的时长（毫秒）<br>                <br>    - 返回值：<br>         - 成功，返回发送变化的文件描述符的个数 &gt; <span class="hljs-number">0</span><br>         - 失败 <span class="hljs-number">-1</span><br><br></code></pre></td></tr></table></figure><p>epoll的服务器实列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br><br>    listen(lfd, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 调用epoll_create()创建一个epoll实列</span><br>    <span class="hljs-type">int</span> epfd = epoll_create1(<span class="hljs-number">100</span>);<br>    <br>    <span class="hljs-comment">// 需要将监听的文件描述符相关的检测信息添加到epoll实列中</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epev</span>;</span><br>    epev.events = EPOLLIN;<br>    epev.data.fd = lfd;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epevs</span>[1024];</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 调用epoll_wait()去检测那些有数据到达了</span><br>        <span class="hljs-type">int</span> ret = epoll_wait(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>, ret);  <span class="hljs-comment">// 有几个发生了变化</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)<br>        &#123;   <br>            <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br>            <span class="hljs-keyword">if</span>(curfd == lfd)<br>            &#123;<br>                <span class="hljs-comment">// 监听的文件描述符有数据到达，有客户端连接</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>                <br>                epev.events = EPOLLIN;<br>                epev.data.fd = cfd;<br>                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;   <br>                <span class="hljs-keyword">if</span>(epevs[i].events &amp; EPOLLOUT)<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 有数据到达了，需要通信</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>                <span class="hljs-type">int</span> len = read(curfd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed...\n&quot;</span>);<br>                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="hljs-literal">NULL</span>);<br>                    close(curfd);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv data : %s\n&quot;</span>, buf);<br>                    write(curfd, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    close(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Epoll 的工作模式:</strong></p><ul><li><p>LT模式（水平触发） <strong>默认</strong></p><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>​读缓冲区有数据 -&gt; epoll 检测到了会给用户通知</p><ul><li>用户不读数据，数据一直在缓冲区，epoll会一直通知</li><li>用户只读了一部分数据，epoll会通知</li><li>缓冲区的数据读完了，不通知</li></ul></li></ul><p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。如果你不作任何操作，内核还是会继续通知你的。</p><ul><li><p>ET模式（边沿触发）</p><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>​读缓冲区有数据 -&gt; epoll会检测到了会给用户通知</p><ul><li>用户不读数据，数据一直在缓冲区，epoll下次检测的时候就不通知了</li><li>用户只读了一部分数据，epoll不通知</li><li>缓冲区数据读完了，不通知</li></ul></li></ul><p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成 未就绪），内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll  工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写 操作把处理多个文件描述符的任务饿死。</p><p><strong>设置边沿触发</strong>（要配合非阻塞来使用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br> <span class="hljs-type">uint32_t</span>     events;      <br> <span class="hljs-type">epoll_data_t</span> data;        <br>&#125;;<br>常见的Epoll检测事件：<br>    - EPOLLIN<br>    - EPOLLOUT<br>    - EPOLLERR<br>    - EPOLLET<br>    <br>    <br> epev.events = EPOLLIN | EPOLLET;<span class="hljs-comment">// 设置边沿触发</span><br> epev.data.fd = cfd;<br> epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br></code></pre></td></tr></table></figure><p>​ET触发 服务器实列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br><br>    listen(lfd, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 调用epoll_create()创建一个epoll实列</span><br>    <span class="hljs-type">int</span> epfd = epoll_create1(<span class="hljs-number">100</span>);<br>    <br>    <span class="hljs-comment">// 需要将监听的文件描述符相关的检测信息添加到epoll实列中</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epev</span>;</span><br>    epev.events = EPOLLIN;<br>    epev.data.fd = lfd;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epevs</span>[1024];</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 调用epoll_wait()去检测那些有数据到达了</span><br>        <span class="hljs-type">int</span> ret = epoll_wait(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>, ret);  <span class="hljs-comment">// 有几个发生了变化</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)<br>        &#123;   <br>            <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br>            <span class="hljs-keyword">if</span>(curfd == lfd)<br>            &#123;<br>                <span class="hljs-comment">// 监听的文件描述符有数据到达，有客户端连接</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>                <br>                <span class="hljs-comment">// 设置 cfd 非阻塞属性</span><br>                <span class="hljs-type">int</span> flag = fcntl(cfd, F_GETFL);<br>                flag | O_NONBLOCK;<br>                fcntl(cfd, F_SETFL, flag);<br><br>                epev.events = EPOLLIN | EPOLLET;<br>                epev.data.fd = cfd;<br>                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;   <br>                <span class="hljs-keyword">if</span>(epevs[i].events &amp; EPOLLOUT)<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 循环读取出全部数据</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>((len = read(curfd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)<br>                &#123;   <br>                    <span class="hljs-comment">// read 的非阻塞由文件描述符确定</span><br>                    <span class="hljs-comment">//printf(&quot;recv data : %s\n&quot;, buf);</span><br>                    write(STDOUT_FILENO, buf, len);<br>                    write(curfd, buf, len);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed...\n&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(errno == EAGAIN)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data over..n&quot;</span>);<br>                    &#125;<br>                    perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    close(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><h4 id="21、UDP通信"><a href="#21、UDP通信" class="headerlink" title="21、UDP通信"></a>21、UDP通信</h4><img src="/2024/06/02/MyWebServer/UDP%E9%80%9A%E4%BF%A1.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br>- 参数：<br>        - sockfd : 通信的fd<br>        - buf : 要发送的数据<br>        - len : 发送数据的长度<br>        - flags : <span class="hljs-number">0</span><br>        - dest_addr : 通信的另外一端的地址信息<br>        - addrlen : 地址的内存大小<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>- 参数：<br>        - sockfd : 通信的fd<br>        - buf : 接收数据的数组<br>        - len : 数组的大小<br>        - flags : <span class="hljs-number">0</span><br>        - src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="hljs-literal">NULL</span><br>        - addrlen : 地址的内存大小<br></code></pre></td></tr></table></figure><p><strong>UDP服务器端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.创建一个通信的socket</span><br>    <span class="hljs-type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;   <br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">addr</span>;</span><br>    addr.sin_family = AF_INET;<br>    addr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    addr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 2.绑定</span><br>    <span class="hljs-type">int</span> ret = bind(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-keyword">sizeof</span>(addr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.通信</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">128</span>];<br>        <span class="hljs-type">char</span> ipbuf[<span class="hljs-number">16</span>];<br><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>        <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br><br>        <span class="hljs-comment">// 接收数据</span><br>        <span class="hljs-type">int</span> num = recvfrom(fd, recvbuf, <span class="hljs-keyword">sizeof</span>(recvbuf), <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client IP : %s, Port : %d\n&quot;</span>, <br>            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="hljs-keyword">sizeof</span>(ipbuf)),<br>            ntohs(cliaddr.sin_port));<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client say : %s\n&quot;</span>, recvbuf);<br><br>        <span class="hljs-comment">// 发送数据</span><br>        sendto(fd, recvbuf, <span class="hljs-built_in">strlen</span>(recvbuf) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, <span class="hljs-keyword">sizeof</span>(cliaddr));<br><br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UDP客户端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.创建一个通信的socket</span><br>    <span class="hljs-type">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;   <br><br>    <span class="hljs-comment">// 服务器的地址信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_family = AF_INET;<br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 3.通信</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><br>        <span class="hljs-comment">// 发送数据</span><br>        <span class="hljs-type">char</span> sendBuf[<span class="hljs-number">128</span>];<br>        <span class="hljs-built_in">sprintf</span>(sendBuf, <span class="hljs-string">&quot;hello , i am client %d \n&quot;</span>, num++);<br>        sendto(fd, sendBuf, <span class="hljs-built_in">strlen</span>(sendBuf) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br><br>        <span class="hljs-comment">// 接收数据</span><br>        <span class="hljs-type">int</span> num = recvfrom(fd, sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf), <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server say : %s\n&quot;</span>, sendBuf);<br><br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h5><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广 播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。</p><p>a.只能在局域网中使用。 </p><p>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置广播属性的函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> </span><br><span class="hljs-params">optlen)</span>;<br>- sockfd : 文件描述符<br>- level : SOL_SOCKET<br>- optname : SO_BROADCAST<br>- optval : <span class="hljs-type">int</span>类型的值，为<span class="hljs-number">1</span>表示允许广播<br>- optlen : optval的大<br></code></pre></td></tr></table></figure><h5 id="组播-多播"><a href="#组播-多播" class="headerlink" title="组播&#x2F;多播"></a>组播&#x2F;多播</h5><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。 单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方 案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上 的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网 使用。</p><p>a.组播既可以用于局域网，也可以用于广域网 </p><p>b.客户端需要加入多播组，才能接收到多播的数据</p><p><strong>组播地址</strong> </p><p>IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从   224.0.0.0 到  并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span>;<br> <span class="hljs-comment">// 服务器设置多播的信息，外出接口</span><br> - level : IPPROTO_IP<br>    - optname : IP_MULTICAST_IF<br>    - optval : <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">    </span><br><span class="hljs-class">    // 客户端加入到多播组：</span><br><span class="hljs-class">    - <span class="hljs-title">level</span> :</span> IPPROTO_IP<br>    - optname : IP_ADD_MEMBERSHIP<br>    - optval : <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_mreq</span></span><br><span class="hljs-class">        </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_mreq</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">/* IP multicast address of group.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">imr_multiaddr</span>;</span>   <span class="hljs-comment">// 组播的IP地址</span><br><span class="hljs-comment">/* Local IP address of interface.  */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">imr_interface</span>;</span>   <span class="hljs-comment">// 本地的IP地址</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">in_addr_t</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">in_addr_t</span> s_addr;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="22、本地套接字"><a href="#22、本地套接字" class="headerlink" title="22、本地套接字"></a>22、本地套接字</h4><p>本地套接字的作用：本地的进程间通信 </p><p>有关系的进程间的通信 </p><p>没有关系的进程间的通信 </p><p>本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。</p><img src="/2024/06/02/MyWebServer/%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 本地套接字通信的流程 - tcp</span><br> <span class="hljs-comment">// 服务器端</span><br><span class="hljs-number">1.</span> 创建监听的套接字<br><span class="hljs-type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br> <span class="hljs-comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span><br>bind(lfd, addr, len);<br><span class="hljs-number">3.</span> 监听<br>listen(lfd, <span class="hljs-number">100</span>);<br><span class="hljs-number">4.</span> 等待并接受连接请求<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">cliaddr</span>;</span><br> <span class="hljs-type">int</span> cfd = accept(lfd, &amp;cliaddr, len);<br><span class="hljs-number">5.</span> 通信<br>接收数据：read/recv<br>发送数据：write/send<br><span class="hljs-number">6.</span> 关闭连接<br>close();<br> <br><br><span class="hljs-comment">// 客户端的流程</span><br><span class="hljs-number">1.</span> 创建通信的套接字<br><span class="hljs-type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-number">2.</span> 监听的套接字绑定本地的IP 端口<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br> <span class="hljs-comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span><br>bind(lfd, addr, len);<br><span class="hljs-number">3.</span> 连接服务器<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">serveraddr</span>;</span><br> connect(fd, &amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><span class="hljs-number">4.</span> 通信<br>接收数据：read/recv<br>发送数据：write/send<br><span class="hljs-number">5.</span> 关闭连接<br>close();<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件:  sys/un.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNIX_PATH_MAX 108</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span><br>     <span class="hljs-type">sa_family_t</span> sun_family; <span class="hljs-comment">// 地址族协议 af_local</span><br> <span class="hljs-type">char</span> sun_path[UNIX_PATH_MAX];   <span class="hljs-comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="自己实现WebServer笔记"><a href="#自己实现WebServer笔记" class="headerlink" title="自己实现WebServer笔记"></a>自己实现WebServer笔记</h2><img src="/2024/06/02/MyWebServer/Webserver%E6%A1%86%E6%9E%B6%E5%9B%BE.png" class=""><h3 id="并发框架"><a href="#并发框架" class="headerlink" title="并发框架"></a>并发框架</h3><p>在具体的实现中，最核⼼的部分就是  EventLoop 、  Channel 以及  Poller 三个类，其中  EventLoop 可以看作是对业务线程的封装，⽽  Channel 可以看作是对每 个已经建⽴连接的封装（即  accept(3) 返回的⽂件描述符）</p><h3 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h3><p>日志系统是一个典型的单例模式。</p><p>单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>实现思路：<strong>私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</strong></p><p>单例模式有两种实现方法，分别是懒汉和饿汉模式。</p><p>顾名思义，懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；</p><p>饿汉模式，即迫不及待，在程序运行时立即初始化。</p><h4 id="1、设计模式"><a href="#1、设计模式" class="headerlink" title="1、设计模式"></a>1、设计模式</h4><p>设计模式（Design Patterns）是一套被反复使用、多数人知晓并经过时间验证的解决特定设计问题的典型解决方案。设计模式并不是具体的代码，而是一种对常见问题的抽象解决方案，旨在提高代码的可维护性、复用性和扩展性。设计模式通常可以分为以下三大类：</p><h5 id="1）-创建型模式（Creational-Patterns）"><a href="#1）-创建型模式（Creational-Patterns）" class="headerlink" title="1） 创建型模式（Creational Patterns）"></a>1） <strong>创建型模式（Creational Patterns）</strong></h5><ul><li><strong>工厂方法模式（Factory Method Pattern）</strong>：定义一个创建对象的接口，但让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</li><li><strong>单例模式（Singleton Pattern）</strong>：确保一个类只有一个实例，并提供一个全局访问点来访问它。</li><li><strong>建造者模式（Builder Pattern）</strong>：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype Pattern）</strong>：通过复制现有实例来创建新对象，而不是从零构建实例。</li></ul><h5 id="2）-结构型模式（Structural-Patterns）"><a href="#2）-结构型模式（Structural-Patterns）" class="headerlink" title="2） 结构型模式（Structural Patterns）"></a>2） <strong>结构型模式（Structural Patterns）</strong></h5><ul><li><strong>适配器模式（Adapter Pattern）</strong>：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li><strong>桥接模式（Bridge Pattern）</strong>：将抽象部分与实现部分分离，使它们都可以独立地变化。</li><li><strong>组合模式（Composite Pattern）</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得客户对单个对象和组合对象的使用具有一致性。</li><li><strong>装饰模式（Decorator Pattern）</strong>：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</li><li><strong>外观模式（Facade Pattern）</strong>：为子系统中的一组接口提供一个一致的界面，使得子系统更加容易使用。</li><li><strong>享元模式（Flyweight Pattern）</strong>：运用共享技术来有效地支持大量细粒度的对象。</li><li><strong>代理模式（Proxy Pattern）</strong>：为其他对象提供一个代理以控制对这个对象的访问。</li></ul><h5 id="3）-行为型模式（Behavioral-Patterns）"><a href="#3）-行为型模式（Behavioral-Patterns）" class="headerlink" title="3） 行为型模式（Behavioral Patterns）"></a>3） <strong>行为型模式（Behavioral Patterns）</strong></h5><ul><li><strong>观察者模式（Observer Pattern）</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li><li><strong>策略模式（Strategy Pattern）</strong>：定义一系列算法，将每个算法封装起来，并让它们可以互换使用。策略模式让算法独立于使用它的客户而变化。</li><li><strong>命令模式（Command Pattern）</strong>：将请求封装为对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</li><li><strong>状态模式（State Pattern）</strong>：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li><li><strong>模板方法模式（Template Method Pattern）</strong>：在一个方法中定义一个算法的框架，而将一些步骤的实现延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</li><li><strong>中介者模式（Mediator Pattern）</strong>：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，可以独立地改变它们之间的交互。</li><li><strong>迭代器模式（Iterator Pattern）</strong>：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</li><li><strong>责任链模式（Chain of Responsibility Pattern）</strong>：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</li><li><strong>访问者模式（Visitor Pattern）</strong>：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。</li><li><strong>备忘录模式（Memento Pattern）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li></ul><h4 id="2、虚析构函数"><a href="#2、虚析构函数" class="headerlink" title="2、虚析构函数"></a>2、虚析构函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Log</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Log</span>();<span class="hljs-comment">/////////////////////////////////////////////</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">async_write_log</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        string single_log;<br>        <span class="hljs-comment">//从阻塞队列中取出一个日志string，写入文件</span><br>        <span class="hljs-keyword">while</span> (m_log_queue-&gt;<span class="hljs-built_in">pop</span>(single_log))<br>        &#123;<br>            m_mutex.<span class="hljs-built_in">lock</span>();<br>            <span class="hljs-built_in">fputs</span>(single_log.<span class="hljs-built_in">c_str</span>(), m_fp);<br>            m_mutex.<span class="hljs-built_in">unlock</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>将析构函数声明为虚函数的原因主要涉及继承和多态性。具体来说，声明为虚函数的原因如下：</p><h5 id="1-确保正确的析构顺序"><a href="#1-确保正确的析构顺序" class="headerlink" title="1) 确保正确的析构顺序"></a>1) <strong>确保正确的析构顺序</strong></h5><ul><li>当一个基类的指针或引用指向一个派生类的对象时，如果通过该指针或引用删除对象（例如，<code>delete</code> 一个指向派生类对象的基类指针），析构函数会被调用。</li><li>如果基类的析构函数不是虚函数，调用 <code>delete</code> 时只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致派生类对象的资源（如动态分配的内存、打开的文件、锁等）无法正确释放，造成资源泄漏。</li><li>如果基类的析构函数是虚函数，删除对象时，编译器会根据实际对象的类型（基于虚表机制）调用正确的析构函数，从而确保派生类的析构函数也被调用，确保对象的所有资源都能正确释放。</li></ul><h5 id="2-支持多态性"><a href="#2-支持多态性" class="headerlink" title="2) 支持多态性"></a>2) <strong>支持多态性</strong></h5><ul><li>在具有继承关系的类层次结构中，如果基类的析构函数是虚函数，它可以保证通过基类指针或引用来删除派生类对象时，派生类的析构函数能够正确执行。</li></ul><h5 id="3-避免未定义行为"><a href="#3-避免未定义行为" class="headerlink" title="3) 避免未定义行为"></a>3) <strong>避免未定义行为</strong></h5><ul><li>如果基类析构函数不是虚拟的，但通过基类指针删除派生类对象，这将导致未定义行为。在大多数情况下，这会导致程序崩溃或者资源泄漏。因此，出于安全性考虑，如果一个类打算作为基类被继承，通常会将它的析构函数声明为虚函数</li></ul><p><code>Log</code> 类的析构函数被声明为虚函数，是为了确保在使用多态时（即通过基类指针或引用来操作派生类对象）可以正确调用派生类的析构函数，防止资源泄漏和未定义行为。这是一个良好的设计习惯，尤其是在设计用于继承和扩展的类时。</p><h3 id="HTTP部分"><a href="#HTTP部分" class="headerlink" title="HTTP部分"></a>HTTP部分</h3><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><h3 id="1、srrlen和sizeof的区别"><a href="#1、srrlen和sizeof的区别" class="headerlink" title="1、srrlen和sizeof的区别"></a>1、srrlen和sizeof的区别</h3><p><strong>计算对象不同</strong>:</p><ul><li><code>sizeof</code> 计算任何类型（包括数组和对象）的大小（以字节为单位）。</li><li><code>strlen</code> 只能用于计算以 <code>&#39;\0&#39;</code> 结尾的字符串的长度（以字符为单位）。</li></ul><p><strong>结果的含义不同</strong>:</p><ul><li><code>sizeof</code> 返回数据类型或变量在内存中占用的字节数。</li><li><code>strlen</code> 返回字符串中的字符数，不包括终止符 <code>&#39;\0&#39;</code>。</li></ul><p><strong>包含范围不同</strong>:</p><ul><li><code>sizeof</code> 在处理字符数组时，包含字符串终止符 <code>&#39;\0&#39;</code>。</li><li><code>strlen</code> 仅计算字符串中的实际字符数，不包括终止符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size of str: %lu\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(str));       <span class="hljs-comment">// 输出 4 或 8，取决于系统架构</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Length of str: %lu\n&quot;</span>, <span class="hljs-built_in">strlen</span>(str));<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>sizeof(str)</code> 返回的是指针的大小，而 <code>strlen(str)</code> 返回的是字符串的长度。</p><h3 id="2、c-中没有在类中函数，没有在忘记打public了，函数默认是什么状态的"><a href="#2、c-中没有在类中函数，没有在忘记打public了，函数默认是什么状态的" class="headerlink" title="2、c++中没有在类中函数，没有在忘记打public了，函数默认是什么状态的"></a>2、c++中没有在类中函数，没有在忘记打public了，函数默认是什么状态的</h3><h4 id="1-在-class-定义中："><a href="#1-在-class-定义中：" class="headerlink" title="1)在 class 定义中："></a>1)<strong>在 <code>class</code> 定义中</strong>：</h4><ul><li>如果你在 <code>class</code> 中定义成员函数而没有明确指定访问控制修饰符，则该成员函数的默认访问级别是 <code>private</code>。也就是说，函数只能在类的内部使用，类的外部不能访问</li></ul><h4 id="2-在-struct-定义中："><a href="#2-在-struct-定义中：" class="headerlink" title="2)在 struct 定义中："></a>2)<strong>在 <code>struct</code> 定义中</strong>：</h4><ul><li>如果你在 <code>struct</code> 中定义成员函数而没有明确指定访问控制修饰符，则该成员函数的默认访问级别是 <code>public</code>。也就是说，函数可以在类的外部直接访问。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>class<code>中的默认访问级别是</code>private。      struct<code>中的默认访问级别是</code>public。</p><p>这意味着，在 <code>class</code> 中，未指定访问控制的成员函数和数据成员只能被类的内部成员（如其他成员函数）访问，而在 <code>struct</code> 中，未指定访问控制的成员函数和数据成员可以在类外部直接访问。</p><h4 id="struct-和Class的区别"><a href="#struct-和Class的区别" class="headerlink" title="struct 和Class的区别"></a>struct 和Class的区别</h4><ul><li>通常，struct用来表示一组相关的数据，而class用于表示一个封装了数据和操作的对象，在实际使用中，可以根据具体的需求选择使用struct和class。如果只是用来组织一些数据，而不涉及复杂的封装和继承关系，struct可能更直观；如果需要进行封装、继承等面向对象编程的特性，可以选择使用class。</li><li>struct结构体中的成员默认是共有的（public），类中的成员默认是私有的（private）</li><li>struct继承时默认使用公有继承。class继承时默认使用私有继承</li><li>如果结构体没有定义任何构造函数，编译器会生成默认的无参数构造函数。如果类没有定义任何构造函数，编译器也会生成默认的无参数构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用 struct 定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Mystruct</span>&#123;<br><span class="hljs-type">int</span> x;  <span class="hljs-comment">// 默认时public</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Struct method&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 使用Class 定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<span class="hljs-comment">// 如果忽略， 默认时private</span><br><span class="hljs-type">int</span> y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Class method&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3、-include-和-include-string-有什么区别"><a href="#3、-include-和-include-string-有什么区别" class="headerlink" title="3、#include &lt;string.h&gt;和#include  &lt; string &gt;有什么区别"></a>3、#include &lt;string.h&gt;和#include  &lt; string &gt;有什么区别</h3><p><code>#include &lt;string.h&gt;</code> 和 <code>#include &lt;string&gt;</code> 是用于包含不同头文件的指令，它们之间的主要区别在于它们属于不同的编程语言和提供的功能不同。</p><h4 id="1-include"><a href="#1-include" class="headerlink" title="1. #include &lt;string.h&gt;"></a>1. <strong><code>#include &lt;string.h&gt;</code></strong></h4><ul><li><strong>语言</strong>：C 和 C++</li><li><strong>头文件内容</strong>：<code>&lt;string.h&gt;</code> 是C语言的标准库头文件，主要提供了一组用于处理C风格字符串的函数。这些字符串是以 <code>char</code> 数组形式存储的，以 <code>\0</code>（空字符）作为字符串的结束标志。</li><li><strong>常用函数</strong>：<ul><li><code>strlen(const char* str)</code>: 计算字符串的长度，不包括结尾的 <code>\0</code>。</li><li><code>strcpy(char* dest, const char* src)</code>: 复制字符串 <code>src</code> 到 <code>dest</code>。</li><li><code>strncpy(char* dest, const char* src, size_t n)</code>: 将最多 <code>n</code> 个字符从 <code>src</code> 复制到 <code>dest</code>。</li><li><code>strcat(char* dest, const char* src)</code>: 将 <code>src</code> 字符串追加到 <code>dest</code> 字符串的末尾。</li><li><code>strcmp(const char* str1, const char* str2)</code>: 比较两个字符串的内容。</li><li><code>memset(void* ptr, int value, size_t num)</code>: 将指定内存区域 <code>ptr</code> 中的前 <code>num</code> 个字节设置为 <code>value</code>。</li><li><code>memcpy(void* dest, const void* src, size_t num)</code>: 复制 <code>num</code> 个字节的数据从 <code>src</code> 到 <code>dest</code>。</li></ul></li><li><strong>使用场景</strong>：<ul><li>在需要处理C风格字符串（如 <code>char</code> 数组）时使用。</li><li>常用于低级别的字符串操作或在需要与C代码兼容的C++程序中。</li></ul></li></ul><h4 id="2-include"><a href="#2-include" class="headerlink" title="2. #include &lt;string&gt;"></a>2. <strong><code>#include &lt;string&gt;</code></strong></h4><ul><li><p><strong>语言</strong>：C++（C++标准库）</p></li><li><p><strong>头文件内容</strong>：<code>&lt;string&gt;</code> 是C++标准库头文件，提供了一个专门用于处理字符串的 <code>std::string</code> 类。<code>std::string</code> 是C++中的字符串类，封装了字符串的管理，并提供了丰富的成员函数来处理字符串操作。</p></li><li><p><strong>常用功能</strong>：</p><ul><li><p>成员函数</p><p>：</p><ul><li><code>std::string::length() / size()</code>: 获取字符串的长度。</li><li><code>std::string::append(const std::string&amp; str)</code>: 追加字符串 <code>str</code> 到当前字符串末尾。</li><li><code>std::string::substr(size_t pos, size_t len)</code>: 返回从 <code>pos</code> 开始长度为 <code>len</code> 的子字符串。</li><li><code>std::string::find(const std::string&amp; str)</code>: 查找子字符串 <code>str</code> 在当前字符串中的位置。</li><li><code>std::string::replace(size_t pos, size_t len, const std::string&amp; str)</code>: 用字符串 <code>str</code> 替换从 <code>pos</code> 开始长度为 <code>len</code> 的部分。</li><li><code>std::string::c_str()</code>: 返回指向C风格字符串的指针（<code>const char*</code>），用于与C风格函数兼容。</li></ul></li><li><p>运算符重载</p><p>：</p><ul><li><code>+</code>：字符串连接。</li><li><code>==</code>、<code>!=</code>：比较两个字符串是否相等。</li></ul></li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>在C++程序中，使用 <code>std::string</code> 提供的高级字符串操作，而不需要手动管理内存或处理字符串末尾的 <code>\0</code>。</li><li>提供了更安全、简洁的字符串操作，是C++开发中处理字符串的首选工具。</li></ul></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><strong><code>#include &lt;string.h&gt;</code></strong> 是C标准库中的头文件，主要用于处理C风格的 <code>char</code> 数组字符串，提供了一些基本的字符串操作函数。</li><li><strong><code>#include &lt;string&gt;</code></strong> 是C++标准库中的头文件，提供了功能强大的 <code>std::string</code> 类，能够方便、安全地处理字符串，避免了手动管理字符串内存和处理C风格字符串常见的问题。</li></ul><p>在C++开发中，优先使用 <code>std::string</code>（即 <code>#include &lt;string&gt;</code>），因为它更符合面向对象编程的思想，操作更加简单和安全。如果需要与C代码兼容或处理低级别的字符串操作，才会使用 <code>#include &lt;string.h&gt;</code>。</p><h3 id="4、man手册使用"><a href="#4、man手册使用" class="headerlink" title="4、man手册使用"></a>4、man手册使用</h3><p><code>man</code> 命令是Linux和Unix系统中用于查看命令或函数的手册页（manual pages）的工具。它可以帮助你快速了解某个命令、系统调用、库函数、配置文件等的用法和详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">基本用法<br>man [section] name<br>section：可选参数，指定手册页的章节号（详见下文）。<br>name：必需参数，指定你要查询的命令、系统调用、库函数、配置文件等的名称。<br></code></pre></td></tr></table></figure><h4 id="常见的-man-手册页章节"><a href="#常见的-man-手册页章节" class="headerlink" title="常见的 man 手册页章节"></a>常见的 <code>man</code> 手册页章节</h4><p><code>man</code> 手册页分为不同的章节，每个章节包含不同类型的信息。常见的章节包括：</p><ol><li><strong>用户命令</strong>：通常是你在终端中运行的命令（如 <code>ls</code>, <code>cd</code>）。</li><li><strong>系统调用</strong>：由内核提供的函数（如 <code>open</code>, <code>read</code>）。</li><li><strong>库函数</strong>：C标准库函数（如 <code>printf</code>, <code>malloc</code>）。</li><li><strong>设备文件和特殊文件</strong>：通常在 <code>/dev</code> 下找到的设备文件。</li><li><strong>文件格式</strong>：文件格式和协议（如 <code>/etc/passwd</code>）。</li><li><strong>游戏</strong>：游戏和其他杂项（很少使用）。</li><li><strong>杂项</strong>：杂项（如 <code>man</code>、<code>groff</code> 等）。</li><li><strong>系统管理命令</strong>：通常只有管理员可以使用的命令（如 <code>ifconfig</code>, <code>iptables</code>）。</li><li><strong>内核例程</strong>：与内核相关的例程和接口。</li></ol><h3 id="5、枚举类的作用"><a href="#5、枚举类的作用" class="headerlink" title="5、枚举类的作用"></a>5、枚举类的作用</h3><p>枚举类（枚举类型）的作用是为一组相关的常量赋予有意义的名称，从而提高代码的可读性、可维护性和安全性。具体作用如下：</p><h4 id="1-可读性和可维护性："><a href="#1-可读性和可维护性：" class="headerlink" title="1. 可读性和可维护性："></a>1. <strong>可读性和可维护性</strong>：</h4><p>枚举类为一组相关的值（常量）提供了清晰的语义。例如，直接使用数字 <code>0</code>、<code>1</code> 来表示HTTP请求中的 <code>GET</code> 和 <code>POST</code> 方法，可能导致代码不易理解；而使用枚举类 <code>METHOD::GET</code> 和 <code>METHOD::POST</code> 能让人一眼就明白其含义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">METHOD</span> &#123;<br>    GET = <span class="hljs-number">0</span>,<br>    POST = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-防止魔法数字："><a href="#2-防止魔法数字：" class="headerlink" title="2. 防止魔法数字："></a>2. <strong>防止魔法数字</strong>：</h4><p>枚举类避免了在代码中使用“魔法数字”（magic numbers），即没有明确含义的常量数字。例如，直接使用 <code>0</code>、<code>1</code> 等作为状态值，可能会让代码变得难以理解；使用枚举可以提供清晰的语义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">HTTP_CODE</span> &#123;<br>    NO_REQUEST = <span class="hljs-number">0</span>,<br>    GET_REQUEST,<br>    BAD_REQUEST<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-类型安全："><a href="#3-类型安全：" class="headerlink" title="3. 类型安全："></a>3. <strong>类型安全</strong>：</h4><p>枚举类是一种强类型，能够防止无关的值被赋予相关变量。例如，如果定义了枚举类 <code>METHOD</code>，那么只能将 <code>METHOD</code> 中定义的值赋给该类型的变量，而不会错误地传递无关的数字或其他枚举类型的值，从而提高了代码的安全性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cpp复制代码METHOD method = METHOD::GET;<br><span class="hljs-comment">// method 只能是枚举类METHOD中的值，不能是其他任意的整数</span><br></code></pre></td></tr></table></figure><h4 id="4-易于调试："><a href="#4-易于调试：" class="headerlink" title="4. 易于调试："></a>4. <strong>易于调试</strong>：</h4><p>当代码中使用枚举类时，调试时可以轻松看到相关变量的含义，而不是仅仅看到一些数字。这使得调试过程中能够更快地理解程序的状态和问题。</p><h4 id="5-范围限制："><a href="#5-范围限制：" class="headerlink" title="5. 范围限制："></a>5. <strong>范围限制</strong>：</h4><p>枚举类型限制了可能的取值范围。例如，在 <code>HTTP_CODE</code> 枚举中，状态只能是 <code>NO_REQUEST</code>、<code>GET_REQUEST</code>、<code>BAD_REQUEST</code> 等定义的值。这样可以避免程序中出现非法状态。</p><h4 id="6-方便条件判断："><a href="#6-方便条件判断：" class="headerlink" title="6. 方便条件判断："></a>6. <strong>方便条件判断</strong>：</h4><p>枚举可以直接用于条件判断和 <code>switch</code> 语句中，简化代码逻辑。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">cpp复制代码<span class="hljs-keyword">switch</span>(method) &#123;<br>    <span class="hljs-keyword">case</span> METHOD::GET:<br>        <span class="hljs-comment">// 处理GET请求</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD::POST:<br>        <span class="hljs-comment">// 处理POST请求</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用枚举类型，可以让条件判断更清晰易懂，且减少了人为错误的可能性。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>枚举类的主要作用是为一组相关的常量提供有意义的名称，使代码更具可读性、可维护性，并提升类型安全性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode和Git的使用</title>
    <link href="/2024/06/01/Vscode%E5%92%8CGit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/01/Vscode%E5%92%8CGit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用Vscode和github完成代码版本控制"><a href="#如何使用Vscode和github完成代码版本控制" class="headerlink" title="如何使用Vscode和github完成代码版本控制"></a>如何使用Vscode和github完成代码版本控制</h1><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><p>参考内容：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304">廖雪峰git教程</a></p><h3 id="1、创建本地版本库"><a href="#1、创建本地版本库" class="headerlink" title="1、创建本地版本库"></a>1、创建本地版本库</h3><h4 id="1）选择合适的地方，创建一个空目录，并进入目录"><a href="#1）选择合适的地方，创建一个空目录，并进入目录" class="headerlink" title="1）选择合适的地方，创建一个空目录，并进入目录"></a>1）选择合适的地方，创建一个空目录，并进入目录</h4><p>win系统下最好不包括中文目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> MyWebServer</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> MyWebServer</span><br></code></pre></td></tr></table></figure><h4 id="2）将目录变成git可以管理的仓库"><a href="#2）将目录变成git可以管理的仓库" class="headerlink" title="2）将目录变成git可以管理的仓库"></a>2）将目录变成git可以管理的仓库</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ git <span class="hljs-keyword">init</span><br><span class="hljs-type">Initialized</span> empty <span class="hljs-type">Git</span> repository <span class="hljs-keyword">in</span> <span class="hljs-type">E</span>:<span class="hljs-regexp">/MyGit/</span><span class="hljs-type">MyWebServer</span><span class="hljs-regexp">/.git/</span><br><br>ls <span class="hljs-operator">-</span>ah<span class="hljs-comment">// Linux下可以看见隐藏的文件</span><br></code></pre></td></tr></table></figure><p>此时会生成一个 <strong>.git</strong> 文件，是 Git 用来跟踪管理版本的</p><h4 id="3）把文件添加到版本库"><a href="#3）把文件添加到版本库" class="headerlink" title="3）把文件添加到版本库"></a>3）把文件添加到版本库</h4><p>在<strong>新建的目录下</strong>，新建一个 <strong>readme.md</strong> 文件，文件内写上（不要用win自带的文本编辑器打开编写）：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mercury">Git <span class="hljs-keyword">is</span> a version control system.<br>Git <span class="hljs-keyword">is</span> free software.<br></code></pre></td></tr></table></figure><p>使用 <strong>Git</strong> 命令 把文件添加到仓库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 第一步，添加文件到仓库</span><br>$ git add readme<span class="hljs-selector-class">.md</span><br><br><span class="hljs-comment">// 第二步，将文件提交到仓库</span><br>$ git commit -m <span class="hljs-string">&quot;添加本次仓库测试的文档&quot;</span><br><br><span class="hljs-selector-attr">[main (root-commit) 8d1a06f]</span> 添加本次仓库测试的文档<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">0</span> <span class="hljs-built_in">insertions</span>(+), <span class="hljs-number">0</span> <span class="hljs-built_in">deletions</span>(-)<br> create mode <span class="hljs-number">100644</span> readme<span class="hljs-selector-class">.md</span><br><br></code></pre></td></tr></table></figure><p><strong>git commit -m “添加本次仓库测试的文档”</strong> 命令，**-m** 后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><h3 id="2、添加远程库"><a href="#2、添加远程库" class="headerlink" title="2、添加远程库"></a>2、添加远程库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><h4 id="1）在GitHub上创建一个新的仓库"><a href="#1）在GitHub上创建一个新的仓库" class="headerlink" title="1）在GitHub上创建一个新的仓库"></a>1）在GitHub上创建一个新的仓库</h4><p>图形化操作</p><h4 id="2）绑定远程仓库"><a href="#2）绑定远程仓库" class="headerlink" title="2）绑定远程仓库"></a>2）绑定远程仓库</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用命令下面命令绑定远程库      git remote add [远端仓库别名] [远端仓库地址]</span><br>$ git remote add MyWebServer_origin git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:zy674517173/MyWebServer_origin.git<br></code></pre></td></tr></table></figure><h4 id="3）把本地库的内容推送到远程库"><a href="#3）把本地库的内容推送到远程库" class="headerlink" title="3）把本地库的内容推送到远程库"></a>3）把本地库的内容推送到远程库</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 使用命令下面命令推送      git push -u [远端仓库别名] [推送的位置]</span><br>$ git push -u <span class="hljs-type">MyWebServer_origin</span> main<br><br><span class="hljs-type">Enumerating</span> objects: <span class="hljs-number">5</span>, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Counting</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Delta</span> compression using up <span class="hljs-keyword">to</span> <span class="hljs-number">12</span> threads<br><span class="hljs-type">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">2</span>/<span class="hljs-number">2</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">4</span>/<span class="hljs-number">4</span>), <span class="hljs-number">384</span> <span class="hljs-built_in">bytes</span> | <span class="hljs-number">384.00</span> <span class="hljs-type">KiB</span>/s, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Total</span> <span class="hljs-number">4</span> (delta <span class="hljs-number">1</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">0</span> (from <span class="hljs-number">0</span>)<br>remote: <span class="hljs-type">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">1</span>/<span class="hljs-number">1</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">To</span> github.com:zy674517173/<span class="hljs-type">MyWebServer_origin</span>.git<br>   af59730..<span class="hljs-number">5</span>aa9a4d  main -&gt; main<br>branch <span class="hljs-symbol">&#x27;main&#x27;</span> set up <span class="hljs-keyword">to</span> track <span class="hljs-symbol">&#x27;MyWebServer_origin</span>/main&#x27;.<br></code></pre></td></tr></table></figure><p><strong>报错</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">error: failed <span class="hljs-built_in">to</span> push some refs <span class="hljs-built_in">to</span> <span class="hljs-string">&#x27;github.com:zy674517173/MyWebServer_origin.git&#x27;</span><br>hint: Updates were rejected because <span class="hljs-keyword">the</span> remote <span class="hljs-keyword">contains</span> work that you <span class="hljs-built_in">do</span> <span class="hljs-keyword">not</span><br>hint: have locally. This is usually caused <span class="hljs-keyword">by</span> another repository pushing <span class="hljs-built_in">to</span><br>hint: <span class="hljs-keyword">the</span> same ref. If you want <span class="hljs-built_in">to</span> integrate <span class="hljs-keyword">the</span> remote changes, use<br>hint: <span class="hljs-string">&#x27;git pull&#x27;</span> <span class="hljs-keyword">before</span> pushing again.<br>hint: See <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br><br>解决方案<br>将仓库里的 README.md 文件删除，然后执行命令<br>$ git pull MyWebServer_origin main <span class="hljs-comment">--allow-unrelated-histories   // 从远端仓库拉取，同步本地</span><br></code></pre></td></tr></table></figure><h4 id="4）后续"><a href="#4）后续" class="headerlink" title="4）后续"></a>4）后续</h4><p>从现在开始，本地做了提交，就可以通过命令</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> MyWebServer_origin main<br></code></pre></td></tr></table></figure><p>把本地的 <strong>main</strong> 分支的最新修改推送至 GitHub 。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code> 是默认习惯命名；</p><p>关联后，使用命令 <strong>git push -u origin master</strong> 第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令 <strong>git push origin master</strong> 推送最新修改；</p><h4 id="5）删除远程库"><a href="#5）删除远程库" class="headerlink" title="5）删除远程库"></a>5）删除远程库</h4><h5 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h5><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用 <strong>git remote rm [name]</strong> 命令。使用前，建议先用 <strong>git remote -v</strong> 查看远程库的信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>MyWebServer_origin      git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:zy674517173/MyWebServer_origin.git (fetch)<br>MyWebServer_origin      git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:zy674517173/MyWebServer_origin.git (push)<br></code></pre></td></tr></table></figure><p>然后根据名字删除，比如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> MyWebServer_origin<br></code></pre></td></tr></table></figure><h2 id="VsCode内使用Git版本控制"><a href="#VsCode内使用Git版本控制" class="headerlink" title="VsCode内使用Git版本控制"></a>VsCode内使用Git版本控制</h2><p>在VsCode中打开本地仓库，然后点击版本控制，如果提示 <strong>未找到Git。请安装Git，或在git.path设置中配置</strong></p><p>配置过程：设置 —&gt; 在搜索框输入 <code>git.path</code> —&gt; settings.json 中编辑</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// win系统</span><br><span class="hljs-string">&quot;git.path&quot;</span>: <span class="hljs-string">&quot;E:<span class="hljs-subst">\\</span>Program Files<span class="hljs-subst">\\</span>Git<span class="hljs-subst">\\</span>bin<span class="hljs-subst">\\</span>git.exe&quot;</span><br><br><span class="hljs-comment">// linux系统</span><br><span class="hljs-string">&quot;git.path&quot;</span>: <span class="hljs-string">&quot;/Program Files/Git/bin/git.exe&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>General</title>
    <link href="/2024/05/31/General/"/>
    <url>/2024/05/31/General/</url>
    
    <content type="html"><![CDATA[<h1 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h1><p>hexo官方网站：[<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/31/hello-world/"/>
    <url>/2024/05/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远端网址"><a href="#部署到远端网址" class="headerlink" title="部署到远端网址"></a>部署到远端网址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="Hexo三连"><a href="#Hexo三连" class="headerlink" title="Hexo三连"></a>Hexo三连</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Hexo遇到的问题"><a href="#Hexo遇到的问题" class="headerlink" title="Hexo遇到的问题"></a>Hexo遇到的问题</h2><h3 id="1、部署到GitHub后不能显示主题，只有文字"><a href="#1、部署到GitHub后不能显示主题，只有文字" class="headerlink" title="1、部署到GitHub后不能显示主题，只有文字"></a>1、部署到GitHub后不能显示主题，只有文字</h3><p><strong>原因：</strong> </p><p>1、GitHub 上的博客搭建到了仓库里，也就是博客跟地址是<a href="https://xxx.github.io/">https://XXX.github.io/</a><repository_name>上，而不是根目录<a href="https://xxx.github.io/%E4%B8%AD">https://XXX.github.io/中</a></p><p>2.由于主题中的各种图片、js脚本都是默认根路径的</p><p><strong>如何修改：</strong> 将Hexo的 <code>config.yml</code> 中的 <code>url</code> 改为根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 原来是 url: https://zy674517173.github.io/archive<br>url: https://zy674517173.github.io<br></code></pre></td></tr></table></figure><h3 id="2、如何在Hexo中插入图片"><a href="#2、如何在Hexo中插入图片" class="headerlink" title="2、如何在Hexo中插入图片"></a>2、如何在Hexo中插入图片</h3><p>最简单的方法是安装 hexo-image-link 插件，<a href="http://home.ustc.edu.cn/~sdyzzy/posts/36e27ee1.html">参考博客</a></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">cnpm install hexo-<span class="hljs-built_in">image</span>-link --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
