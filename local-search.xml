<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux基础知识</title>
    <link href="/2024/08/05/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/08/05/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*********************************** 终端 *********************************** */</span><br>pwd<span class="hljs-comment">// 显示当前路径</span><br>rmdir   <span class="hljs-comment">// 删除空目录rm -rf 目录名</span><br>mkdir<span class="hljs-comment">// 创建文件夹</span><br>ls/ll<span class="hljs-comment">// 查看目录或文件信息-l 列出详细信息-a列出当前目录下的所有文件</span><br>vi<span class="hljs-comment">// 文本编辑器</span><br>i 进入编辑状态ESC 退出编辑:q! 不保存退出:wq 保存退出G 定位到文件末尾<br>cp<span class="hljs-comment">// 复制cp [选项] 文件名或目录 目标地址-R全部目录和文件</span><br>cp a.txt b.txt 将文件a复制并命令为b文件<br>mv<span class="hljs-comment">// 移动mv 文件名或目录 目标目录</span><br>rm<span class="hljs-comment">// 删除文件或目录-f 强制删除 -r 删除目录</span><br>grep<span class="hljs-comment">// 分析一行的信息，如果存在所需信息，打印输出 grep 字符串 文件名(grep band file)</span><br>find <span class="hljs-comment">// 查找文件find [路径] [选项]find . -name *log 在当前目录查找以.log结尾的文件</span><br>ps <span class="hljs-comment">// 查看进程（动态）-ef 显示所有运行进程，并显示启动进程的命令</span><br>netstat<span class="hljs-comment">// 查看网络状况（net status的简写）</span><br>netstat -apn 查看所有端口 -an 按一定顺序排列输出p 表示显示那个进程在调用<br>|<span class="hljs-comment">// 管道符在命令之间建立管道，将前面命令的输出作为后面命令的输入</span><br>通过命令查找tomcat进程：ps -ef | grep tomcat <br>通过命令查找到占用此端口的进程编号：netstat -apn|grep <span class="hljs-number">8080</span><br>touch <span class="hljs-comment">// 创建一个空白文件-a 修改access(访问) 时间-m 修改modfiy(修改)时间</span><br>su<span class="hljs-comment">// 切换用户su root</span><br>chmod<span class="hljs-comment">// 权限赋予命令 -R 递归改变目录下所有子目录和文件的权限(可读可写可执行) r=4 w=2 x=1</span><br>chmod <span class="hljs-number">777</span> lemon<br>tar<span class="hljs-comment">// 解压,压缩</span><br>tar -czvf test.tar.gz test将test压缩 tar -xzvf test.tar.gz解压tast<br><br>which <span class="hljs-comment">// 查找文件、显示命令路径which pwd</span><br>whereis <span class="hljs-comment">// 定位可执行文件、帮助文件和原文件代码在系统中的位置</span><br>whereis [选项] [路径/目录名 -f] 文件名<br><br>cat <span class="hljs-comment">// 显示文本文件内容cat 文件名字</span><br>head <span class="hljs-comment">// 查看前几行head -n 5 文件名字</span><br>tail<span class="hljs-comment">// 从指定点开始将文件写到标准输出tail -n 5 文件名     查看后几行 tail -f</span><br>echo <span class="hljs-comment">// 打印文件内容或编辑文件内容</span><br>uname<span class="hljs-comment">// 查看系统-m 查看系统是几位操作系统 -r 查看系统的内核版本 -a 查看详细的系统内核版本和系统的操作系统</span><br>rz<span class="hljs-comment">// 上传</span><br>sz<span class="hljs-comment">// 下载</span><br>history<span class="hljs-comment">// 查看命令历史记录</span><br>ssh 用户名@ip地址:<span class="hljs-number">22</span>  <span class="hljs-comment">// ssh连接远程服务器   ssh zy@192.168.130.111:22</span><br>        <br><span class="hljs-comment">/*********************************** 线程相关 *********************************** */</span><br>ps –Lf pid   <span class="hljs-comment">// 查看指定进程的 LWP 号</span><br>        <span class="hljs-comment">// 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC使用</title>
    <link href="/2024/08/01/GCC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/08/01/GCC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GCC使用"><a href="#GCC使用" class="headerlink" title="GCC使用"></a>GCC使用</h1><p><a href="https://blog.csdn.net/qq_42037383/article/details/140217436">原文链接</a></p><p> GCC（GUN Compiler Collection）是一个开源的编译器套件，支持多种编程语言，包括 C、C++、Objective-C、Fortran、Ada 等。它是 Linux 和许多 Unix-like 系统中的默认编译器，也可以在 Windows 等平台上使用。</p><h2 id="GCC的基本用法"><a href="#GCC的基本用法" class="headerlink" title="GCC的基本用法"></a>GCC的基本用法</h2><h3 id="1、编译-C-程序"><a href="#1、编译-C-程序" class="headerlink" title="1、编译 C 程序"></a>1、编译 C 程序</h3><p>gcc编译器将c源文件到生成一个可执行程序，中间一共经历了四个步骤：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">                     c文件                 汇编文件          二进制文件      可执行文件<br><span class="hljs-function"><span class="hljs-title">hello</span>.c   ---&gt;</span>      <span class="hljs-function"><span class="hljs-title">hello</span>.i     ---&gt;</span>      <span class="hljs-function"><span class="hljs-title">hello</span>.s   ---&gt;</span>   <span class="hljs-function"><span class="hljs-title">hello</span>.o  ---&gt;</span>   a.out<br>         预处理（CPP）         编译器（gcc）          汇编器(<span class="hljs-keyword">as</span>)       链接器(ld)<br>         gcc -E                gcc -S                 gcc -c           gcc<br></code></pre></td></tr></table></figure><p>下面以hello.c为例介绍gcc的四个步骤:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E hello.c -o hello.i <span class="hljs-comment"># -E激活预处理，生成预处理后的文件</span><br>gcc -S hello.i -o hello.s <span class="hljs-comment"># —S激活预处理和编译，生成汇编代码</span><br>gcc -c hello.s -o hello.o <span class="hljs-comment"># -c激活预处理、编译和汇编，生成目标文件</span><br>gcc hello.o -o hello <span class="hljs-comment"># 执行所有阶段，生成可执行程序</span><br></code></pre></td></tr></table></figure><p>其实没必要指定每一个步骤，我们常常会这样用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c hello.c <span class="hljs-comment"># 生成目标文件，gcc会根据文件名hello.c生成hello.o</span><br>gcc hello.o -o hello <span class="hljs-comment"># 生成可执行程序hello，这里我们需要指定可执行程序的名称，否则会默认生成a.out</span><br></code></pre></td></tr></table></figure><p>一步生成最终的可执行程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc hello.c -o hello <span class="hljs-comment"># 编译链接，生成可执行程序hello</span><br></code></pre></td></tr></table></figure><h3 id="2、GCC常用参数选项"><a href="#2、GCC常用参数选项" class="headerlink" title="2、GCC常用参数选项"></a>2、GCC常用参数选项</h3><table><thead><tr><th align="center"><strong>gcc编译选项</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">-E</td><td align="center">预处理指定的源文件，不进行编译</td></tr><tr><td align="center">-S</td><td align="center">编译指定的源文件，但是不进行汇编</td></tr><tr><td align="center">-C</td><td align="center">编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td align="center">-o [file1] [file2] &#x2F; [file2] -o [file1]</td><td align="center">将文件 file2 编译成可执行文件 file1</td></tr><tr><td align="center">-I directory</td><td align="center">指定include包含文件的搜索目录</td></tr><tr><td align="center">-g</td><td align="center">在编译的时候生成调试信息，该程序可以被调试器调试</td></tr><tr><td align="center">-D</td><td align="center">在程序编译的时候，指定一个宏</td></tr><tr><td align="center">-w</td><td align="center">不生成任何警告信息</td></tr><tr><td align="center">-Wall</td><td align="center">生成所有警告信息</td></tr><tr><td align="center">-On</td><td align="center">n的取值范围：0~3，编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td align="center">-l</td><td align="center">在程序编译时，指定使用的库</td></tr><tr><td align="center">-L</td><td align="center">指定编译的时候，搜索的库的路径</td></tr><tr><td align="center">-fPIC&#x2F;fpic</td><td align="center">生成与位置无关的代码</td></tr><tr><td align="center">-shared</td><td align="center">生成共享目标文件，通常用在建立共享库</td></tr><tr><td align="center">-std</td><td align="center">指定c方法，如：-std&#x3D;c99，gcc默认的方言时GNU C</td></tr></tbody></table><h2 id="GDB使用"><a href="#GDB使用" class="headerlink" title="GDB使用"></a>GDB使用</h2><h3 id="1、什么时GDB"><a href="#1、什么时GDB" class="headerlink" title="1、什么时GDB"></a>1、什么时GDB</h3><p> GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</p><p> 一般来说，GDB 主要帮助你完成下面四个方面的功能：</p><ul><li>启动程序，可以按照自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时程序中所发生的事</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG</li></ul><h3 id="2、怎么使用GDB"><a href="#2、怎么使用GDB" class="headerlink" title="2、怎么使用GDB"></a>2、怎么使用GDB</h3><p>通常，在为调试而编译时，我们会（）关掉编译器的优化选项（ -O ）， 并打开调试选项（ -g ）。 另外， -Wall 在尽量不影响程序行为的情况下选项打开所有 warning，也可以发现许多问题，避免 一些不必要的 BUG。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -Wall program.c -o program<br>gcc test.c -o <span class="hljs-built_in">test</span> -g<br></code></pre></td></tr></table></figure><p>-g 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代 码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</p><h3 id="3、GDB的命令"><a href="#3、GDB的命令" class="headerlink" title="3、GDB的命令"></a>3、GDB的命令</h3><table><thead><tr><th align="center">功能</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">启动<br />退出</td><td align="center">gdb 可执行程序<br />quit&#x2F;q</td></tr><tr><td align="center">给程序设置参数&#x2F;获取设置参数</td><td align="center">set args 10 20  &#x2F;   show args</td></tr><tr><td align="center">GDB使用帮助</td><td align="center">help</td></tr><tr><td align="center">查看当前文件代码</td><td align="center">list&#x2F;l  (从默认位置显示)<br />list&#x2F;l 行号  (从指定的行显示)<br />list&#x2F;l  函数名  （从指定的函数显示）</td></tr><tr><td align="center">查看非当前文件代码</td><td align="center">list&#x2F;l  文件名:行号&#x2F;函数名</td></tr><tr><td align="center">设置显示行数</td><td align="center">show list&#x2F;listsize<br />set list&#x2F;listsize 行数</td></tr><tr><td align="center">设置断点</td><td align="center">b&#x2F;break 行号<br />b&#x2F;break 函数名<br />b&#x2F;break 文件名:行号<br />b&#x2F;break 文件名:函数</td></tr><tr><td align="center">查看断点</td><td align="center">i&#x2F;info b&#x2F;break</td></tr><tr><td align="center">删除断点</td><td align="center">d&#x2F;del&#x2F;delete 断点编号</td></tr><tr><td align="center">设置断点无效</td><td align="center">dis&#x2F;disable 断点编号</td></tr><tr><td align="center">设置断点生效</td><td align="center">ena&#x2F;enable 断点编号</td></tr><tr><td align="center">设置条件断点（一般用在循环的位置）</td><td align="center">b&#x2F;break 10 if i&#x3D;&#x3D;5</td></tr><tr><td align="center">运行GDB程序</td><td align="center">start (程序停在第一行)<br />run (遇到断点才停)</td></tr><tr><td align="center">继续运行，到下一个断点</td><td align="center">c&#x2F;continue</td></tr><tr><td align="center">向下执行一行代码，不会进入函数体</td><td align="center">n&#x2F;next</td></tr><tr><td align="center">变量操作</td><td align="center">p&#x2F;print 变量名 （打印变量值）<br />ptype 变量名 （打印变量类型）</td></tr><tr><td align="center">向下单步调试（遇到函数进入函数体）</td><td align="center">s&#x2F;step<br />finish (跳出函数体)</td></tr><tr><td align="center">自动变量操作</td><td align="center">display 变量名<br />i&#x2F;info display<br />undisplay 编号</td></tr><tr><td align="center">其他操作</td><td align="center">set var 变量名&#x3D;变量值<br />until （跳出循环）</td></tr></tbody></table><h3 id="4、GDB多进程调试"><a href="#4、GDB多进程调试" class="headerlink" title="4、GDB多进程调试"></a>4、GDB多进程调试</h3><p>使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">设置调试父进程或者子进程<br><span class="hljs-built_in">set</span> follow-fork-mode [parent (默认) | child]<br><br>设置调试模式<br><span class="hljs-built_in">set</span> detach-on-fork [on | off]<br>默认为 on， 表示当前进程的时候，其他的进程继续运行，如果为off，调试当前进程的时候，其他进程被GDB挂起<br><br>查看当前调试的进程：  info inferiors<br>切换当前调试的进程： inferior <span class="hljs-built_in">id</span><br>使进程脱离GDB调试： detach inferiors <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex使用</title>
    <link href="/2024/07/12/Latex%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/12/Latex%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Latex使用"><a href="#Latex使用" class="headerlink" title="Latex使用"></a>Latex使用</h1><h2 id="1、如何在Overleaf中采用快速引用参考文献"><a href="#1、如何在Overleaf中采用快速引用参考文献" class="headerlink" title="1、如何在Overleaf中采用快速引用参考文献"></a>1、如何在Overleaf中采用快速引用参考文献</h2><p><a href="https://blog.csdn.net/qq_35831906/article/details/132767074">原文链接</a></p><h3 id="原来的参考文献格式"><a href="#原来的参考文献格式" class="headerlink" title="原来的参考文献格式"></a>原来的参考文献格式</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;thebibliography&#125;&#123;00&#125;<br><span class="hljs-keyword">\bibliography</span>&#123;references&#125;<br><span class="hljs-keyword">\bibitem</span>&#123;b1&#125; G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,&#x27;&#x27; Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.<br><span class="hljs-keyword">\bibitem</span>&#123;b2&#125; J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.<br><span class="hljs-keyword">\bibitem</span>&#123;b3&#125; I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,&#x27;&#x27; in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.<br><span class="hljs-keyword">\bibitem</span>&#123;b4&#125; K. Elissa, ``Title of paper if known,&#x27;&#x27; unpublished.<br><span class="hljs-keyword">\bibitem</span>&#123;b5&#125; R. Nicole, ``Title of paper with only first word capitalized,&#x27;&#x27; J. Name Stand. Abbrev., in press.<br><span class="hljs-keyword">\bibitem</span>&#123;b6&#125; Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,&#x27;&#x27; IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].<br><span class="hljs-keyword">\bibitem</span>&#123;b7&#125; M. Young, The Technical Writer&#x27;s Handbook. Mill Valley, CA: University Science, 1989.<br><span class="hljs-keyword">\end</span>&#123;thebibliography&#125;<br><br></code></pre></td></tr></table></figure><h3 id="新的快速参考方式"><a href="#新的快速参考方式" class="headerlink" title="新的快速参考方式"></a>新的快速参考方式</h3><h3 id="1-1-创建或导入-bib-文件"><a href="#1-1-创建或导入-bib-文件" class="headerlink" title="1.1 创建或导入  .bib 文件"></a>1.1 创建或导入  <code>.bib</code> 文件</h3><ol><li>在项目文件树中点击 “New File”。</li><li>输入 <code>.bib</code> 作为文件名（例如，<code>references.bib</code>）。</li><li>点击 “Upload” 并上传你的 <code>.bib</code> 文件。</li></ol><p>或者在谷歌学术中点击引用，选择 <code>BibTex</code> 格式</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex">@article&#123;b1,// 这里需要改为自己引用的序号<br>  title=&#123;The internet of things: An overview&#125;,<br>  author=&#123;Rose, Karen and Eldridge, Scott and Chapin, Lyman&#125;,<br>  journal=&#123;The internet society (ISOC)&#125;,<br>  volume=&#123;80&#125;,<br>  number=&#123;15&#125;,<br>  pages=&#123;1--53&#125;,<br>  year=&#123;2015&#125;,<br>  publisher=&#123;Reston, VA&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-在文档中引用参考文献"><a href="#1-2-在文档中引用参考文献" class="headerlink" title="1.2 在文档中引用参考文献"></a>1.2 在文档中引用参考文献</h3><p>使用cite包 方式在文档中引用参考文献</p><p>Bibtex 内部包含8种对参考文献排序的方式，通过 bibliographystyle 就可以达到按照自己想法对参考文献排序的目的。分别如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">plain，按字母的顺序排列，比较次序为作者、年度和标题<br>unsrt，样式同plain，只是按照引用的先后排序<br>alpha，用作者名首字母+年份后两位作标号，以字母顺序排序<br>abbrv，类似plain，将月份全拼改为缩写，更显紧凑<br>ieeetr，国际电气电子工程师协会期刊样式<br>acm，美国计算机学会期刊样式<br>siam，美国工业和应用数学学会期刊样式<br>apalike，美国心理学学会期刊样式<br>————————————————<br></code></pre></td></tr></table></figure><h4 id="1-2-1-在文件开头导入需要的包"><a href="#1-2-1-在文件开头导入需要的包" class="headerlink" title="1.2.1  在文件开头导入需要的包"></a>1.2.1  在文件开头导入需要的包</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;cite&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-在正文中添加参考文献：-cite-b1"><a href="#1-2-2-在正文中添加参考文献：-cite-b1" class="headerlink" title="1.2.2 在正文中添加参考文献：\cite{b1]}"></a>1.2.2 在正文中添加参考文献：\cite{b1]}</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">These “smart objects” require minimal human intervention to generate,   exchange, and utilize data with minimal human intervention<span class="hljs-keyword">\cite</span>&#123;b1&#125;. As a new generation of information technology, IoT is characterized by its high integration and comprehensive application. In recent years, the continuous advancements in satellite communication technology have led to the widespread use of satellite IoT as a crucial communication means.<br></code></pre></td></tr></table></figure><p>此处的 \cite{b1} 是ref.bib 文件中的第一条参考文献。</p><p>当文档某处需要引用多个参考文献时，可以使用逗号分隔引用标签，并将它们包含在 \cite{} 命令内。例如，如果你要引用文献 “r1”、”r2” 和 “r3”，可以这样做：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\cite</span>&#123;r1, r2, r3&#125;<br></code></pre></td></tr></table></figure><p>这将在文档中生成一个带有逗号分隔的引用列表，类似于 [1, 2, 3]，其中 “[1]” 表示文献 “r1”，”[2]” 表示文献 “r2”，”[3]” 表示文献 “r3”。</p><p>特例：如下</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\cite</span>&#123;r9, r10, r11, r12, r13&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-3-文章结尾部分加入：-bibliographystyle-ieeetr-bibliography-references"><a href="#1-2-3-文章结尾部分加入：-bibliographystyle-ieeetr-bibliography-references" class="headerlink" title="1.2.3  文章结尾部分加入：\bibliographystyle{ieeetr}     \bibliography{references},"></a>1.2.3  文章结尾部分加入：\bibliographystyle{ieeetr}     \bibliography{references},</h4><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\bibliographystyle</span>&#123;ieeetr&#125;   <span class="hljs-comment">% 选择引用样式</span><br><span class="hljs-keyword">\bibliography</span>&#123;references&#125;          <span class="hljs-comment">% 参考文献存放目录ref.bib文件</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-编译、生成参考文献列表"><a href="#1-3-编译、生成参考文献列表" class="headerlink" title="1.3  编译、生成参考文献列表"></a>1.3  编译、生成参考文献列表</h3><p>在Overleaf中，你需要使用LaTeX编译器编译你的文档，以生成正确的参考文献列表和引用标记。通常，你需要运行LaTeX编译器多次以处理引用。</p><p> 在LaTeX文档中，使用 <code>\bibliography&#123;&#125;</code> 命令指定你的 <code>.bib</code> 文件名称，并使用 <code>\bibliographystyle&#123;&#125;</code> 命令选择引用的样式。然后，在文档的适当位置使用 <code>\bibliography&#123;&#125;</code> 命令生成参考文献列表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零实现TCP</title>
    <link href="/2024/07/11/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0TCP/"/>
    <url>/2024/07/11/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0TCP/</url>
    
    <content type="html"><![CDATA[<p>斯坦福计网大作业</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><h1 id="洛谷刷题"><a href="#洛谷刷题" class="headerlink" title="洛谷刷题"></a>洛谷刷题</h1><p>产生长度为5的回文数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (d1 = <span class="hljs-number">1</span>; d1 &lt;= <span class="hljs-number">9</span>; d1+=<span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// 只有奇数才会是素数</span><br>     <span class="hljs-keyword">for</span> (d2 = <span class="hljs-number">0</span>; d2 &lt;= <span class="hljs-number">9</span>; d2++) &#123;<br>         <span class="hljs-keyword">for</span> (d3 = <span class="hljs-number">0</span>; d3 &lt;= <span class="hljs-number">9</span>; d3++) &#123;<br>           palindrome = <span class="hljs-number">10000</span>*d1 + <span class="hljs-number">1000</span>*d2 +<span class="hljs-number">100</span>*d3 + <span class="hljs-number">10</span>*d2 + d1;<span class="hljs-comment">//(处理回文数...)</span><br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>埃氏筛：给定整数n ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>二维vector的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><p>另外sort不能对二维数组进行排序</p><h1 id="力扣刷题"><a href="#力扣刷题" class="headerlink" title="力扣刷题"></a>力扣刷题</h1><h2 id="十进制转任意进制"><a href="#十进制转任意进制" class="headerlink" title="十进制转任意进制"></a>十进制转任意进制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 【分析】</span><br><span class="hljs-comment">//  n = …… + a * (base)^5 + b * (base)^4 + c * (base)^3 + d * (base)^2 + e * (base)^1 + f * (base)^0</span><br><span class="hljs-comment">//  若base为正数，则n也必定为非负数</span><br><span class="hljs-comment">//  若base为负数，则n可为所有整数</span><br><br><span class="hljs-comment">// 【任意base的通用写法】</span><br><span class="hljs-function">string <span class="hljs-title">baseAny</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> base)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>    string ans;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 获取当前最低位</span><br>        <span class="hljs-type">int</span> r = n % base;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)     <span class="hljs-comment">// 说明 base 必为负数</span><br>            r -= base; <span class="hljs-comment">// 保证找到的余数在有效范围 [0, base - 1] 内</span><br>        n -= r;        <span class="hljs-comment">// 将最后一位抹零，保证后续是整除，从而保证不同语言通用</span><br>        <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">10</span>)<br>            ans += <span class="hljs-string">&#x27;A&#x27;</span> + r - <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">else</span><br>            ans += <span class="hljs-string">&#x27;0&#x27;</span> + r;<br><br>        <span class="hljs-comment">// 将n的进制表达式向右移一位</span><br>        n /= base;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>作者：Yvette<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/convert-to-base-2/solutions/2211859/jin-zhi-biao-da-shi-de-ben-zhi-bu-tong-y-1x4a/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="3-移除元素-双指针方法"><a href="#3-移除元素-双指针方法" class="headerlink" title="3.移除元素      双指针方法"></a>3.移除元素      双指针方法</h3><h4 id="884-比较含退格的字符串"><a href="#884-比较含退格的字符串" class="headerlink" title="884.比较含退格的字符串"></a>884.比较含退格的字符串</h4><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</p><p>若该字符为普通字符：</p><p>若 skip 为 0，则说明当前字符不需要删去；</p><p>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。</p><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = s,<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">// 处理#</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;#&#x27;</span>)<span class="hljs-comment">// 如果遇到 #, 计数器+1，并且跳过这个#</span><br>                &#123;<br>                    skipS++, i--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipS &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">// 如果计数器 &gt; 0，则跳过下一个字符，计数器-1 </span><br>                &#123;<br>                    skipS--, i--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(t[j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    skipT++, j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipT &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    skipT--, j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(s[i] != t[j])    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//经过前面的处理，是没有#和删除的字符</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 如果两个不一样长，就k</span><br>            i--, j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5-长度最小的子数组"><a href="#5-长度最小的子数组" class="headerlink" title="5. 长度最小的子数组"></a>5. 长度最小的子数组</h3><h4 id="904水果成篮-滑动区间unordered-map使用"><a href="#904水果成篮-滑动区间unordered-map使用" class="headerlink" title="904水果成篮         滑动区间unordered_map使用"></a>904水果成篮         滑动区间unordered_map使用</h4><p><strong>问题：</strong>怎么判断滑动区间内元素种类？采用哈希表unordered_map来统计，或者构建数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个unordered_map，键是string类型，值是int类型</span><br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span>;<br>    myMap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">3</span>;<br>    myMap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 查找元素</span><br>    std::string fruit = <span class="hljs-string">&quot;banana&quot;</span>;<br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">find</span>(fruit) != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The number of &quot;</span> &lt;&lt; fruit &lt;&lt; <span class="hljs-string">&quot; is: &quot;</span> &lt;&lt; myMap[fruit] &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No information available for &quot;</span> &lt;&lt; fruit &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;orange&quot;</span>);<br><br>    <span class="hljs-comment">// 遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取unordered_map的长度</span><br>    cout &lt;&lt; myMap.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-螺旋数组Ⅱ"><a href="#6-螺旋数组Ⅱ" class="headerlink" title="6. 螺旋数组Ⅱ"></a>6. 螺旋数组Ⅱ</h3><h4 id="二维vector的定义"><a href="#二维vector的定义" class="headerlink" title="二维vector的定义"></a>二维vector的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>|| matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m * n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt; right; j++)   res[count++] = matrix[top][j];<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = top; i &lt;= bottom; i++)   res[count++] = matrix[i][right];<br><br>            <span class="hljs-keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>; j &gt; left; j--)   res[count++] = matrix[bottom][j];<br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bottom; i &gt; top; i--)   res[count++] = matrix[i][left];<br>            &#125;<br><br>            left++, right--, top++, bottom--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p><p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p><h3 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>dummyHead-&gt;next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span><br></code></pre></td></tr></table></figure><h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><p><strong>双指针法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>递归法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre,ListNode* cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>        <span class="hljs-comment">// pre = cur;</span><br>        <span class="hljs-comment">// cur = temp;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur,temp);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>        <span class="hljs-comment">// ListNode* cur = head;</span><br>        <span class="hljs-comment">// ListNode* pre = NULL;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>重点是推导的过程，详见代码随想录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" class=""><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">数组<br>set、unordered_set<br>map、unordered_<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1、二叉树理论基础"><a href="#1、二叉树理论基础" class="headerlink" title="1、二叉树理论基础"></a>1、二叉树理论基础</h3><h4 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h4><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p><p><strong>满二叉树：</strong>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p><strong>完全二叉树：</strong>在完全二叉树中，除了最底层节点可能没填满外，其余<strong>每层节点数都达到最大值</strong>，并且最下面一层的节点都集中在<strong>该层最左边</strong>的若干位置。</p><p><strong>二叉搜索树：</strong>二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。（左  &lt;  根  &lt;  右）</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><strong>平衡二叉树：</strong>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的<strong>高度差</strong>的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>补充： <strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p><h4 id="二叉树存储方式"><a href="#二叉树存储方式" class="headerlink" title="二叉树存储方式"></a>二叉树存储方式</h4><p>1、链式存储：用指针</p><p>2、顺序存储：用数组，<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储的节点定义方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-comment">// 构造函数，初始化节点的值和子节点指针</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2、二叉树的递归遍历"><a href="#2、二叉树的递归遍历" class="headerlink" title="2、二叉树的递归遍历"></a>2、二叉树的递归遍历</h3><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>前序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：由于 <code>vec</code> 是引用传递，因此对 <code>vec</code> 的任何修改都会保留，并且在递归调用中不断累积结果。</strong></p><h3 id="3、二叉树的迭代遍历"><a href="#3、二叉树的迭代遍历" class="headerlink" title="3、二叉树的迭代遍历"></a>3、二叉树的迭代遍历</h3><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><p><strong>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br><br>        stack&lt;TreeNode *&gt; myStk;<br>        myStk.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = myStk.<span class="hljs-built_in">top</span>();<br>            myStk.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">NULL</span>)     myStk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)      myStk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><strong>再来看后序遍历，先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">=<br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">postorderTraversal</span>(TreeNode* root) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br><br>        stack&lt;TreeNode *&gt; myStk;<br>        myStk.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = myStk.<span class="hljs-built_in">top</span>();<br>            myStk.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)      myStk.<span class="hljs-built_in">push</span>(node-&gt;left);<span class="hljs-comment">////////</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">NULL</span>)     myStk.<span class="hljs-built_in">push</span>(node-&gt;right);<span class="hljs-comment">////////</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//////////</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; myStk;<br>        TreeNode *cur = root;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                myStk.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur = myStk.<span class="hljs-built_in">top</span>();<br>                myStk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyWebServer</title>
    <link href="/2024/06/02/MyWebServer/"/>
    <url>/2024/06/02/MyWebServer/</url>
    
    <content type="html"><![CDATA[<h1 id="MyWebServer"><a href="#MyWebServer" class="headerlink" title="MyWebServer"></a>MyWebServer</h1><h2 id="webserver学习总结"><a href="#webserver学习总结" class="headerlink" title="webserver学习总结"></a>webserver学习总结</h2><h3 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h3><p>[1、小白视角：一文读懂社长的TinyWebServer(Raw_Version)](<a href="https://huixxi.github.io/2020/06/02/%E5%B0%8F%E7%99%BD%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82%E7%A4%BE%E9%95%BF%E7%9A%84TinyWebServer/#more">小白视角：一文读懂社长的TinyWebServer | HU (huixxi.github.io)</a>)</p><h3 id="Socket网络编程"><a href="#Socket网络编程" class="headerlink" title="Socket网络编程"></a>Socket网络编程</h3><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>使用webbench工具进行测试，直接运行因为权限问题不够找不到命令无法执行，使用下面的命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc webbench.c -o webbench<br></code></pre></td></tr></table></figure><p>重新编译该文件时遇到报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">webbench.c:<span class="hljs-number">21</span>:<span class="hljs-number">10</span>: fatal error: rpc/types.h: 没有那个文件或目录<br>   <span class="hljs-number">21</span> | <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rpc/types.h&gt;</span></span><br>      |          ^~~~~~~~~~~~~<br>解决方案：将&lt;rpc/typed.h&gt;改为&lt;sys/typed.h&gt;后重新编译<br></code></pre></td></tr></table></figure><p>然后在解压目录打开终端运行命令（<code>-c</code>表示客户端数， <code>-t</code>表示时间）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./webbench -c <span class="hljs-number">10001</span> -t <span class="hljs-number">5</span> http:<span class="hljs-comment">//127.0.0.1:9006/</span><br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Webbench - Simple Web Benchmark <span class="hljs-number">1.5</span><br>Copyright (c) Radim Kolar <span class="hljs-number">1997</span><span class="hljs-number">-2004</span>, GPL Open Source Software.<br><br>Benchmarking: GET http:<span class="hljs-comment">//127.0.0.1:9007/</span><br><span class="hljs-number">10001</span> clients, running <span class="hljs-number">5</span> sec.<br><br>Speed=<span class="hljs-number">503340</span> pages/min, <span class="hljs-number">939568</span> bytes/sec.<br>Requests: <span class="hljs-number">41945</span> susceed, <span class="hljs-number">0</span> failed.<br></code></pre></td></tr></table></figure><h4 id="Webbench是什么，介绍一下原理"><a href="#Webbench是什么，介绍一下原理" class="headerlink" title="Webbench是什么，介绍一下原理"></a>Webbench是什么，介绍一下原理</h4><p>WebBench 是一个简单、实用的 Web 压力测试工具。它主要用于测试 Web 服务器的性能，通过模拟大量客户端访问服务器，以评估服务器在高负载下的表现。</p><p>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p><h2 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h2><h3 id="添加一个HTML和CSS的登录界面"><a href="#添加一个HTML和CSS的登录界面" class="headerlink" title="添加一个HTML和CSS的登录界面"></a>添加一个HTML和CSS的登录界面</h3><p>HTML和CSS素材来自：<a href="https://mp.weixin.qq.com/s/0snX38O4LQsglgd_dsY57g">微信公众号</a></p><h4 id="代码中响应HTTP的逻辑部分"><a href="#代码中响应HTTP的逻辑部分" class="headerlink" title="代码中响应HTTP的逻辑部分"></a>代码中响应HTTP的逻辑部分</h4><p>该方法中可以根据HTML代码中的 <code>form</code> 中的 <code>action</code> 和 <code>post</code> 方法，来传输到服务器中进行逻辑判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>新用户<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务器代码中实现处理HTTP请求的方法在文件 <code>http_conn.cpp</code> 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理HTTP请求的方法</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::do_request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">strcpy</span>(m_real_file, doc_root);      <span class="hljs-comment">// 将 doc_root 的值复制到 m_real_file 中</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(doc_root);<br>    <span class="hljs-comment">//printf(&quot;m_url:%s\n&quot;, m_url);</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = <span class="hljs-built_in">strrchr</span>(m_url, <span class="hljs-string">&#x27;/&#x27;</span>);    <span class="hljs-comment">// 查找m_url中最后一个/字符的位置。</span><br><br>    <span class="hljs-comment">//处理cgi       如果cgi标志为1，并且URL中最后一个/后面紧跟的字符是&#x27;2&#x27;或&#x27;3&#x27;，进入处理CGI部分的代码块。</span><br>    <span class="hljs-keyword">if</span> (cgi == <span class="hljs-number">1</span> &amp;&amp; (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;2&#x27;</span> || *(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;3&#x27;</span>))   <br>    &#123;<br>        <span class="hljs-comment">//根据标志判断是登录检测还是注册检测</span><br>        <span class="hljs-type">char</span> flag = m_url[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取m_url中的第二个字符，存储在flag中。</span><br><br>        <span class="hljs-comment">// 动态分配200字节的内存给m_url_real，并将m_url从第三个字符开始的子串连接到/后面，</span><br>        <span class="hljs-comment">// 构建新的URL路径，最后将其复制到m_real_file中，并释放分配的内存。</span><br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-built_in">strcat</span>(m_url_real, m_url + <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">free</span>(m_url_real);<br><br>        <span class="hljs-comment">//将用户名和密码提取出来</span><br>        <span class="hljs-comment">//user=123&amp;passwd=123</span><br>        <span class="hljs-type">char</span> name[<span class="hljs-number">100</span>], password[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">5</span>; m_string[i] != <span class="hljs-string">&#x27;&amp;&#x27;</span>; ++i)<br>            name[i - <span class="hljs-number">5</span>] = m_string[i];<br>        name[i - <span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = i + <span class="hljs-number">10</span>; m_string[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i, ++j)<br>            password[j] = m_string[i];<br>        password[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">//如果是注册，先检测数据库中是否有重名的</span><br>        <span class="hljs-comment">//没有重名的，进行增加数据</span><br>        <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;3&#x27;</span>)<br>        &#123;<br>            <span class="hljs-type">char</span> *sql_insert = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>            <span class="hljs-built_in">strcpy</span>(sql_insert, <span class="hljs-string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, name);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, <span class="hljs-string">&quot;&#x27;, &#x27;&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, password);<br>            <span class="hljs-built_in">strcat</span>(sql_insert, <span class="hljs-string">&quot;&#x27;)&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> (users.<span class="hljs-built_in">find</span>(name) == users.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                m_lock.<span class="hljs-built_in">lock</span>();<br>                <span class="hljs-type">int</span> res = <span class="hljs-built_in">mysql_query</span>(mysql, sql_insert);<br>                users.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, string&gt;(name, password));<br>                m_lock.<span class="hljs-built_in">unlock</span>();<br><br>                <span class="hljs-keyword">if</span> (!res)<br>                    <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/log.html&quot;</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/registerError.html&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/registerError.html&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//如果是登录，直接判断</span><br>        <span class="hljs-comment">//若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;2&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (users.<span class="hljs-built_in">find</span>(name) != users.<span class="hljs-built_in">end</span>() &amp;&amp; users[name] == password)<br>                <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/welcome.html&quot;</span>);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">strcpy</span>(m_url, <span class="hljs-string">&quot;/logError.html&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)    <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;0&#x27;，处理注册页面请求：</span><br>    &#123;   <br>        <span class="hljs-comment">// 构建注册页面路径并复制到m_real_file中，然后释放动态分配的内存。</span><br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/register.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)   <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;1&#x27;，处理登录页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/log.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;5&#x27;</span>) <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;5&#x27;，处理图片页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/picture.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;6&#x27;</span>)  <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;6&#x27;，处理视频页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/video.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(p + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;7&#x27;</span>)   <span class="hljs-comment">// 如果`URL`中最后一个`/`后面的字符是&#x27;7&#x27;，处理粉丝页面请求：</span><br>    &#123;<br>        <span class="hljs-type">char</span> *m_url_real = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) * <span class="hljs-number">200</span>);<br>        <span class="hljs-built_in">strcpy</span>(m_url_real, <span class="hljs-string">&quot;/fans.html&quot;</span>);<br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="hljs-built_in">strlen</span>(m_url_real));<br><br>        <span class="hljs-built_in">free</span>(m_url_real);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 处理其他未明确指定的请求，直接将`m_url`复制到`m_real_file`中。</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="hljs-number">0</span>)    <span class="hljs-comment">// 检查m_real_file是否存在。如果不存在，返回NO_RESOURCE错误</span><br>        <span class="hljs-keyword">return</span> NO_RESOURCE;<br><br>    <span class="hljs-keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))   <span class="hljs-comment">// 检查文件权限。如果文件不可读，返回`FORBIDDEN_REQUEST`错误。</span><br>        <span class="hljs-keyword">return</span> FORBIDDEN_REQUEST;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISDIR</span>(m_file_stat.st_mode))   <span class="hljs-comment">// 检查文件类型。如果是目录，返回BAD_REQUEST错误。</span><br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br><br>    <span class="hljs-comment">// 打开文件并将其映射到内存中，然后关闭文件描述符，返回`FILE_REQUEST`。</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(m_real_file, O_RDONLY);<br>    m_file_address = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">mmap</span>(<span class="hljs-number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> FILE_REQUEST;<br>&#125;<br></code></pre></td></tr></table></figure><p>用GPT生成了 <code>root</code> 目录下的 <code>style.css</code> 文件，修改了 <code>judge.html</code> 、<code>log.html</code> 、<code>register.html</code> 文件，使其符合要求</p><p>其中，有一部分不太明白，我觉得应该去看看HTML请求体的结构和内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;2CGISQL.cgi&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;required&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 这部分不太懂 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;登录密码&quot;</span> <span class="hljs-attr">required</span>=<span class="hljs-string">&quot;required&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 这部分不太懂 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基础知识学习"><a href="#基础知识学习" class="headerlink" title="基础知识学习"></a>基础知识学习</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="1、什么是进程？"><a href="#1、什么是进程？" class="headerlink" title="1、什么是进程？"></a>1、什么是进程？</h4><ul><li>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</li><li>它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li><li>从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序 代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信 息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的 有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</li><li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始 运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li><li>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li></ul><h4 id="2、并行和并发"><a href="#2、并行和并发" class="headerlink" title="2、并行和并发"></a>2、并行和并发</h4><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</p><p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使 得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干 段，使多个进程快速交替的执行。</p><p><strong>并发是两个队列交替使用一台咖啡机。并行是两个队列同时使用两台咖啡机。</strong></p><h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 <strong>task_struct 结构体</strong>。结构体组成：</p><ul><li>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</li><li>进程的状态：有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录（Current Working Directory）</li><li>umask 掩码</li><li>文件描述符表，包含很多指向 file 结构体的指针</li><li>和信号相关的信息</li><li>用户 id 和组 id </li><li>会话（Session）和进程组 </li><li>进程可以使用的资源上限（Resource Limit）</li></ul><h4 id="3、进程的状态"><a href="#3、进程的状态" class="headerlink" title="3、进程的状态"></a>3、进程的状态</h4><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型 中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。</p><img src="/2024/06/02/MyWebServer/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" class=""><ul><li><p>运行态：进程占有处理器正在运行</p></li><li><p>就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必 要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常 将它们排成一个队列，称为就绪队列</p></li><li><p>阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程<strong>不具备运行条件，正在等待某个事件的完成</strong></p></li></ul><p><strong>在五态模型中</strong>，进程分为<strong>新建态</strong>、就绪态，运行态，阻塞态，终止态。</p><ul><li>新建态：进程刚被创建时的状态，尚未进入就绪队列</li><li>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终 止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待 善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</li></ul><h4 id="4、进程的相关指令"><a href="#4、进程的相关指令" class="headerlink" title="4、进程的相关指令"></a>4、进程的相关指令</h4><p>查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux / ajx<br>a：显示终端上的所有进程，包括其他用户的进程<br>u：显示进程的详细信息<br>x：显示没有控制终端的进程<br>j：列出与作业控制相关的信息<br><br>STAT参数意义<br>D 不可中断 Uninterruptible（usually IO）<br>R 正在运行，或在队列中的进程<br>S 处于休眠状态<br>T 停止或被追踪<br>Z 僵尸进程<br>W 进入内存交换（从内核2.6开始无效）<br>X 死掉的进程<br>&lt; 高优先级<br>N 低优先级<br>s 包含子进程<br>+ 位于前台的进程组<br></code></pre></td></tr></table></figure><p>实时显示进程动态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">top<br><br>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键<br>对显示的结果进行排序：<br>M 根据内存使用量排序<br>P 根据 CPU 占有率排序<br>T 根据进程运行时间长短排序<br>U 根据用户名来筛选进程<br>K 输入指定的 PID 杀死进程<br></code></pre></td></tr></table></figure><p>杀死进程 （kill名并不是去杀死一个进程，而是给进程发送某个信号）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> [-signal] pid<br><span class="hljs-built_in">kill</span> –l 列出所有信号<br><span class="hljs-built_in">kill</span> –SIGKILL 进程ID<br><span class="hljs-built_in">kill</span> -9 进程ID<br>killall name 根据进程名杀死进程<br></code></pre></td></tr></table></figure><h4 id="5、进程号相关函数"><a href="#5、进程号相关函数" class="headerlink" title="5、进程号相关函数"></a>5、进程号相关函数</h4><p>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一 的，但可以重用。当一个进程终止后，其进程号就可以再次使用。 </p><p>任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为 父进程号（PPID）。 </p><p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进 程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。 进程号和进程组相关函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">// 获取进程id</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;  <span class="hljs-comment">// 获取父进程id</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="6、进程的创建"><a href="#6、进程的创建" class="headerlink" title="6、进程的创建"></a>6、进程的创建</h4><h5 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h5><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;   <br><br></code></pre></td></tr></table></figure><p>返回值： </p><p>​成功：子进程中返回 0，父进程中返回子进程 ID </p><p>​失败：返回 -1 </p><p>失败的两个主要原因： </p><p>​当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN </p><p>​系统内存不足，这时 errno 的值被设置为 ENOMEM</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">pid_t fork(void) I</span><br><span class="hljs-comment">函数的作用:用于创建子进程。</span><br><span class="hljs-comment">返回值:</span><br><span class="hljs-comment">fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。在父进程中返回创建的子进程的ID,</span><br><span class="hljs-comment">在子进程中返回日</span><br><span class="hljs-comment">如何区分父进程和子进程:通过fork的返回值。</span><br><span class="hljs-comment">在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-comment">// 判断是父进程还是子进程</span><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid : %d\n&quot;</span>, pid);<br>        <span class="hljs-comment">//如果大于0，创建的是子进程编号</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parents process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-comment">// 当前是子进程代码</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="exec-函数族介绍"><a href="#exec-函数族介绍" class="headerlink" title="exec 函数族介绍"></a>exec 函数族介绍</h5><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就 是在调用进程内部执行一个可执行文件。</p><p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被 新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱 壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调 用点接着往下执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/* (char *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ... <span class="hljs-comment">/* (char *) NULL */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...<span class="hljs-comment">/*, (char *) NULL, char * const</span></span><br><span class="hljs-comment"><span class="hljs-params">envp[] */</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span>;<br><br></code></pre></td></tr></table></figure><ul><li>l(list) 参数地址列表，以空指针结尾 </li><li>v(vector) 存有各参数地址的指针数组的地址 </li><li>p(path) 按 PATH 环境变量指定的目录搜索可执行文件 </li><li>e(environment) 存有环境变量字符串地址的指针数组的地址</li></ul><h4 id="7、GDB多进程调试"><a href="#7、GDB多进程调试" class="headerlink" title="7、GDB多进程调试"></a>7、GDB多进程调试</h4><p>使用GDB调试的时候，GDB默认只能跟踪一个进程，可以在fork函数调用之前，通过指令设置GDB调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">设置调试父进程或者子进程<br><span class="hljs-built_in">set</span> follow-fork-mode [parent (默认) | child]<br><br>设置调试模式<br><span class="hljs-built_in">set</span> detach-on-fork [on | off]<br>默认为 on， 表示当前进程的时候，其他的进程继续运行，如果为off，调试当前进程的时候，其他进程被GDB挂起<br><br>查看当前调试的进程：  info inferiors<br>切换当前调试的进程： inferior <span class="hljs-built_in">id</span><br>使进程脱离GDB调试： detach inferiors <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h4 id="8、进程控制"><a href="#8、进程控制" class="headerlink" title="8、进程控制"></a>8、进程控制</h4><h5 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;    <span class="hljs-comment">// 在退出前会多一个调用退出处理函数 和 刷星I/O缓冲、关闭文件描述符</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> _exit(<span class="hljs-type">int</span> status);  <span class="hljs-comment">// 进行运行 ---&gt; 调用_exit()系统调用 ---&gt; 进程终止运行</span><br></code></pre></td></tr></table></figure><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。</p><p> 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init （pid为1） ，而 init 进程会循环地 wait() 它 的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和 政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</p><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p><p> 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害， 应当避免。</p><h5 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h5><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其 保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间 等）。</p><p>父进程可以通过调用 wait 或 waitpid 得到它的退出状态同时彻底清除掉这个进程。</p><p>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞， waitpid() 还可以指定等待哪个子进程结束。</p><p>注意：一次 wait 或 waitpid 调用只能清理一个子进程，清理多个子进程应使用循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    pid_t wait(int *wstatus);</span><br><span class="hljs-comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程资源</span><br><span class="hljs-comment">        参数: int *wstatus</span><br><span class="hljs-comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="hljs-comment">        返回值:</span><br><span class="hljs-comment">            -成功:返回被回收的子进程的id</span><br><span class="hljs-comment">            -失败:-1(所有的子进程都结束，调用函数失败)</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒</span><br><span class="hljs-comment">    如果没有子进程，函数立刻返回， 返回-1；如果子进程都结束了，也会立刻返回，返回-1</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    pid_t waitpid(pid_t pid， int *wstatus, int options);</span><br><span class="hljs-comment">功能:回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="hljs-comment">参数:</span><br><span class="hljs-comment">-pid:</span><br><span class="hljs-comment">pid &gt; 0: 某个子进程的pid</span><br><span class="hljs-comment">pid = 0: 回收当前进程组的所有子进程</span><br><span class="hljs-comment">pid = -1: 回收所有的子进程，相当于 wait()</span><br><span class="hljs-comment">pid &lt; -1: 回收某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="hljs-comment">-options: 设置阻塞或者非阻塞</span><br><span class="hljs-comment">0 ：阻塞</span><br><span class="hljs-comment">WNOHANG ：非阻塞</span><br><span class="hljs-comment">-返回值 ：</span><br><span class="hljs-comment">&gt; 0 : 返回子进程的id</span><br><span class="hljs-comment">= 0 ：options=WNOHANG, 表示还有子进程或者</span><br><span class="hljs-comment">= -1：错误，或者没有子进程</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 有一个父进程，创建4哥子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)    <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// 防止产生很多孙子进程</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parenet, pid = %d\n&quot;</span>, getpid());<br><br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)   <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">if</span>(WIFEXITED(st))<br>            &#123;<br>                <span class="hljs-comment">// 是不是正常退出</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(WIFSIGNALED(st))<br>            &#123;<br>                <span class="hljs-comment">// 是不是异常终止</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被那个信号干掉了：%d&quot;</span>, WTERMSIG(st));<br>            &#125;<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br><br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;   <br>        <br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>, getpid());<br>        sleep(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>       <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>waitpid()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">     pid_t waitpid(pid_t pid， int *wstatus, int options);</span><br><span class="hljs-comment">功能:回收指定进程号的子进程，可以设置是否阻塞。</span><br><span class="hljs-comment">参数:</span><br><span class="hljs-comment">-pid:</span><br><span class="hljs-comment">pid &gt; 0: 某个子进程的pid</span><br><span class="hljs-comment">pid = 0: 回收当前进程组的所有子进程</span><br><span class="hljs-comment">pid = -1: 回收所有的子进程，相当于 wait()</span><br><span class="hljs-comment">pid &lt; -1: 回收某个进程组的组id的绝对值，回收指定进程组中的子进程</span><br><span class="hljs-comment">-options: 设置阻塞或者非阻塞</span><br><span class="hljs-comment">0 ：阻塞</span><br><span class="hljs-comment">WNOHANG ：非阻塞</span><br><span class="hljs-comment">-返回值 ：</span><br><span class="hljs-comment">&gt; 0 : 返回子进程的id</span><br><span class="hljs-comment">= 0 ：options=WNOHANG, 表示还有子进程或者</span><br><span class="hljs-comment">= -1：错误，或者没有子进程 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 有一个父进程，创建4哥子进程（兄弟）</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <br>    <span class="hljs-comment">// 创建5个子进程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)    <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// 防止产生很多孙子进程</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;   <br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parenet, pid = %d\n&quot;</span>, getpid());<br><br>            <span class="hljs-type">int</span> st;<br>            <span class="hljs-comment">// int ret = waitpid(-1, &amp;st, 0);        // 阻塞</span><br>            <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, &amp;st, WNOHANG);  <span class="hljs-comment">// 非阻塞</span><br>            <br>            <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)   <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(WIFEXITED(st))<br>                &#123;<br>                    <span class="hljs-comment">// 是不是正常退出</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(WIFSIGNALED(st))<br>                &#123;<br>                    <span class="hljs-comment">// 是不是异常终止</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;被那个信号干掉了：%d&quot;</span>, WTERMSIG(st));<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die, pid = %d\n&quot;</span>, ret);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;   <br>        <br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child, pid = %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>       <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>退出信息相关宏函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">WIFEXITED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程正常退出<br><span class="hljs-function"><span class="hljs-title">WEXITSTATUS</span><span class="hljs-params">(status)</span></span> 如果上宏为真，获取进程退出的状态（exit的参数）<br><span class="hljs-function"><span class="hljs-title">WIFSIGNALED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程异常终止<br><span class="hljs-function"><span class="hljs-title">WTERMSIG</span><span class="hljs-params">(status)</span></span> 如果上宏为真，获取使进程终止的信号编号<br><span class="hljs-function"><span class="hljs-title">WIFSTOPPED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程处于暂停状态<br><span class="hljs-function"><span class="hljs-title">WSTOPSIG</span><span class="hljs-params">(status)</span></span> 如果上宏为真，获取使进程暂停的信号的编号<br><span class="hljs-function"><span class="hljs-title">WIFCONTINUED</span><span class="hljs-params">(status)</span></span> 非<span class="hljs-number">0</span>，进程暂停后已经继续运行<br></code></pre></td></tr></table></figure><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="1、进程间通信概念"><a href="#1、进程间通信概念" class="headerlink" title="1、进程间通信概念"></a>1、进程间通信概念</h4><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC： Inter Processes Communication )。</p><p>进程间通信的目的：</p><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程。 </li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程 终止时要通知父进程）。 </li><li>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 </li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够 拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><h5 id="Linux进程间通信方式"><a href="#Linux进程间通信方式" class="headerlink" title="Linux进程间通信方式"></a>Linux进程间通信方式</h5><img src="/2024/06/02/MyWebServer/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.png" class=""><h4 id="2、管道"><a href="#2、管道" class="headerlink" title="2、管道"></a>2、管道</h4><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都 支持这种通信机制。</p><p>统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。  | 为管道符</p><h5 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h5><ul><li>管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大 小不一定相同。 </li><li>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储 数据。可以按照操作文件的方式对管道进行操作。 </li><li>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以 读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 </li><li>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一 样的。 </li><li>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的</li><li>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数 据，在管道中无法使用 lseek() 来随机的访问数据。 </li><li>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。</li></ul><h5 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h5><p>创建匿名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>])</span>;<br></code></pre></td></tr></table></figure><p>查看管道缓冲大小命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ulimit –a<br></code></pre></td></tr></table></figure><p>查看管道缓冲大小函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-title function_">fpathconf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> name)</span>;<br></code></pre></td></tr></table></figure><p>管道的非阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int pipe(int pipefd[2]);</span><br><span class="hljs-comment">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="hljs-comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="hljs-comment">            pipefd[0] 对应的是管道的读端</span><br><span class="hljs-comment">            pipefd[1] 对应的是管道的写端</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 子进程发送数据给父进程，父进程读取到数据输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    设置管道非阻塞</span><br><span class="hljs-comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag </span><br><span class="hljs-comment">    flags |= O_NONBLOCK;                // 修改flag的值</span><br><span class="hljs-comment">    fcntl(fd[0], F_SERFL, flags);       // 设置信道flag</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <br>        <span class="hljs-comment">// 从管道的读取端读取数据 </span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-comment">// 设置管道非阻塞</span><br>        <span class="hljs-type">int</span> flags = fcntl(pipefd[<span class="hljs-number">0</span>], F_GETFL);  <span class="hljs-comment">// 获取原来的flag </span><br>        flags |= O_NONBLOCK;                <span class="hljs-comment">// 修改flag的值</span><br>        fcntl(pipefd[<span class="hljs-number">0</span>], F_SETFL, flags);       <span class="hljs-comment">// 设置信道flag</span><br><br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;len : %d\n&quot;</span>, len);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);<br>            sleep(<span class="hljs-number">1</span>); <br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>            <span class="hljs-comment">//sleep(1);</span><br><br>            <span class="hljs-comment">// int len = read(pipefd[0], buf, sizeof(buf));</span><br>            <span class="hljs-comment">// printf(&quot;child recv : %s, pid : %d\n&quot;, buf, getpid());</span><br>            <span class="hljs-comment">// bzero(buf, 1024);</span><br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="有名管道（命名管道）"><a href="#有名管道（命名管道）" class="headerlink" title="有名管道（命名管道）"></a>有名管道（命名管道）</h5><p><strong>介绍</strong></p><ol><li>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道 （FIFO），也叫命名管道、FIFO文件。</li><li>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存 在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不 存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不 相关的进程也能交换数据。</li><li>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了 （如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取 数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</li><li>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：<ul><li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 </li><li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 </li><li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</li></ul></li></ol><p><strong>使用</strong></p><p>通过命令创建有名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mkfifo 名字<br></code></pre></td></tr></table></figure><p>通过函数创建有名管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><br></code></pre></td></tr></table></figure><p>一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I&#x2F;O 函数都可用于 fifo。如： close、read、write、unlink 等。 FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写 则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中写数据</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <span class="hljs-comment">// 2、创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 3、以只写的方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4、写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中读取数据</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2、读数据</span><br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接了....\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有名管道的注意事项</strong>*</p><ol><li>一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开进程</li><li>一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开进程</li></ol><p>读管道：</p><ul><li>管道中有数据，read返回实际读到的字节数</li><li>管道中无数据：管道写端被全部关闭，read返回0，（相当于读到文件末尾）；写端没有全部被关闭，read阻塞等待</li></ul><p>写管道:</p><ul><li>管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号)</li><li>管道读端没有全部关闭:   管道已经满了，write会阻塞；管道没有满，write将数据写入，并返回实际写入的字节数。</li></ul><p><strong>有名管道的使用完成聊天功能</strong></p><img src="/2024/06/02/MyWebServer/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//     *****************************  chatA.c **********************************</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、判断管道是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    ret = access(<span class="hljs-string">&quot;fifo2&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo2&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、以只写的方式打开管道1</span><br>    <span class="hljs-type">int</span> fdw = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fdw == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 2、以只读的方式打开管道2</span><br>    <span class="hljs-type">int</span> fdr = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fdr == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-comment">// 4、循环的读写数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);    <br>        <span class="hljs-comment">// 获取标准输入的数据</span><br>        fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-comment">// 写数据</span><br>        ret = write(fdw, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 读管道数据</span><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        ret = read(fdr, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf : %s\n&quot;</span>, buf);<br>    &#125;<br><br>    close(fdw);<br>    close(fdr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//     *****************************  chatB.c **********************************</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、判断管道是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    ret = access(<span class="hljs-string">&quot;fifo2&quot;</span>, F_OK);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，船舰对应命名的有名管道\n&quot;</span>);<br>        ret = mkfifo(<span class="hljs-string">&quot;fifo2&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2、以只读的方式打开管道1</span><br>    <span class="hljs-type">int</span> fdr = open(<span class="hljs-string">&quot;fifo1&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fdr == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>);<br><br>    <span class="hljs-comment">// 2、以只写的方式打开管道2</span><br>    <span class="hljs-type">int</span> fdw = open(<span class="hljs-string">&quot;fifo2&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fdw == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br><br>    <span class="hljs-comment">// 4、循环的读写数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 读管道数据</span><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        ret = read(fdr, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf : %s\n&quot;</span>, buf);<br><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);    <br>        <span class="hljs-comment">// 获取标准输入的数据</span><br>        fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>        <span class="hljs-comment">// 写数据</span><br>        ret = write(fdw, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    close(fdw);<br>    close(fdr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、内存映射"><a href="#3、内存映射" class="headerlink" title="3、内存映射"></a>3、内存映射</h4><p>内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br> <span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> </span><br><span class="hljs-params">offset)</span>;<br> <span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       void *mmap(void *addr, size_t length, int prot, int flags,</span><br><span class="hljs-comment">                  int fd, off_t offset);</span><br><span class="hljs-comment">            -功能： 映射一个文件或设备到内存之中，</span><br><span class="hljs-comment">            -参数：</span><br><span class="hljs-comment">                - void *addr: NULL, 由内核决定</span><br><span class="hljs-comment">                - length: 要映射数据的长度，不能为0。建议使用文件的长度</span><br><span class="hljs-comment">                        获取文件的长度：stat  lseek 函数</span><br><span class="hljs-comment">                - prot: 对申请的内存映射区的操作权限， </span><br><span class="hljs-comment">                    PROT_EXEC  Pages may be executed.</span><br><span class="hljs-comment">                    PROT_READ  Pages may be read.</span><br><span class="hljs-comment">                    PROT_WRITE Pages may be written.</span><br><span class="hljs-comment">                    PROT_NONE  Pages may not be accessed.</span><br><span class="hljs-comment">                    要操作映射区，必须要有读的权限</span><br><span class="hljs-comment">                    PROT_READ、 PROT_READ | PROT_WRITE</span><br><span class="hljs-comment">                - flags: </span><br><span class="hljs-comment">                    - MAP_SHARD: 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须设置这个选项</span><br><span class="hljs-comment">                    - MAP_PRIVATE: 不同步， 内存映射区的数据改变了，对原来文件不会修改，会重新创建一个新的文件。</span><br><span class="hljs-comment">                - fd: 需要映射的那个文件的文件描述符</span><br><span class="hljs-comment">                    - 通过open得到，open的是一个磁盘文件</span><br><span class="hljs-comment">                    - 注意： 文件大小不能为0，open指定的权限不能和prot参数有冲突</span><br><span class="hljs-comment">                        prot: PROT_READ     open: 只读/读写</span><br><span class="hljs-comment">                        prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="hljs-comment">                - offset: 偏移量，一般不用，必须指定是4k的整数值，0表示不偏移</span><br><span class="hljs-comment">            - 返回值：返回船舰的内存的首地址</span><br><span class="hljs-comment">                失败返回MAP_FAILED, (void *) -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        int munmap(void *addr, size_t length);</span><br><span class="hljs-comment">            - 功能： 释放内存映射</span><br><span class="hljs-comment">            - 参数：</span><br><span class="hljs-comment">                -addr: 要释放内存的首地址</span><br><span class="hljs-comment">                -length: 要释放的内存的大小，要和mmap函数中的length参数要一样</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用内存映射实现进程间通信</span><br><span class="hljs-comment">    1、有关系的进程（父子间）</span><br><span class="hljs-comment">        - 还没有子进程的时候</span><br><span class="hljs-comment">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="hljs-comment">        - 有了内存映射区以后，创建子进程</span><br><span class="hljs-comment">        - 父子进程共享创建的内存映射区</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    2、没有关系的进程       </span><br><span class="hljs-comment">        - 准备一个大小不是0的磁盘文件</span><br><span class="hljs-comment">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 使用内存映射区通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：内存映射区通信，是非阻塞的</span><br><span class="hljs-comment">    通过同一个磁盘文件创建了内存映射区。</span><br><span class="hljs-comment">    这意味着这两个进程都将相同的文件内容映射到它们各自的地址空间中，并且对这个文件内容的任何更改都会在两个进程中可见。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1、打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);  <span class="hljs-comment">// 获取文件的大小</span><br><br>    <span class="hljs-comment">// 2、创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3、创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)<br>    &#123;   <br>        wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv: %s\n&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4、关闭内存映射区</span><br>    munmap(ptr, size);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内存映射的注意事项</strong></p><ol><li>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功？<br>答：可以对ptr进行++操作，但是munmap会错误，需要提前保存++前的内存地址</li><li>如果open时O_RDONLY, mmap时prot参数指定 PROT_READ | PROT_WRITE 会怎样？<br>答：错误， 会返回 MAP_FAILED （即，void* -1） open() 函数中的权限建议和prot参数的权限保持一致。</li><li>如果文件偏移量为1000会怎样？<br>答：偏移量必须是4k的整数倍， 返回MAP_FAILED (分页大小)</li><li>mmap什么情况下会调用失败？<ul><li>第二个参数： length &#x3D; 0</li><li>第三个参数： prot权限有问题<ul><li>只指定了写权限</li><li>prot PROT_READ | PROT_WRITE<br>第五个参数fd 通过open函数时 未指定 O_RDONLY | O_WRONLY</li></ul></li></ul></li><li>可以open的时候O_CREATE一个新文件来创建映射区吗？<ul><li>可以， 但是创建文件大小为0的话，肯定不行</li><li>可以对新的文件进行扩展<ul><li>lseek()</li><li>truncate()  &#x2F;&#x2F; 扩招新的文件的内存</li></ul></li></ul></li><li>mmap后关闭文件描述符，对mmap映射有没有影响？<br>答：int fd &#x3D; open(“xxx”)<br>mmap(,,, fd, 0);<br>close(fd);<br>映射区还存在， 创建映射区的fd被关闭， 没有任何影响</li><li>对ptr越界操作会怎样？<br>答：越界操作，操作的是非法内存，-&gt; 段错误</li></ol><h4 id="4、信号"><a href="#4、信号" class="headerlink" title="4、信号"></a>4、信号</h4><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中 断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的 进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 通常会给进程发送一个中断信号。 </li><li>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。 比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 </li><li>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 时间超限，或者 该进程的某个子进程退出。 </li><li>运行 kill 命令或调用 kill 函数。</li></ul><p>使用信号的两个主要目的是：</p><ul><li>让进程知道已经发生了一个特定的事情。 </li><li>强迫进程执行它自己代码中的信号处理程序。</li></ul><p>信号的特点： </p><ul><li>简单 </li><li>不能携带大量信息 </li><li>满足某个特定条件才发送 </li><li>优先级比较高</li></ul><p>查看系统定义的信号列表：kill –l</p><table><thead><tr><th align="center">信号编号</th><th align="center">信号名称</th><th align="center">对应事件</th><th align="center">默认动作</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">SIGINT</td><td align="center">当用户按下了组合键时，用户终端向正在运行中 的由该终端启动的程序发出此信号</td><td align="center">终止进程</td></tr><tr><td align="center">3</td><td align="center">SIGQUIT</td><td align="center">用户按下组合键时产生该信号，用户终端向正在运 行中的由该终端启动的程序发出些信号</td><td align="center">终止进程</td></tr><tr><td align="center">9</td><td align="center">SIGKILL</td><td align="center">无条件终止进程。该信号不能被忽略，处理和阻塞</td><td align="center">终止进程，可以杀死任何进程</td></tr><tr><td align="center">11</td><td align="center">SIGSEGV</td><td align="center">指示进程进行了无效内存访问(段错误)</td><td align="center">终止进程 并产生 core文件</td></tr><tr><td align="center">13</td><td align="center">SIGPIPE</td><td align="center">Broken pipe向一个没有读端的管道写数据</td><td align="center">终止进程</td></tr><tr><td align="center">17</td><td align="center">SIGCHLD</td><td align="center">子进程结束时，父进程会收到这个信号</td><td align="center">忽略这个信号</td></tr><tr><td align="center">18</td><td align="center">SIGCONT</td><td align="center">如果进程已停止，则使其继续运行</td><td align="center">继续&#x2F;忽略</td></tr><tr><td align="center">19</td><td align="center">SIGSTOP</td><td align="center">停止进程的执行。信号不能被忽略，处理和阻塞</td><td align="center">为终止进 程</td></tr></tbody></table><h5 id="信号的-5-种默认处理动作"><a href="#信号的-5-种默认处理动作" class="headerlink" title="信号的 5 种默认处理动作"></a><strong>信号的 5 种默认处理动作</strong></h5><p>查看信号的详细信息：man 7 signal </p><p>信号的 5 中默认处理动作 </p><ul><li>Term 终止进程 </li><li>Ign 当前进程忽略掉这个信号 </li><li>Core 终止进程，并生成一个Core文件 </li><li>Stop 暂停当前进程 </li><li>Cont 继续执行当前被暂停的进程</li></ul><p>信号的几种状态：产生、未决、递达 </p><p>SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作。</p><p><strong>信号相关函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 给任何的进程或者进程组pid，发送任何信号</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- pid：</span><br><span class="hljs-comment">&gt; 0: 将信号发送给指定的进程</span><br><span class="hljs-comment">= 0：将信号发送给当前的进程组</span><br><span class="hljs-comment">= -1: 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="hljs-comment">&lt; -1: 这个pid=这个进程组的ID取反（-12345）</span><br><span class="hljs-comment">- sig: 需要发送的信号的编号或者宏值，0表示不发送任何信号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能: 给当前进程发送信号</span><br><span class="hljs-comment">- 参数：  </span><br><span class="hljs-comment">- sig: 要发送的信号</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">- 成功 0</span><br><span class="hljs-comment">- 失败 非0</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">-功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：设置定时器，函数调用，开始倒计时，当倒计时为0的时候，函数会给当前的进程发发送一个信号SIGALARM</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">    seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，也不会发送信号），取消一个定时器，通过alarm(0)</span><br><span class="hljs-comment">    - 返回值： </span><br><span class="hljs-comment">    - 之前没有定时器，返回0</span><br><span class="hljs-comment">    - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">- SIGALARM: 默认终止当前的进程，每一个进程都有且只有唯一的一个定时器</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">该函数时不阻塞的</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval *new_val, <span class="hljs-keyword">struct</span> itimerval *old_value)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;sys/time.h&gt;</span><br><span class="hljs-comment">- 功能： 设置定时器（闹钟），可以替代alerm函数。精度达到us，可以实现周期性的定时</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">    - which: 定时器以什么时间计时</span><br><span class="hljs-comment">    ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM  常用</span><br><span class="hljs-comment">    ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="hljs-comment">    ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROT</span><br><span class="hljs-comment">    - new_val: 设置定时器属性</span><br><span class="hljs-comment">             struct itimerval &#123;// 定时器结构体</span><br><span class="hljs-comment">                   struct timeval it_interval; // 间隔时间 </span><br><span class="hljs-comment">                   struct timeval it_value;    // 延长多长时间会执行定时器 </span><br><span class="hljs-comment">               &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">               struct timeval &#123;// 时间的结构体</span><br><span class="hljs-comment">                   time_t      tv_sec;         // 秒数 </span><br><span class="hljs-comment">                   suseconds_t tv_usec;        /* 微秒 </span><br><span class="hljs-comment">               &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">               过10秒后，每个2秒定时一次</span><br><span class="hljs-comment">        - old_value: 记录上一次的计时参数，一般不使用，指定NULL</span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">    成功 0</span><br><span class="hljs-comment">    失败 -1，并设置错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="信号捕捉函数"><a href="#信号捕捉函数" class="headerlink" title="信号捕捉函数"></a><strong>信号捕捉函数</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction </span><br><span class="hljs-params">*oldact)</span>; <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- signum: 需要捕捉的信号的编号或者宏值，推荐宏值</span><br><span class="hljs-comment">- act: 捕捉信号之后的处理动作</span><br><span class="hljs-comment">- oldset: 上一次对信号捕捉相关的设置，一般不适用，传递NULL</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">成功 0</span><br><span class="hljs-comment">失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct sigaction &#123;</span><br><span class="hljs-comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="hljs-comment">               void     (*sa_handler)(int);</span><br><span class="hljs-comment">             // 不常用</span><br><span class="hljs-comment">               void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="hljs-comment">             // 临时阻塞信号集，信号捕捉函数执行过程中，临时阻塞某些信号</span><br><span class="hljs-comment">               sigset_t   sa_mask;</span><br><span class="hljs-comment">             // 使用哪个信号处理对捕捉到的信号进行处理</span><br><span class="hljs-comment">                // 可以是0， 表示使用sa_handler, 等</span><br><span class="hljs-comment">               int        sa_flags;</span><br><span class="hljs-comment">               // 被废弃掉了</span><br><span class="hljs-comment">               void     (*sa_restorer)(void);</span><br><span class="hljs-comment">           &#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="阻塞信号和未决信号集"><a href="#阻塞信号和未决信号集" class="headerlink" title="阻塞信号和未决信号集"></a><strong>阻塞信号和未决信号集</strong></h5><p>阻塞信号集是可以修改的，未决信号集不能修改</p><ol><li>用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</li><li>信号产生但是没有被处理 （未决）<ul><li>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）</li><li>SIGINT信号状态被存储在第二个标志位上<ul><li>这个标志位的值为0， 说明信号不是未决状态</li><li>这个标志位的值为1， 说明信号处于未决状态</li></ul></li></ul></li><li>.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<ul><li>阻塞信号集默认不阻塞任何的信号</li><li>如果想要阻塞某些信号需要用户调用系统的API</li></ul></li><li>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<ul><li>如果没有阻塞，这个信号就被处理</li><li>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">int</span> signum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>, <span class="hljs-type">sigset_t</span> *oldset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *<span class="hljs-built_in">set</span>)</span>;<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="hljs-comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - how : 如何对内核阻塞信号集进行处理</span><br><span class="hljs-comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="hljs-comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="hljs-comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="hljs-comment">                    mask &amp;= ~set</span><br><span class="hljs-comment">                SIG_SETMASK:覆盖内核中原来的值</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            - set ：已经初始化好的用户自定义的信号集</span><br><span class="hljs-comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">                设置错误号：EFAULT、EINVAL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigpending(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：获取内核中的未决信号集</span><br><span class="hljs-comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span><br><span class="hljs-comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 设置2、3号信号阻塞</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    <span class="hljs-comment">// 将2号和3号信号添加到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 修改内核中的阻塞信号集</span><br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        num++;<br>        <span class="hljs-comment">// 获取当前的未决信号集的数据</span><br>        <span class="hljs-type">sigset_t</span> pendingset;<br>        sigemptyset(&amp;pendingset);<br>        sigpending(&amp;pendingset);<br><br>        <span class="hljs-comment">// 遍历前32位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                perror(<span class="hljs-string">&quot;sigismember&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 解除阻塞</span><br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、共享内存"><a href="#5、共享内存" class="headerlink" title="5、共享内存"></a>5、共享内存</h4><p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会 称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 </p><p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快</p><p><strong>使用步骤</strong></p><ul><li>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的 共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 </li><li>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要 使用由 shmat()  </li><li>调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是 可选的，并且在进程终止时会自动完成这一步。 </li><li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销 毁。只有一个进程需要执行这一步。</li></ul><p><strong>相关函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的表示。</span><br><span class="hljs-comment">新创建的内存段中的数据都会被初始化为0</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- key:  ket_t类型是一个整形，通过这个找到或者创建一个共享内存</span><br><span class="hljs-comment">一般使用16进制表示，非0值</span><br><span class="hljs-comment">- size： 共享内存的大小</span><br><span class="hljs-comment">- shmflg: 属性</span><br><span class="hljs-comment">- 访问权限</span><br><span class="hljs-comment">- 附加属性： 创建/判断共享内存是不是存在</span><br><span class="hljs-comment">- 创建： IPC_CREAT</span><br><span class="hljs-comment">- 判断共享内存是否存在： IPC_EXCL, 需要和IPC_CREAT一起使用</span><br><span class="hljs-comment">IPC_CREAT | IPC_EXCL | 0664</span><br><span class="hljs-comment">- 返回值： </span><br><span class="hljs-comment">- 失败 -1 并设置错误号</span><br><span class="hljs-comment">- 成功 &gt;0 返回共享的引用的ID, 后面操作共享内存都是通过这个值</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 和当前的进程进行关联</span><br><span class="hljs-comment">- 参数： </span><br><span class="hljs-comment">- shmid： 共享内存的表示（ID）,由shmget返回值获取</span><br><span class="hljs-comment">- shmaddr： 申请的共享内存的起始地址，指定NULL，由内核指定</span><br><span class="hljs-comment">- shmflg： 共享内存的操作</span><br><span class="hljs-comment">- 读： SHM_RDONLY, 必须要有读权限</span><br><span class="hljs-comment">- 读写： 0</span><br><span class="hljs-comment">- 返回值：</span><br><span class="hljs-comment">- 成功 返回共享内存的起始地址/首地址</span><br><span class="hljs-comment">- 失败 (void *) -1</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 接触当前进程和共享内存的关联</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">shmaddr： 共享内存的首地址</span><br><span class="hljs-comment">- 返回值： 成功 0 失败 -1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进程被销毁了对共享内存没有任何影响</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- shmid： 共享内存的ID</span><br><span class="hljs-comment">- cmd： 要做的操作</span><br><span class="hljs-comment">- IPC_STAT : 获取共享内存当前的状态</span><br><span class="hljs-comment">- IPC_SET: 设置共享内存的状态</span><br><span class="hljs-comment">- IPC_RMID: 标记共享内存被销毁</span><br><span class="hljs-comment">- buf: 需要设置或者获取的共享内存的属性信息</span><br><span class="hljs-comment">- IPC_STAT: buf存储数据</span><br><span class="hljs-comment">- IPC_SET: buf中需要初始化数据，设置到内核中</span><br><span class="hljs-comment">- IPC_RMID: 没有用，NULL</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能： 根据指定的路径名，和int值，生成一个共享的key</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- pathname: 指定一个存在的路径</span><br><span class="hljs-comment">- proj_id: int 类型的值，但是这系统调用指挥使用其中的1个字节</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>问题</strong></p><ol><li>问题1：操作系统如何知道一块共享内存被多少个进程关联？<ul><li>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</li><li>shm_nattach 记录了关联的进程个数</li></ul></li><li>问题2：可不可以对共享内存进行多次删除 shmctl<ul><li>可以的</li><li>因为shmctl 标记删除共享内存，不是直接删除</li><li>什么时候真正删除呢?<ul><li>当和共享内存关联的进程数为0的时候，就真正被删除</li></ul></li><li>当共享内存的key为0的时候，表示共享内存被标记删除了<ul><li>如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</li></ul></li></ul></li></ol><p><strong>共享内存和内存映射的区别</strong></p><ol><li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li><li>共享内存效率更高</li><li>内存<ul><li>所有的进程操作的是同一块共享内存。</li><li>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li></ul></li><li>数据安全<ul><li>进程突然退出<ul><li>共享内存还存在</li><li>内存映射区消失</li></ul></li><li>运行进程的电脑死机，宕机了<ul><li>数据存在在共享内存中，没有了</li><li>内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li></ul></li></ul></li><li>生命周期<ul><li>内存映射区：进程退出，内存映射区销毁</li><li>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机<ul><li>如果一个进程退出，会自动和共享内存进行取消关联。</li></ul></li></ul></li></ol><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p><p>守护进程具备下列特征： </p><ul><li>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 </li><li>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</li></ul><p>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd， Web 服务器 httpd 等。</p><p>执行一个 fork()，之后父进程退出，子进程继续执行。 </p><p>子进程调用 setsid() 开启一个新会话。 </p><p>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 </p><p>修改进程的当前工作目录，通常会改为根目录（&#x2F;）。 </p><p>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 </p><p>在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2()  使所有这些描述符指向这个设备。 </p><h3 id="线程（重点）"><a href="#线程（重点）" class="headerlink" title="线程（重点）"></a>线程（重点）</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可 以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中 包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一 个特例，该进程只包含一个线程） </p><p>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 </p><p>线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP 号：ps –Lf pid</p><h5 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><p>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通 信方式，在进程间进行信息交换。 </p><p>调用 fork() 来创建进程的代价相对较高，即便利用<strong>写时复制技术</strong>，仍然需要复制诸如内存页表和文件描 述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 </p><p>线程之间能够<strong>方便、快速地共享信息</strong>。只需将数据复制到共享（全局或堆）变量中即可。 </p><p>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复 制内存，也无需复制页表。</p><h5 id="线程之间共享和非共享的资源"><a href="#线程之间共享和非共享的资源" class="headerlink" title="线程之间共享和非共享的资源"></a>线程之间共享和非共享的资源</h5><img src="/2024/06/02/MyWebServer/linux%E5%86%85%E6%A0%B8.png" class=""><p>共享资源 </p><ul><li>进程 ID 和父进程 ID </li><li>进程组 ID 和会话 ID </li><li>用户 ID 和 用户组 ID </li><li>文件描述符表 </li><li>信号处置 </li><li>文件系统的相关信息：文件权限掩码（umask）、当前工作目录 </li><li>虚拟地址空间（除栈、.text） ，每个线程都占据总共的一部分资源。</li></ul><p>非共享资源 </p><ul><li>线程 ID </li><li>信号掩码 </li><li>线程特有数据 </li><li>error 变量 </li><li>实时调度策略和优先级 </li><li>n栈，本地变量和函数的调用链接信息</li></ul><h4 id="2、线程操作函数"><a href="#2、线程操作函数" class="headerlink" title="2、线程操作函数"></a>2、线程操作函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span> *</span><br><span class="hljs-params"> (*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-type">pthread_t</span> <span class="hljs-title function_">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_equal</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create()"></a><strong>pthread_create()</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    一般情况下，main函数所在的线程我们称之为主线程（main线程），其余创建的线程称之为子线程</span><br><span class="hljs-comment">    程序中默认只有一个进程，fork()函数调用，2个进程</span><br><span class="hljs-comment">    程序中默认只有一个线程，pthread_create()函数调用，2个线程</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *</span><br><span class="hljs-comment">    (*start_routine) (void *), void *arg);</span><br><span class="hljs-comment">        - 功能： 创建一个子线程</span><br><span class="hljs-comment">        - 参数： </span><br><span class="hljs-comment">            - thread: 传出参数，线程创建成功后，子线程的线程ID被写到该变量中</span><br><span class="hljs-comment">            - attr: 设置线程的属性，一般使用默认值，NULL</span><br><span class="hljs-comment">            - start_routine: 函数指针，这个函数是子线程需要处理的逻辑代码</span><br><span class="hljs-comment">            - arg： 给第三个参数使用，传参</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 返回错误号，这个错误号和之前的error不太一样</span><br><span class="hljs-comment">            获取错误号的信息，   char * strerror(int errnum);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread... \n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arg value: %d\n&quot;</span>, * (<span class="hljs-type">int</span> *) arg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, (<span class="hljs-type">void</span> *) &amp;num);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i:%d\n&quot;</span>, i);<br>    &#125;<br>    sleep(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-equal-和-pthread-exit"><a href="#pthread-equal-和-pthread-exit" class="headerlink" title="pthread_equal 和 pthread_exit"></a><strong>pthread_equal 和 pthread_exit</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    void pthread_exit(void *retval);</span><br><span class="hljs-comment">        - 功能：终止一个线程，在那个线程中调用，就表示终止那个线程</span><br><span class="hljs-comment">        - 参数： </span><br><span class="hljs-comment">            - retval: 需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    pthread_t pthread_self(void);</span><br><span class="hljs-comment">        - 功能：获取到当前线程的线程ID</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_equal(pthread_t t1, pthread_t t2)</span><br><span class="hljs-comment">        -功能: 比较两个线程的ID是否相等</span><br><span class="hljs-comment">        不同的操作系统，pthread_t类型的实现不一定相等，有些是int。有些是结构体</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id:%ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>  <span class="hljs-comment">// pthread_exit(NULL);</span><br>&#125;<br><br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());<br>    <span class="hljs-comment">// 让主线成主动退出，当主线程主动退出了，不影响其他线程的执行</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a><strong>pthread_join()</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    int pthread_join(pthread_t thread, void **retval);</span><br><span class="hljs-comment">        - 功能： 和一个已经终止的线程进行连接</span><br><span class="hljs-comment">            回收子线程的资源</span><br><span class="hljs-comment">            这个函数是阻塞函数，调用一次只能回收一个子线程</span><br><span class="hljs-comment">            一般在主线程中使用</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - thread: 需要回收的子线程ID,</span><br><span class="hljs-comment">            - retval: 接受子线程退出的返回值</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 返回错误号</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id:%ld\n&quot;</span>, pthread_self());<br>   <br>    <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>    pthread_exit((<span class="hljs-type">void</span> *) &amp;value);  <span class="hljs-comment">// return (void *) &amp;value;一样</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());<br>    <br>    <span class="hljs-comment">// 主线程调用pthread_join()回收子线程的资源</span><br>    <span class="hljs-type">int</span> * thread_retval;<br>    ret = pthread_join(tid, (<span class="hljs-type">void</span> *)&amp;thread_retval);<br>    <br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit data : %d\n&quot;</span>, *thread_retval);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程资源释放成功\n&quot;</span>);<br><br>    <span class="hljs-comment">// 让主线成主动退出，当主线程主动退出了，不影响其他线程的执行</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach()"></a>pthread_detach()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    int pthread_detach(pthread_t thread);</span><br><span class="hljs-comment">        - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统</span><br><span class="hljs-comment">            1.不能多次分离，会产生不可预料的行为</span><br><span class="hljs-comment">            2.不能去连接一个已经分离的线程，会报错</span><br><span class="hljs-comment">        - 参数：需要分离的线程的ID</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：返回错误号</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());<br><br>    <span class="hljs-comment">// 设置子线程分离，子线程分离后，子线程结束时对应的资源就不需要主线程释放了</span><br>    ret = pthread_detach(tid);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error2: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// // 设置分离后，不能对分离的子线程进行连接，pthread_join();  </span><br>    <span class="hljs-comment">// ret = pthread_join(tid, NULL);</span><br>    <span class="hljs-comment">// if(ret != 0)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     char * errstr = strerror(ret);</span><br>    <span class="hljs-comment">//     printf(&quot;error3: %s\n&quot;, errstr);</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    phread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;pthread.h&gt;</span><br><span class="hljs-comment">    int pthread_cancel(pthread_t thread);</span><br><span class="hljs-comment">        - 功能：取消线程（让线程终止）  杀毒软件可以让一些程序停止</span><br><span class="hljs-comment">            取消某个线程可以终止某个线程的运行，</span><br><span class="hljs-comment">            但是不是立刻终止，而是当子线程执行到一个取消点，线程才会终止。</span><br><span class="hljs-comment">            取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户到内核去的切换，这个位置称之为取消点</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - thread</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id: %ld\n&quot;</span>, pthread_self());<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child i : %d\n&quot;</span>, i);<br> <br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br><br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1: %s\n&quot;</span>, errstr);<br>    &#125;<br><br>    <span class="hljs-comment">// 取消线程</span><br>    pthread_cancel(tid);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i : %d\n&quot;</span>, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出主线程和子线程的ID</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid: %ld, main thread id: %ld\n&quot;</span>, tid, pthread_self());<br><br>    phread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程属性相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">线程属性类型 <span class="hljs-type">pthread_attr_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span>;<span class="hljs-comment">// 初始化线程属性变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span>;<span class="hljs-comment">// 销毁线程属性变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getdetachstate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> *detachstate)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：获取线程分离的状态属性</span><br><span class="hljs-comment">- 参数：</span><br><span class="hljs-comment">- detachstate：</span><br><span class="hljs-comment">        PTHREAD_CREATE_DETACHED表示设置了线程分离</span><br><span class="hljs-comment">        PTHREAD_CREATE_JOINABLE</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> detachstate)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 功能：设置线程分离的状态属性</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="3、线程同步（重点）"><a href="#3、线程同步（重点）" class="headerlink" title="3、线程同步（重点）"></a>3、线程同步（重点）</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多 个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 </p><p>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共 享资源的其他线程不应终端该片段的执行。 </p><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该 线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。</p><h5 id="卖票程序"><a href="#卖票程序" class="headerlink" title="卖票程序"></a>卖票程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用多线程实现卖票的案例</span><br><span class="hljs-comment">    有3个窗口，一共是100张票</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;<br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(tickets &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>        tickets--;<span class="hljs-comment">// 临界数据</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 创建三个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2, tid3;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 回收子线程的资源, 阻塞</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 设置线程分离，好处，自动回收资源，不需要主线程去回收</span><br>    <span class="hljs-comment">// pthread_detach(tid1);</span><br>    <span class="hljs-comment">// pthread_detach(tid2);</span><br>    <span class="hljs-comment">// pthread_detach(tid3);</span><br><br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>表示出线程同步的问题，多个线程并发同时执行的代码，产生数据安全问题。</p><h5 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h5><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同 时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</p><p> 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。</p><p>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每 一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议</p><ul><li>针对共享资源锁定互斥量 </li><li>访问共享资源 </li><li>对互斥量解锁</li></ul><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示：</p><img src="/2024/06/02/MyWebServer/%E4%BA%92%E6%96%A5%E9%87%8F.png" class=""><p><strong>互斥量相关操作函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> 互斥量的类型 <span class="hljs-type">pthread_mutex_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> </span><br><span class="hljs-params"><span class="hljs-type">pthread_mutexattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    互斥量的类型 pthread_mutex_t</span><br><span class="hljs-comment">    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);// 初始化</span><br><span class="hljs-comment">        - 功能： 初始化互斥量</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - mutex: 需要初始化的互斥量变量</span><br><span class="hljs-comment">            - attr: 互斥量相关的属性，NULL</span><br><span class="hljs-comment">        - restrict: C语言的修饰符，被修饰的指针，不能由另外一个指针进行操作。</span><br><span class="hljs-comment">            pthread_mutex_t * restrict muutex = xxx;</span><br><span class="hljs-comment">            pthread_mutex_t * restrict mutex1 = mutex 会报错 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_mutex_destroy(pthread_mutex_t *mutex);   // 销毁</span><br><span class="hljs-comment">        - 功能： 释放互斥量的资源</span><br><span class="hljs-comment">    int pthread_mutex_lock(pthread_mutex_t *mutex);// 上锁</span><br><span class="hljs-comment">        - 功能： 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_mutex_trylock(pthread_mutex_t *mutex);// </span><br><span class="hljs-comment">        - 功能： 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br><span class="hljs-comment">        - 功能： 解锁</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用多线程实现卖票的案例</span><br><span class="hljs-comment">    有3个窗口，一共是100张票</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">100</span>;<br><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        <span class="hljs-comment">// 加锁         在临界区之前加上锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(tickets &gt; <span class="hljs-number">0</span>)<br>        &#123;   <br>            usleep(<span class="hljs-number">60000</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>            tickets--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;   <br>            <span class="hljs-comment">// 解锁</span><br>            pthread_mutex_unlock(&amp;mutex);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建三个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2, tid3;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 回收子线程的资源, 阻塞</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br>    pthread_mutex_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="死锁（重点）"><a href="#死锁（重点）" class="headerlink" title="死锁（重点）"></a>死锁（重点）</h5><p>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。</p><p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用， 它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p><p>死锁的几种场景：</p><ul><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占资源</li></ul><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形， 当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想<strong>读取</strong>这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就<strong>无法读访问共享资源</strong>了，但是实际上多个线程同时<strong>读</strong>访问共享资源并不会导致问题。</p><p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够<strong>允许多个读出，但只允许一个写入的需求</strong>，线程提供了读写锁来实现。</p><p>读写锁特点：</p><ul><li>如果有其他线程读数据，则允许其它线程执行读操作，但不允许写操作</li><li>如果有其他线程写数据，则其他线程都不允许读、写操作</li><li>写是独占的，写的优先级高    (写锁先加，有写锁，则读锁阻塞，等待写锁完成)</li></ul><p><strong>读写锁相关函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">读写锁的类型 <span class="hljs-type">pthread_rwlock_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_init</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *<span class="hljs-keyword">restrict</span> rwlock, <span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_rdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_tryrdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_wrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_trywrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    读写锁的类型 pthread_rwlock_t</span><br><span class="hljs-comment">    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</span><br><span class="hljs-comment">    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment">    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    案列：8个线程操作同一个全局变量</span><br><span class="hljs-comment">    3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _XOPEN_SOURCE 500  </span><br><br><span class="hljs-comment">// 创建一个共享数据</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 创建读写锁</span><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">writeNum</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_rwlock_wrlock(&amp;rwlock);<br>        num++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++write, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">readNum</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_rwlock_rdlock(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;===read, tid: %ld, num: %d\n&quot;</span>, pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建三个读线程、五个写线程</span><br>    <span class="hljs-type">pthread_t</span> wtids[<span class="hljs-number">3</span>], rtids[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)      pthread_create(&amp;wtids[i], <span class="hljs-literal">NULL</span>, writeNum, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)      pthread_create(&amp;rtids[i], <span class="hljs-literal">NULL</span>, readNum, <span class="hljs-literal">NULL</span>);<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)      pthread_detach(wtids[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)      pthread_detach(rtids[i]);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    pthread_rwlock_destory(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>pthread_rwlock_t 未定义的问题:</strong></p><p>最近在linux上次编译时出现pthread_rwlock_t没有定义的现象.但是已经include了pthread.h,网上查了一些资料后发现,原因竟然是因为显示使用了-std&#x3D;c99参数导致.</p><p> 在c99没有完全实现时,如果不显示指定-std, 则gcc默认使用gnu89(或gnu90)标准.</p><p>一般而言,</p><p>​        gnuXX标准 &#x3D; cXX标准 + GNU extension</p><p> 而pthread_rwlock_t正好就是GNU extension的一部分. 所以指定使用c99就会把GNU extension禁用,造成pthread_rwlock_t未定义的问题.</p><h5 id="生产者和消费者模型"><a href="#生产者和消费者模型" class="headerlink" title="生产者和消费者模型"></a>生产者和消费者模型</h5><img src="/2024/06/02/MyWebServer/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png" class=""><p>生产者和消费者模型中的对象</p><ol><li>生产者</li><li>消费者</li><li>容器</li></ol><h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>配合互斥量去使用，实现线程同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">条件变量的类型 <span class="hljs-type">pthread_cond_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<span class="hljs-comment">// 初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<span class="hljs-comment">// 释放资源</span><br><span class="hljs-comment">//  等待唤醒，调用了该函数，线程会阻塞</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex)</span>;<br><span class="hljs-comment">// 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_timedwait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *<span class="hljs-keyword">restrict</span> abstime)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<span class="hljs-comment">// 唤醒一个或部分等待的线程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<span class="hljs-comment">// 唤醒全部等待的线程</span><br></code></pre></td></tr></table></figure><p><strong>代码示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    生产者消费者模型(粗略版本)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-comment">// 创建条件变量</span><br><span class="hljs-type">pthread_cond_t</span> cond;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 头节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器里面添加内容， 不断创建新的节点，添加到链表中</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());<br><br>        <span class="hljs-comment">// 只要生产一个，就通知消费者消费</span><br>        pthread_cond_signal(&amp;cond);<br><br>        pthread_mutex_unlock(&amp;mutex);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器中去除内容</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">tmp</span> =</span> head;<br>            head = head-&gt;next;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());<br>            <span class="hljs-built_in">free</span>(tmp);<br>            pthread_mutex_unlock(&amp;mutex);<br>            usleep(<span class="hljs-number">1000</span>); <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 没有数据，需要等待</span><br>            <span class="hljs-comment">// 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞时，会重新加锁</span><br>            pthread_cond_wait(&amp;cond, &amp;mutex);       <br>            pthread_mutex_unlock(&amp;mutex);<br>        &#125;    <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    pthread_cond_init(&amp;cond, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 创建5个生产者线程和5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptids[<span class="hljs-number">5</span>], ctids[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ptids[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ctids[i], <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ptids[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ctids[i]);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    pthread_mutex_destroy(&amp;mutex);<br>    pthread_cond_destroy(&amp;cond);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>通过信号量里面的值，使线程阻塞的，比如5个等都灭了，那就不能接受新的线程了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">信号量的类型 <span class="hljs-type">sem_t</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<span class="hljs-comment">// value 多少个灯</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_timedwait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_getvalue</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> *sval)</span>;<br></code></pre></td></tr></table></figure><p>代码示例：信号量实现生产者和消费者模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    信号量的类型 sem_t</span><br><span class="hljs-comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);// value 多少个灯</span><br><span class="hljs-comment">        - 功能： 初始化信号量</span><br><span class="hljs-comment">        - 参数： </span><br><span class="hljs-comment">            - sem:  信号量变量的地址</span><br><span class="hljs-comment">            - pshared:  0 用在线程间 非0 用在进程间  </span><br><span class="hljs-comment">            - value:  信号量中的值</span><br><span class="hljs-comment">    int sem_destroy(sem_t *sem);</span><br><span class="hljs-comment">        - 功能： 释放资源</span><br><span class="hljs-comment">    int sem_wait(sem_t *sem);</span><br><span class="hljs-comment">        - 功能：对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span><br><span class="hljs-comment">    int sem_trywait(sem_t *sem);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="hljs-comment">    int sem_post(sem_t *sem);</span><br><span class="hljs-comment">        - 功能：对信号量解锁，调用一次对信号量的值+1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">    sem_t psem;</span><br><span class="hljs-comment">    sem_t csem;</span><br><span class="hljs-comment">    init(psem, 0, 8);</span><br><span class="hljs-comment">    init(csem, 0, 0);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    producer()</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;psem);</span><br><span class="hljs-comment">        sem_post(&amp;csem);    </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    customer()</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;csem);</span><br><span class="hljs-comment">        sem_post(&amp;psem)</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    生产者消费者模型(粗略版本)</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-comment">// 创建两个信号量</span><br><span class="hljs-type">sem_t</span> psem, csem;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-comment">// 头节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器里面添加内容， 不断创建新的节点，添加到链表中</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        sem_wait(&amp;psem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());<br><br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;csem);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">customer</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span><br>&#123;   <br>    <span class="hljs-comment">// 往容器中去除内容</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;   <br>        sem_wait(&amp;csem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">tmp</span> =</span> head;<br>        head = head-&gt;next;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());<br>        <span class="hljs-built_in">free</span>(tmp);<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;psem);<br>        usleep(<span class="hljs-number">1000</span>); <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;   <br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    sem_init(&amp;psem, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>    sem_init(&amp;csem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 创建5个生产者线程和5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptids[<span class="hljs-number">5</span>], ctids[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ptids[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_create(&amp;ctids[i], <span class="hljs-literal">NULL</span>, customer, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ptids[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)  pthread_detach(ctids[i]);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    sem_destroy(&amp;csem);<br>    sem_destroy(&amp;psem);<br>    pthread_mutex_destroy(&amp;mutex);<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><h4 id="1、网络结构模式"><a href="#1、网络结构模式" class="headerlink" title="1、网络结构模式"></a>1、网络结构模式</h4><h5 id="C-S结构"><a href="#C-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h5><p><strong>简介</strong></p><p>服务器 - 客户机，即 Client - Server（C&#x2F;S）结构。C&#x2F;S 结构通常采取两层结构。<strong>服务器负责数据的管理，客户机负责完成与用户的交互任务</strong>。客户机是因特网上访问别人信息的机器，服务器则是提供信息供人访问的计算机。 </p><p>客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行 操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用 户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务器，这就对服务器的硬件处理数据能力提出了很高的要求。 </p><p>在C&#x2F;S结构中，应用程序分为两部分：<strong>服务器部分和客户机部分</strong>。服务器部分是多个用户共享的信 息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。</p><p><strong>优点</strong></p><ol><li>能充分发挥客户端 PC 的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 C&#x2F;S 结构客户端响应速度快； </li><li>操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求； </li><li>C&#x2F;S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程；</li><li>安全性较高，C&#x2F;S 一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强，一般高度机密的信息系统采用 C&#x2F;S 结构适宜。</li></ol><p><strong>缺点</strong></p><ol><li>客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病 毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高；</li><li>对客户端的操作系统一般也会有限制，不能够跨平台。</li></ol><h5 id="B-S结构"><a href="#B-S结构" class="headerlink" title="B&#x2F;S结构"></a>B&#x2F;S结构</h5><p><strong>简介</strong></p><p>B&#x2F;S 结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式），是 WEB 兴起后的一种网络结构模式，WEB  浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服 务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 Internet  Explorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据 库进行数据交互。</p><p><strong>优点</strong></p><p>B&#x2F;S 架构最大的优点是总体拥有<strong>成本低、维护方便、 分布性强、开发简单</strong>，可以<strong>不用安装任何专门的软件</strong>就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</p><p><strong>缺点</strong></p><ol><li>通信开销大、系统和数据的安全性较难保障; </li><li>个性特点明显降低，无法实现具有个性化的功能要求； </li><li>协议一般是固定的：http&#x2F;https </li><li>客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低。</li></ol><h4 id="2、MAC地址"><a href="#2、MAC地址" class="headerlink" title="2、MAC地址"></a>2、MAC地址</h4><p>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网 络接口卡NIC。其拥有 MAC 地址，<strong>属于 OSI 模型的第 2 层</strong>，它使得用户可以通过电缆或无线相互连接。</p><p>每一个网卡都有一个被称为 MAC 地址的独一无二的 <strong>48 位串行号</strong>。</p><p><strong>网卡的主要功能：</strong></p><ol><li>数据的封装与解封装、</li><li>链路管理、</li><li>数据编码与译码。</li></ol><p>MAC地址（Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址、 以太网地址、物理地址或硬件地址，它是一个用来确认网络设备位置的位址，由网络设备制造商生产时烧录在网卡中。<strong>在 OSI 模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC位址 。</strong>MAC 地址用于在网络中唯一标识一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址。</p><p>MAC 地址的长度为 48 位（6个字节），通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就 是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由  IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。 形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性</p><h4 id="3、IP地址"><a href="#3、IP地址" class="headerlink" title="3、IP地址"></a>3、IP地址</h4><p><strong>简介</strong></p><p><strong>IP 协议是为计算机网络相互连接进行通信而设计的协议</strong>。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守 IP 协议就可以与因特网互连互通。各个厂家生产的网络系统和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传送数据的基本单元（技术上称之为“帧”）的格式不同。IP 协议实际上是一套由软件程序组成的协议软件，它把各种不同“帧”<strong>统一转换成“IP 数据报”格式</strong>，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“因特网 协议”。</p><p><strong>IP 地址（Internet Protocol Address）是指互联网协议地址</strong>，又译为网际协议地址。IP 地址是 IP  协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>IP 地址是一个 <strong>32 位</strong>的<strong>二进制</strong>数，通常被分割为 4 个“ 8 位二进制数”（也就是 4 个字节）。IP 地址 通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。 例：点分十进IP地址（100.4.5.6），实际上是 32 位二进制数 （01100100.00000100.00000101.00000110）。</p><p><strong>IP地址编址方式</strong></p><p>最初设计互联网络时，为了便于寻址以及层次化构造网络，每个 IP 地址包括两个标识码（ID），即网络  ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工 作站，服务器和路由器等）有一个主机 ID 与其对应。Internet 委员会定义了 5 种 IP 地址类型以适合不 同容量的网络，即 A 类~ E 类。 其中 A、B、C 3类（如下表格）由 InternetNIC 在全球范围内统一分配，D、E 类为特殊地址。</p><img src="/2024/06/02/MyWebServer/IP%E5%9C%B0%E5%9D%80%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.png" class=""><p><strong>D类IP地址</strong></p><p>D 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命 名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从 224.0.0.0 - 239.255.255.255。</p><p><strong>特殊的网址</strong></p><p>每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机； IP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址； IP 地址中凡是以 “11110”  开头的 E 类 IP 地址都保留用于将来和实验使用。 IP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测 试，如：127.0.0.1可以代表本机IP地址。</p><p><strong>子网掩码</strong></p><p>子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地 址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存 在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和 主机地址两部分。 子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP  地址是在局域网上，还是在广域网上</p><h4 id="4、端口"><a href="#4、端口" class="headerlink" title="4、端口"></a>4、端口</h4><p><strong>简介</strong></p><p>“端口” 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP&#x2F;IP协议中的端口，是逻辑意义上的端口。例如计算机中的80 端口、21 端口、23 端口等。物理端口又称为接口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插 口也属于物理端口的范畴。 </p><p>如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP  地址的端口可以有 65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数， 范围是从 0  到65535（2^16-1）。</p><p><strong>端口类型</strong></p><ol><li><p>周知端口</p><p>周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，<strong>范围从 0 到 1023</strong>，它们紧密 绑定于一些特定的服务。例如 <strong>80 端口分配给 WWW 服务</strong>，<strong>21 端口分配给 FTP 服务</strong>，23 端口分配给  Telnet服务等等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下  WWW 服务的端口是 “80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏 上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口号。比如使用 “8080” 作为 WWW  服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改 变的，比如 139 端口专门用于 NetBIOS 与 TCP&#x2F;IP 之间的通信，不能手动改变。</p></li><li><p>注册端口</p><p><strong>端口号从 1024 到 49151</strong>，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是 用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。</p></li><li><p>动态端口&#x2F;私有端口</p><p><strong>动态端口的范围是从 49152 到 65535</strong>。之所以称为动态端口，是因为它一般不固定分配某种服务，而是 动态分配。</p></li></ol><h4 id="5、网络模型"><a href="#5、网络模型" class="headerlink" title="5、网络模型"></a>5、网络模型</h4><h5 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h5><p>七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参 考模型或七层模型</p><p>它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。</p><img src="/2024/06/02/MyWebServer/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class=""><h5 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h5><p>现在 Internet（因特网）使用的主流协议族是 TCP&#x2F;IP 协议族，它是一个分层、多协议的通信体 系。TCP&#x2F;IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用 层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p><img src="/2024/06/02/MyWebServer/TCP_IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class=""><h4 id="6、协议"><a href="#6、协议" class="headerlink" title="6、协议"></a>6、协议</h4><p><strong>简介</strong></p><p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连 接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语 法、语义、时序。 </p><p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议 （protocol），它最终体现为在网络上传输的数据包的格式。 </p><p>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。</p><p><strong>常见协议</strong></p><p><strong>应用层</strong>常见的协议有：FTP协议（File Transfer Protocol 文件传输协议）、HTTP协议（Hyper Text  Transfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。 </p><p><strong>传输层</strong>常见协议有：TCP协议（Transmission Control Protocol 传输控制协议）、UDP协议（User  Datagram Protocol 用户数据报协议）。</p><p><strong>网络层</strong>常见协议有：IP 协议（Internet Protocol 因特网互联协议）、ICMP 协议（Internet Control  Message Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特 网组管理协议）。 </p><p><strong>网络接口层</strong>常见协议有：ARP协议（Address Resolution Protocol 地址解析协议）、RARP协议 （Reverse Address Resolution Protocol 反向地址解析协议）。</p><p><strong>UDP协议</strong></p><img src="/2024/06/02/MyWebServer/UDP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>源端口号：发送方端口号 </li><li>目的端口号：接收方端口号 </li><li>长度：UDP用户数据报的长度，<strong>最小值是8</strong>（仅有首部） </li><li>校验和：检测UDP用户数据报在传输中是否有错，有错就丢弃</li></ol><p><strong>TCP协议</strong></p><img src="/2024/06/02/MyWebServer/TCP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>源端口号：发送方端口号 </li><li>目的端口号：接收方端口号 </li><li>序列号：本报文段的数据的第一个字节的序号 </li><li>确认序号：期望收到对方下一个报文段的第一个数据字节的序号 </li><li>首部长度（数据偏移）：TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长 度。单位：32位，即以 4 字节为计算单位 </li><li>保留：占 6 位，保留为今后使用，目前应置为 0 </li><li>紧急 URG ：此位置 1 ，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送 </li><li>确认 ACK：仅当 ACK&#x3D;1 时确认号字段才有效，TCP 规定，在连接建立后所有传达的报文段都必须 把 ACK 置1 </li><li>推送 PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立 即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方  TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH &#x3D; 1 的报文段，就尽快地 （即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付 </li><li>复位 RST：用于复位相应的 TCP 连接 </li><li>同步 SYN：仅在三次握手建立 TCP 连接时有效。当 SYN &#x3D; 1 而 ACK &#x3D; 0 时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用 SYN &#x3D; 1 和 ACK &#x3D; 1。因此，SYN 置  1 就表示这是一个连接请求或连接接受报文</li><li>终止 FIN：用来释放一个连接。当 FIN &#x3D; 1 时，表明此报文段的发送方的数据已经发送完毕，并要 求释放运输连接 </li><li>窗口：指发送本报文段的一方的接收窗口（而不是自己的发送窗口） </li><li>校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头 部 </li><li>紧急指针：仅在 URG &#x3D; 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就 是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据</li><li>选项：长度可变，最长可达 40 字节，当没有使用选项时，TCP 首部长度是 20 字节</li></ol><p><strong>IP协议</strong></p><img src="/2024/06/02/MyWebServer/IP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>版本：IP 协议的版本。通信双方使用过的 IP 协议的版本必须一致，目前最广泛使用的 IP 协议版本 号为 4（即IPv4) </li><li>首部长度：单位是 32 位（4 字节） </li><li>服务类型：一般不适用，取值为 0 </li><li>总长度：指首部加上数据的总长度，单位为字节 </li><li>标识（identification）：IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1， 并将此值赋给标识字段 </li><li>标志（flag）：目前只有两位有意义。 标志字段中的最低位记为 MF。MF &#x3D; 1 即表示后面“还有分片”的数据报。MF &#x3D; 0 表示这已是若干数据报片中的最后一个。 标志字段中间的一位记为 DF，意思是“不能分片”，只有当 DF &#x3D; 0 时才允许分片 </li><li>片偏移：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以 8 字节为偏移单位。 </li><li>生存时间：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个 字段。路由器在转发数据之前就把 TTL 值减一，当 TTL 值减为零时，就丢弃这个数据报。 </li><li>协议：指出此数据报携带的数据时使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程，常用的 ICMP(1)，IGMP(2)，TCP(6)，UDP(17)，IPv6（41） </li><li>首部校验和：只校验数据报的首部，不包括数据部分。 </li><li>源地址：发送方 IP 地址 </li><li>目的地址：接收方 IP 地址</li></ol><p><strong>以太网帧协议</strong></p><img src="/2024/06/02/MyWebServer/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%8D%8F%E8%AE%AE.png" class=""><p>类型：0x800表示 IP、0x806表示 ARP、0x835表示 RARP</p><p><strong>ARP协议</strong></p><img src="/2024/06/02/MyWebServer/ARP%E5%8D%8F%E8%AE%AE.png" class=""><ol><li>硬件类型：1 表示 MAC 地址 </li><li>协议类型：0x800 表示 IP 地址 </li><li>硬件地址长度：6 </li><li>协议地址长度：4 </li><li>操作：1 表示 ARP 请求，2 表示 ARP 应答，3 表示 RARP 请求，4 表示 RARP 应答</li></ol><p><strong>封装</strong></p><p>上层协议是如何使用下层协议提供的服务的呢？其实这是通过<strong>封装（encapsulation）实现</strong>的。应用<strong>程序数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递</strong>。每层协议都将<strong>在上层数据的基础上加上自己的头部信息</strong>（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。</p><img src="/2024/06/02/MyWebServer/%E5%B0%81%E8%A3%85.png" class=""><p><strong>分用</strong></p><p>当帧到达目的主机时，将沿着协议栈<strong>自底向上依次传递</strong>。各层协议依次处理帧中本层负责的头部数据， 以获取所需的信息，并最终<strong>将处理后的帧交给目标应用程序</strong>。这个过程称为分用（demultiplexing）。 </p><p>分用是依靠头部信息中的类型字段实现的。</p><img src="/2024/06/02/MyWebServer/%E5%88%86%E7%94%A8.png" class="">]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode和Git的使用</title>
    <link href="/2024/06/01/Vscode%E5%92%8CGit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/01/Vscode%E5%92%8CGit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用Vscode和github完成代码版本控制"><a href="#如何使用Vscode和github完成代码版本控制" class="headerlink" title="如何使用Vscode和github完成代码版本控制"></a>如何使用Vscode和github完成代码版本控制</h1><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><p>参考内容：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896827951938304">廖雪峰git教程</a></p><h3 id="1、创建本地版本库"><a href="#1、创建本地版本库" class="headerlink" title="1、创建本地版本库"></a>1、创建本地版本库</h3><h4 id="1）选择合适的地方，创建一个空目录，并进入目录"><a href="#1）选择合适的地方，创建一个空目录，并进入目录" class="headerlink" title="1）选择合适的地方，创建一个空目录，并进入目录"></a>1）选择合适的地方，创建一个空目录，并进入目录</h4><p>win系统下最好不包括中文目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> MyWebServer</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> MyWebServer</span><br></code></pre></td></tr></table></figure><h4 id="2）将目录变成git可以管理的仓库"><a href="#2）将目录变成git可以管理的仓库" class="headerlink" title="2）将目录变成git可以管理的仓库"></a>2）将目录变成git可以管理的仓库</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">$ git <span class="hljs-keyword">init</span><br><span class="hljs-type">Initialized</span> empty <span class="hljs-type">Git</span> repository <span class="hljs-keyword">in</span> <span class="hljs-type">E</span>:<span class="hljs-regexp">/MyGit/</span><span class="hljs-type">MyWebServer</span><span class="hljs-regexp">/.git/</span><br><br>ls <span class="hljs-operator">-</span>ah<span class="hljs-comment">// Linux下可以看见隐藏的文件</span><br></code></pre></td></tr></table></figure><p>此时会生成一个 <strong>.git</strong> 文件，是 Git 用来跟踪管理版本的</p><h4 id="3）把文件添加到版本库"><a href="#3）把文件添加到版本库" class="headerlink" title="3）把文件添加到版本库"></a>3）把文件添加到版本库</h4><p>在<strong>新建的目录下</strong>，新建一个 <strong>readme.md</strong> 文件，文件内写上（不要用win自带的文本编辑器打开编写）：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mercury">Git <span class="hljs-keyword">is</span> a version control system.<br>Git <span class="hljs-keyword">is</span> free software.<br></code></pre></td></tr></table></figure><p>使用 <strong>Git</strong> 命令 把文件添加到仓库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 第一步，添加文件到仓库</span><br>$ git add readme<span class="hljs-selector-class">.md</span><br><br><span class="hljs-comment">// 第二步，将文件提交到仓库</span><br>$ git commit -m <span class="hljs-string">&quot;添加本次仓库测试的文档&quot;</span><br><br><span class="hljs-selector-attr">[main (root-commit) 8d1a06f]</span> 添加本次仓库测试的文档<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">0</span> <span class="hljs-built_in">insertions</span>(+), <span class="hljs-number">0</span> <span class="hljs-built_in">deletions</span>(-)<br> create mode <span class="hljs-number">100644</span> readme<span class="hljs-selector-class">.md</span><br><br></code></pre></td></tr></table></figure><p><strong>git commit -m “添加本次仓库测试的文档”</strong> 命令，**-m** 后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><h3 id="2、添加远程库"><a href="#2、添加远程库" class="headerlink" title="2、添加远程库"></a>2、添加远程库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><h4 id="1）在GitHub上创建一个新的仓库"><a href="#1）在GitHub上创建一个新的仓库" class="headerlink" title="1）在GitHub上创建一个新的仓库"></a>1）在GitHub上创建一个新的仓库</h4><p>图形化操作</p><h4 id="2）绑定远程仓库"><a href="#2）绑定远程仓库" class="headerlink" title="2）绑定远程仓库"></a>2）绑定远程仓库</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用命令下面命令绑定远程库      git remote add [远端仓库别名] [远端仓库地址]</span><br>$ git remote add MyWebServer_origin git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:zy674517173/MyWebServer_origin.git<br></code></pre></td></tr></table></figure><h4 id="3）把本地库的内容推送到远程库"><a href="#3）把本地库的内容推送到远程库" class="headerlink" title="3）把本地库的内容推送到远程库"></a>3）把本地库的内容推送到远程库</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 使用命令下面命令推送      git push -u [远端仓库别名] [推送的位置]</span><br>$ git push -u <span class="hljs-type">MyWebServer_origin</span> main<br><br><span class="hljs-type">Enumerating</span> objects: <span class="hljs-number">5</span>, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Counting</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">5</span>/<span class="hljs-number">5</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Delta</span> compression using up <span class="hljs-keyword">to</span> <span class="hljs-number">12</span> threads<br><span class="hljs-type">Compressing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">2</span>/<span class="hljs-number">2</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Writing</span> objects: <span class="hljs-number">100</span>% (<span class="hljs-number">4</span>/<span class="hljs-number">4</span>), <span class="hljs-number">384</span> <span class="hljs-built_in">bytes</span> | <span class="hljs-number">384.00</span> <span class="hljs-type">KiB</span>/s, <span class="hljs-keyword">done</span>.<br><span class="hljs-type">Total</span> <span class="hljs-number">4</span> (delta <span class="hljs-number">1</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">0</span> (from <span class="hljs-number">0</span>)<br>remote: <span class="hljs-type">Resolving</span> deltas: <span class="hljs-number">100</span>% (<span class="hljs-number">1</span>/<span class="hljs-number">1</span>), <span class="hljs-keyword">done</span>.<br><span class="hljs-type">To</span> github.com:zy674517173/<span class="hljs-type">MyWebServer_origin</span>.git<br>   af59730..<span class="hljs-number">5</span>aa9a4d  main -&gt; main<br>branch <span class="hljs-symbol">&#x27;main&#x27;</span> set up <span class="hljs-keyword">to</span> track <span class="hljs-symbol">&#x27;MyWebServer_origin</span>/main&#x27;.<br></code></pre></td></tr></table></figure><p><strong>报错</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">error: failed <span class="hljs-built_in">to</span> push some refs <span class="hljs-built_in">to</span> <span class="hljs-string">&#x27;github.com:zy674517173/MyWebServer_origin.git&#x27;</span><br>hint: Updates were rejected because <span class="hljs-keyword">the</span> remote <span class="hljs-keyword">contains</span> work that you <span class="hljs-built_in">do</span> <span class="hljs-keyword">not</span><br>hint: have locally. This is usually caused <span class="hljs-keyword">by</span> another repository pushing <span class="hljs-built_in">to</span><br>hint: <span class="hljs-keyword">the</span> same ref. If you want <span class="hljs-built_in">to</span> integrate <span class="hljs-keyword">the</span> remote changes, use<br>hint: <span class="hljs-string">&#x27;git pull&#x27;</span> <span class="hljs-keyword">before</span> pushing again.<br>hint: See <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br><br>解决方案<br>将仓库里的 README.md 文件删除，然后执行命令<br>$ git pull MyWebServer_origin main <span class="hljs-comment">--allow-unrelated-histories   // 从远端仓库拉取，同步本地</span><br></code></pre></td></tr></table></figure><h4 id="4）后续"><a href="#4）后续" class="headerlink" title="4）后续"></a>4）后续</h4><p>从现在开始，本地做了提交，就可以通过命令</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> MyWebServer_origin main<br></code></pre></td></tr></table></figure><p>把本地的 <strong>main</strong> 分支的最新修改推送至 GitHub 。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code> 是默认习惯命名；</p><p>关联后，使用命令 <strong>git push -u origin master</strong> 第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令 <strong>git push origin master</strong> 推送最新修改；</p><h4 id="5）删除远程库"><a href="#5）删除远程库" class="headerlink" title="5）删除远程库"></a>5）删除远程库</h4><h5 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h5><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用 <strong>git remote rm [name]</strong> 命令。使用前，建议先用 <strong>git remote -v</strong> 查看远程库的信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>MyWebServer_origin      git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:zy674517173/MyWebServer_origin.git (fetch)<br>MyWebServer_origin      git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:zy674517173/MyWebServer_origin.git (push)<br></code></pre></td></tr></table></figure><p>然后根据名字删除，比如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> MyWebServer_origin<br></code></pre></td></tr></table></figure><h2 id="VsCode内使用Git版本控制"><a href="#VsCode内使用Git版本控制" class="headerlink" title="VsCode内使用Git版本控制"></a>VsCode内使用Git版本控制</h2><p>在VsCode中打开本地仓库，然后点击版本控制，如果提示 <strong>未找到Git。请安装Git，或在git.path设置中配置</strong></p><p>配置过程：设置 —&gt; 在搜索框输入 <code>git.path</code> —&gt; settings.json 中编辑</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// win系统</span><br><span class="hljs-string">&quot;git.path&quot;</span>: <span class="hljs-string">&quot;E:<span class="hljs-subst">\\</span>Program Files<span class="hljs-subst">\\</span>Git<span class="hljs-subst">\\</span>bin<span class="hljs-subst">\\</span>git.exe&quot;</span><br><br><span class="hljs-comment">// linux系统</span><br><span class="hljs-string">&quot;git.path&quot;</span>: <span class="hljs-string">&quot;/Program Files/Git/bin/git.exe&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>General</title>
    <link href="/2024/05/31/General/"/>
    <url>/2024/05/31/General/</url>
    
    <content type="html"><![CDATA[<h1 id="总则"><a href="#总则" class="headerlink" title="总则"></a>总则</h1><p>hexo官方网站：[<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/31/hello-world/"/>
    <url>/2024/05/31/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远端网址"><a href="#部署到远端网址" class="headerlink" title="部署到远端网址"></a>部署到远端网址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><h3 id="Hexo三连"><a href="#Hexo三连" class="headerlink" title="Hexo三连"></a>Hexo三连</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="Hexo遇到的问题"><a href="#Hexo遇到的问题" class="headerlink" title="Hexo遇到的问题"></a>Hexo遇到的问题</h2><h3 id="1、部署到GitHub后不能显示主题，只有文字"><a href="#1、部署到GitHub后不能显示主题，只有文字" class="headerlink" title="1、部署到GitHub后不能显示主题，只有文字"></a>1、部署到GitHub后不能显示主题，只有文字</h3><p><strong>原因：</strong> </p><p>1、GitHub 上的博客搭建到了仓库里，也就是博客跟地址是<a href="https://xxx.github.io/">https://XXX.github.io/</a><repository_name>上，而不是根目录<a href="https://xxx.github.io/%E4%B8%AD">https://XXX.github.io/中</a></p><p>2.由于主题中的各种图片、js脚本都是默认根路径的</p><p><strong>如何修改：</strong> 将Hexo的 <code>config.yml</code> 中的 <code>url</code> 改为根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 原来是 url: https://zy674517173.github.io/archive<br>url: https://zy674517173.github.io<br></code></pre></td></tr></table></figure><h3 id="2、如何在Hexo中插入图片"><a href="#2、如何在Hexo中插入图片" class="headerlink" title="2、如何在Hexo中插入图片"></a>2、如何在Hexo中插入图片</h3><p>最简单的方法是安装 hexo-image-link 插件，<a href="http://home.ustc.edu.cn/~sdyzzy/posts/36e27ee1.html">参考博客</a></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">cnpm install hexo-<span class="hljs-built_in">image</span>-link --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
