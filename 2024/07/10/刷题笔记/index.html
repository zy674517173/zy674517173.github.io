

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="张同学">
  <meta name="keywords" content="">
  
    <meta name="description" content="刷题笔记杂记STL基础123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题笔记">
<meta property="og:url" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hello-ZY">
<meta property="og:description" content="刷题笔记杂记STL基础123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/240_%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1.png">
<meta property="article:published_time" content="2024-07-10T14:08:20.000Z">
<meta property="article:modified_time" content="2024-10-24T13:36:32.547Z">
<meta property="article:author" content="张同学">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zy674517173.github.io/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>刷题笔记 - Hello-ZY</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zy674517173.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hello-ZY</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="刷题笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-10 22:08" pubdate>
          2024年7月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          266 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">刷题笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><h2 id="STL基础"><a href="#STL基础" class="headerlink" title="STL基础"></a><strong>STL基础</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector, 变长数组，倍增的思想<br>    <span class="hljs-built_in">size</span>()  返回元素个数<br>    <span class="hljs-built_in">empty</span>()  返回是否为空<br>    <span class="hljs-built_in">clear</span>()  清空<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br>    支持比较运算，按字典序<br><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）<br><br>string，字符串<br>    <span class="hljs-built_in">size</span>()/<span class="hljs-built_in">length</span>()  返回字符串长度<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">substr</span>(起始下标，(子串长度))  返回子串<br>    <span class="hljs-built_in">c_str</span>()  返回字符串所在字符数组的起始地址<br><br>queue, 队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向队尾插入一个元素<br>    <span class="hljs-built_in">front</span>()  返回队头元素<br>    <span class="hljs-built_in">back</span>()  返回队尾元素<br>    <span class="hljs-built_in">pop</span>()  弹出队头元素<br><br>priority_queue, 优先队列，默认是大根堆<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  插入一个元素<br>    <span class="hljs-built_in">top</span>()  返回堆顶元素<br>    <span class="hljs-built_in">pop</span>()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br>stack, 栈<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">push</span>()  向栈顶插入一个元素<br>    <span class="hljs-built_in">top</span>()  返回栈顶元素<br>    <span class="hljs-built_in">pop</span>()  弹出栈顶元素<br><br>deque, 双端队列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">front</span>()/<span class="hljs-built_in">back</span>()<br>    <span class="hljs-built_in">push_back</span>()/<span class="hljs-built_in">pop_back</span>()<br>    <span class="hljs-built_in">push_front</span>()/<span class="hljs-built_in">pop_front</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    []<br><br>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    <span class="hljs-built_in">size</span>()<br>    <span class="hljs-built_in">empty</span>()<br>    <span class="hljs-built_in">clear</span>()<br>    <span class="hljs-built_in">begin</span>()/<span class="hljs-built_in">end</span>()<br>    ++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br><br>    set/<span class="hljs-function">multiset</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入一个数</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span>  查找一个数</span><br><span class="hljs-function">    	</span><br><span class="hljs-function">            <span class="hljs-comment">//</span></span><br><span class="hljs-function">            map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator iter </span>= mapS.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(iter != mapS.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-comment">// 没找到就是返回的数据结构</span><br>            <br>        <span class="hljs-built_in">count</span>()  返回某一个数的个数<br>        <span class="hljs-built_in">erase</span>()<br>            (<span class="hljs-number">1</span>) 输入是一个数x，删除所有<span class="hljs-function">x   <span class="hljs-title">O</span><span class="hljs-params">(k + logn)</span></span><br><span class="hljs-function">            <span class="hljs-params">(<span class="hljs-number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">    		</span><br><span class="hljs-function">                <span class="hljs-comment">// set 集合容器</span></span><br><span class="hljs-function">                <span class="hljs-comment">// 初始化列表中的顺序会自动排序</span></span><br><span class="hljs-function">                set&lt;<span class="hljs-type">int</span>&gt; se</span>&#123; <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> &#125;;<br>                <span class="hljs-comment">// 删除元素 7</span><br>                se.<span class="hljs-built_in">erase</span>(<span class="hljs-number">7</span>);<br>    <br>        <span class="hljs-built_in">lower_bound</span>()/<span class="hljs-built_in">upper_bound</span>()<br>            <span class="hljs-built_in">lower_bound</span>(x)  返回大于等于x的最小的数的迭代器<br>            <span class="hljs-built_in">upper_bound</span>(x)  返回大于x的最小的数的迭代器<br>    map/<span class="hljs-function">multimap</span><br><span class="hljs-function">        <span class="hljs-title">insert</span><span class="hljs-params">()</span>  插入的数是一个pair</span><br><span class="hljs-function">        <span class="hljs-title">erase</span><span class="hljs-params">()</span>  输入的参数是pair或者迭代器</span><br><span class="hljs-function">        <span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(logn)</span></span><br><span class="hljs-function">        <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span><br><span class="hljs-function">    和上面类似，增删改查的时间复杂度是 <span class="hljs-title">O</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">    不支持 <span class="hljs-title">lower_bound</span><span class="hljs-params">()</span>/<span class="hljs-title">upper_bound</span><span class="hljs-params">()</span>， 迭代器的++，--</span><br><span class="hljs-function"></span><br><span class="hljs-function">bitset, 圧位</span><br><span class="hljs-function">    bitset&lt;10000&gt; s</span>;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []<br><br>    <span class="hljs-built_in">count</span>()  返回有多少个<span class="hljs-number">1</span><br><br>    <span class="hljs-built_in">any</span>()  判断是否至少有一个<span class="hljs-number">1</span><br>    <span class="hljs-built_in">none</span>()  判断是否全为<span class="hljs-number">0</span><br><br>    <span class="hljs-built_in">set</span>()  把所有位置成<span class="hljs-number">1</span><br>    <span class="hljs-built_in">set</span>(k, v)  将第k位变成v<br>    <span class="hljs-built_in">reset</span>()  把所有位变成<span class="hljs-number">0</span><br>    <span class="hljs-built_in">flip</span>()  等价于~<br>    <span class="hljs-built_in">flip</span>(k) 把第k位取反<br><br></code></pre></td></tr></table></figure>

<h2 id="判断是否是回文串"><a href="#判断是否是回文串" class="headerlink" title="判断是否是回文串"></a>判断是否是回文串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span>(left &lt; right)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(str[left] != str[right])<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="洛谷刷题"><a href="#洛谷刷题" class="headerlink" title="洛谷刷题"></a>洛谷刷题</h1><p>产生长度为5的回文数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (d1 = <span class="hljs-number">1</span>; d1 &lt;= <span class="hljs-number">9</span>; d1+=<span class="hljs-number">2</span>) &#123;    <span class="hljs-comment">// 只有奇数才会是素数</span><br>     <span class="hljs-keyword">for</span> (d2 = <span class="hljs-number">0</span>; d2 &lt;= <span class="hljs-number">9</span>; d2++) &#123;<br>         <span class="hljs-keyword">for</span> (d3 = <span class="hljs-number">0</span>; d3 &lt;= <span class="hljs-number">9</span>; d3++) &#123;<br>           palindrome = <span class="hljs-number">10000</span>*d1 + <span class="hljs-number">1000</span>*d2 +<span class="hljs-number">100</span>*d3 + <span class="hljs-number">10</span>*d2 + d1;<span class="hljs-comment">//(处理回文数...)</span><br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>埃氏筛：给定整数n ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i]) &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>二维vector的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">s</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure>

<p>另外sort不能对二维数组进行排序</p>
<h1 id="力扣刷题"><a href="#力扣刷题" class="headerlink" title="力扣刷题"></a>力扣刷题</h1><h2 id="面试经典150题"><a href="#面试经典150题" class="headerlink" title="面试经典150题"></a>面试经典150题</h2><h3 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h3><h4 id="88、合并两个有序数组"><a href="#88、合并两个有序数组" class="headerlink" title="88、合并两个有序数组"></a>88、合并两个有序数组</h4><p>归并的思想</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m+n)</span></span>;<br><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[i] &lt;= nums2[j])<br>                res[k++] = nums1[i++];<br>            <span class="hljs-keyword">else</span><br>                res[k++] = nums2[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i &lt; m)    res[k++] = nums1[i++];<br>        <span class="hljs-keyword">while</span>(j &lt; n)    res[k++] = nums2[j++];<br><br>        nums1 = res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>官方题解</strong></p>
<ol>
<li><p>直接合并后排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &lt; m + n; i++)<br>            nums1[i] = nums2[i - m];<br><br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>双指针   就是归并的思想</p>
</li>
<li><p>逆向双指针      因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进 <em>nums</em>1 的最后面</p>
</li>
</ol>
<h4 id="27、移除元素"><a href="#27、移除元素" class="headerlink" title="27、移除元素"></a>27、移除元素</h4><p>由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。</p>
<ul>
<li>如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</li>
<li>如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; right++)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(nums[right] != val)<br>            &#123;<br>                nums[left++] = nums[right]; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="26、删除有序数组中的重复项"><a href="#26、删除有序数组中的重复项" class="headerlink" title="26、删除有序数组中的重复项"></a>26、删除有序数组中的重复项</h4><p>双指针</p>
<p>定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> n; <br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">1</span>; right &lt; n; right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != nums[right - <span class="hljs-number">1</span>])  <br>            &#123;   nums[left] = nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="80、删除有序数组中的重复项Ⅱ"><a href="#80、删除有序数组中的重复项Ⅱ" class="headerlink" title="80、删除有序数组中的重复项Ⅱ"></a>80、删除有序数组中的重复项Ⅱ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">1</span>; right &lt; n; right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != nums[right - <span class="hljs-number">1</span>])<br>            &#123;<br>                cnt = <span class="hljs-number">1</span>;<br>                nums[left] = nums[right];<br>                left++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(nums[right] == nums[right - <span class="hljs-number">1</span>] &amp;&amp; cnt == <span class="hljs-number">1</span>)<br>            &#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                nums[left] = nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>自己思考的代码，运行部分用例出错，下面这个用例出错</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入<br>nums =<br><span class="hljs-string">[1,1,1,2,2,3]</span><br>输出<br><span class="hljs-string">[1,1,2,2,3,3]</span><br>预期结果<br><span class="hljs-string">[1,1,2,2,3]</span><br></code></pre></td></tr></table></figure>

<p><strong>改进点</strong></p>
<ul>
<li>我们从数组的第三个元素（<code>left = 2</code>）开始遍历，因为前两个元素无论如何都应该保留。</li>
<li>每次比较 <code>nums[right]</code> 是否和 <code>nums[left - 2]</code> 相同。这样做是为了确保同一个元素最多保留两次。</li>
<li>如果当前 <code>nums[right]</code> 不等于 <code>nums[left - 2]</code>，我们将其保留到 <code>nums[left]</code> 位置，并更新 <code>left</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)  <span class="hljs-keyword">return</span> n;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">2</span>; right &lt; n; right++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != nums[left - <span class="hljs-number">2</span>])<br>            &#123;<br>                nums[left] = nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="169、多数元素"><a href="#169、多数元素" class="headerlink" title="169、多数元素"></a>169、多数元素</h4><p>很多种方法</p>
<ol>
<li>哈希表，分别统计每个出现的次数</li>
<li>排序，众数就是下标为 n &#x2F; 2的数</li>
<li>随机化，因为超过 ⌊2<em>n</em>⌋ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</li>
<li>分治，分别找到两边的众数，如果数 <code>a</code> 是数组 <code>nums</code> 的众数，如果我们将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数。</li>
<li>Boyer-Moore 投票算法，没了解</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/***********************   哈希        *************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            mp[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(mp[nums[i]] &gt;  nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>)<br>            &#123;<br>                res = nums[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/***********************   排序        *************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="189、轮转数组"><a href="#189、轮转数组" class="headerlink" title="189、轮转数组"></a>189、轮转数组</h4><p><strong>题目</strong>：给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p>我想出来的三种方法</p>
<ol>
<li>deque，deque支持双端操作</li>
<li>暴力for循环</li>
<li>数组分段，再合并数组</li>
</ol>
<p>下面是deque的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; mdq;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)    mdq.<span class="hljs-built_in">push_back</span>(nums[i]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = mdq.<span class="hljs-built_in">back</span>();<br>            mdq.<span class="hljs-built_in">pop_back</span>();<br>            mdq.<span class="hljs-built_in">push_front</span>(a);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            nums[i] = mdq.<span class="hljs-built_in">front</span>();<br>            mdq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>官方题解的方法</p>
<ol>
<li><p>使用额外数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    newArr[(i + k) % n] = nums[i];<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>环状替换</p>
</li>
<li><p>数组反转：数组一共反转3次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">原数组：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br>第一次：<span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第二次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第三次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="121、买卖股票的最佳时机"><a href="#121、买卖股票的最佳时机" class="headerlink" title="121、买卖股票的最佳时机"></a>121、买卖股票的最佳时机</h4><p>记录一下最小值就行了</p>
<p>在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> min_price = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            min_price = <span class="hljs-built_in">min</span>(min_price, prices[i]);<br>            ans  = <span class="hljs-built_in">max</span>(prices[i] - min_price, ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="122、买卖股票的最佳实际Ⅱ"><a href="#122、买卖股票的最佳实际Ⅱ" class="headerlink" title="122、买卖股票的最佳实际Ⅱ"></a>122、买卖股票的最佳实际Ⅱ</h4><h2 id="LeetCode热题100"><a href="#LeetCode热题100" class="headerlink" title="LeetCode热题100"></a>LeetCode热题100</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="1、两数之和"><a href="#1、两数之和" class="headerlink" title="1、两数之和"></a>1、两数之和</h4><p>两种方法</p>
<p>第一种遍历，for循环遍历两次</p>
<p>第二种哈希表，表格里的就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; myMap;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(myMap.<span class="hljs-built_in">find</span>(target - nums[i]) != myMap.<span class="hljs-built_in">end</span>())    <span class="hljs-comment">// 找到了</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                res.<span class="hljs-built_in">push_back</span>(myMap[target - nums[i]]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                myMap.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="49、字母异位词"><a href="#49、字母异位词" class="headerlink" title="49、字母异位词"></a>49、字母异位词</h4><p>ASCII 范围 0 - 127，最少 128 进制，经验上取 131 或 13331 冲突率低</p>
<p>两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。</p>
<p>遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。</p>
<p>以下的两种方法分别使用排序和计数作为哈希表的键。</p>
<p><strong>排序做哈希表的键</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; myMap;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str : strs)<br>        &#123;   <br>            string key = str;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(), key.<span class="hljs-built_in">end</span>());<br><br>            myMap[key].<span class="hljs-built_in">push_back</span>(str);<br>            <br>        &#125;<br><br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">begin</span>(); it != myMap.<span class="hljs-built_in">end</span>(); it++)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="128、最长连续序列"><a href="#128、最长连续序列" class="headerlink" title="128、最长连续序列"></a>128、最长连续序列</h4><p><strong>题目</strong></p>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题</p>
<p><strong>思路</strong></p>
<p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n2 )（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p>
<p>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)<br>        &#123;<br>            mySet.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : mySet)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(!mySet.<span class="hljs-built_in">count</span>(num - <span class="hljs-number">1</span>))	<span class="hljs-comment">// ***************  重点  *************</span><br>            &#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(mySet.<span class="hljs-built_in">count</span>(num + len))<br>                &#123;<br>                    len++;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, len);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="283、移动零"><a href="#283、移动零" class="headerlink" title="283、移动零"></a>283、移动零</h4><p>双指针的模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;  <span class="hljs-comment">// left 指 0 ， right 指 非 0</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right; right &lt; nums.<span class="hljs-built_in">size</span>(); right++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(nums[left] != <span class="hljs-number">0</span> &amp;&amp; left &lt; right)<br>            &#123;<br>                left++;<br>            &#125;<br><br>            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="11、盛水最多的容器"><a href="#11、盛水最多的容器" class="headerlink" title="11、盛水最多的容器"></a>11、盛水最多的容器</h4><p>证明过程很恼火，暂时忽略。</p>
<p>只需要知道 left &#x3D; 0， right &#x3D; size() - 1, 然后移动小的那个数字</p>
<p><strong>双指针代表了什么？</strong></p>
<p>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p>
<p><strong>为什么对应的数字较小的那个指针不可能再作为容器的边界了</strong>？</p>
<ul>
<li>求出当前双指针对应的容器的容量；</li>
<li>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-type">int</span> vol = <span class="hljs-built_in">min</span>(height[left], height[right]) * (right - left);<br>            res = <span class="hljs-built_in">max</span>(res, vol);<br>            <span class="hljs-keyword">if</span>(height[left] &lt;= height[right]) left++;<br>            <span class="hljs-keyword">else</span>    right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="15、三数之和"><a href="#15、三数之和" class="headerlink" title="15、三数之和"></a>15、三数之和</h4><p>如果我们直接使用三重循环枚举三元组，会得到 O(N^3) 个满足题目要求的三元组（其中 N 是数组的长度）时间复杂度至少为 O(N^3)。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。</p>
<p>「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：</p>
<ul>
<li>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</li>
<li>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</li>
</ul>
<p>要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。</p>
<p>答案表示为(a,b,c)。我们可以从小到大枚举 <em>b</em>，<strong>同时</strong>从大到小枚举 <em>c</em>，即<strong>第二重循环和第三重循环实际上是并列的关系</strong>。有了这样的发现，我们就可以保持第二重循环不变，而将<strong>第三重循环变成一个从数组最右端开始向左移动的指针</strong>，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; n; a++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">0</span> &amp;&amp; nums[a] == nums[a - <span class="hljs-number">1</span>])     <span class="hljs-comment">// 枚举值要和上次不一样</span><br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> c = n - <span class="hljs-number">1</span>;      <span class="hljs-comment">// c 对应的指针初始化指向数组的最右端</span><br>            <span class="hljs-type">int</span> target = -nums[a];  <br>            <span class="hljs-comment">// 枚举b</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>; b &lt; n; b++)  <br>            &#123;<br>                <span class="hljs-keyword">if</span>(b &gt; a + <span class="hljs-number">1</span> &amp;&amp; nums[b] == nums[b - <span class="hljs-number">1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 需要保证 b 的指针 在 c 的指针的左侧</span><br>                <span class="hljs-keyword">while</span>(b &lt; c &amp;&amp; nums[b] + nums[c] &gt; target)<br>                &#123;<br>                    c--;<br>                &#125;<br>                <span class="hljs-comment">// 如果指针重合，随着b后续的增加，就不会有满足条件a+b+c=0的，可以退出循环</span><br>                <span class="hljs-keyword">if</span>(b == c)  <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-keyword">if</span>(nums[b] + nums[c] == target)<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(&#123;nums[a], nums[b], nums[c]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>三种循环里面的后两层可以用双指针来替换，c指向某位，b指向a的下一位</p>
<h4 id="42、接雨水"><a href="#42、接雨水" class="headerlink" title="42、接雨水"></a>42、接雨水</h4><p>三种方法</p>
<ol>
<li><p>动态规划</p>
</li>
<li><p>单调栈</p>
</li>
<li><p>双指针</p>
<p>采用双指针的方法，建议去看题解里的示意图</p>
</li>
</ol>
<p>注意到下标 i 处能接的雨水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组 leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。</p>
<p>维护两个指针 left 和 right，以及两个变量 leftMax 和 rightMax，初始时 left&#x3D;0,right&#x3D;n−1,leftMax&#x3D;0,rightMax&#x3D;0。指针 left 只会向右移动，指针 right 只会向左移动，在移动指针的过程中维护两个变量 leftMax 和 rightMax 的值。</p>
<p>当两个指针没有相遇时，进行如下操作：</p>
<ul>
<li>使用 height[left] 和 height[right] 的值更新 leftMax 和 rightMax 的值；</li>
<li>如果 height[left]&lt;height[right]，则必有 leftMax&lt;rightMax，下标 left 处能接的雨水量等于 leftMax−height[left]，将下标 left 处能接的雨水量加到能接的雨水总量，然后将 left 加 1（即向右移动一位）；</li>
<li>如果 height[left]≥height[right]，则必有 leftMax≥rightMax，下标 right 处能接的雨水量等于 rightMax−height[right]，将下标 right 处能接的雨水量加到能接的雨水总量，然后将 right 减 1（即向左移动一位）。</li>
</ul>
<p>当两个指针相遇时，即可得到能接的雨水总量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftmax = <span class="hljs-number">0</span>, rightmax = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            leftmax = <span class="hljs-built_in">max</span>(height[left], leftmax);<br>            rightmax = <span class="hljs-built_in">max</span>(height[right], rightmax);<br><br>            <span class="hljs-keyword">if</span>(leftmax &lt;= rightmax)<br>            &#123;<br>                result = result + (leftmax - height[left]);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result = result + (rightmax - height[right]);<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="3、无重复字符的最长子串"><a href="#3、无重复字符的最长子串" class="headerlink" title="3、无重复字符的最长子串"></a>3、无重复字符的最长子串</h4><p>题目：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><strong>滑动窗口</strong></p>
<p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk；</p>
<p>在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；</p>
<p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
<p><strong>判断重复字符</strong></p>
<p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; myMap;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(r; r &lt; s.<span class="hljs-built_in">size</span>(); r++)<br>        &#123;   <br>            myMap[s[r]]++;<br><br>            <span class="hljs-keyword">while</span>(myMap[s[r]] == <span class="hljs-number">2</span>)<br>            &#123;<br>                myMap[s[l]]--;<br>                l++;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>使用unordered_set修改代码，之前不用 set 是因为我忘记怎么从set里面删除了，</p>
<p>现在发现了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mySet.<span class="hljs-built_in">erase</span>(删除元素)<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 哈希集合，记录每个字符是否出现过</span><br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; occ;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br>        <span class="hljs-type">int</span> rk = <span class="hljs-number">-1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 左指针向右移动一格，移除一个字符</span><br>                occ.<span class="hljs-built_in">erase</span>(s[i - <span class="hljs-number">1</span>]);		<span class="hljs-comment">//*************移除字符***********</span><br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; !occ.<span class="hljs-built_in">count</span>(s[rk + <span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-comment">// 不断地移动右指针</span><br>                occ.<span class="hljs-built_in">insert</span>(s[rk + <span class="hljs-number">1</span>]);<br>                ++rk;<br>            &#125;<br>            <span class="hljs-comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br>            ans = <span class="hljs-built_in">max</span>(ans, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br>作者：力扣官方题解<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/227999/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br></code></pre></td></tr></table></figure>

<h4 id="438、找到字符串中所有字母异位词"><a href="#438、找到字符串中所有字母异位词" class="headerlink" title="438、找到字符串中所有字母异位词"></a>438、找到字符串中所有字母异位词</h4><p>这个不能用 set 来做，因为如下：</p>
<p>当前代码中，使用了 <code>set</code> 数据结构来比较字符集。但字母异位词不仅要求字符相同，还要求每个字符出现的次数相同，而 <code>set</code> 只存储唯一字符，无法区分字符频率。例如，<code>&quot;abb&quot;</code> 和 <code>&quot;aab&quot;</code> 在集合里看起来是一样的，但它们并不是异位词。</p>
<p>用数组存储p和滑动窗口内的字符数量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = p.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(n &lt; m)   <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ();<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sCnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pCnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            pCnt[p[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sCnt[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(sCnt == pCnt)    res.<span class="hljs-built_in">push_back</span>(i);<br>            <br>            sCnt[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            sCnt[s[i + m] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(sCnt == pCnt)    res.<span class="hljs-built_in">push_back</span>(n - m);	<span class="hljs-comment">// 特例特判，最后一个相同</span><br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><h4 id="560、和为K的子数组"><a href="#560、和为K的子数组" class="headerlink" title="560、和为K的子数组"></a>560、和为K的子数组</h4><p>是要找连续非空的序列，所以不能用回溯算法</p>
<p>有两种方法，一种是暴力枚举，一种是前缀和加哈希表，这里用的是前缀和+哈希表法</p>
<p>建议去看图画就懂了</p>
<p>我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。</p>
<p>作者：力扣官方题解<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/">https://leetcode.cn/problems/subarray-sum-equals-k/solutions/238572/he-wei-kde-zi-shu-zu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pre += nums[i];<br><br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(pre - k) != mp.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                cnt += mp[pre - k];<br>            &#125;<br>            mp[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="239、滑动窗口的最大值"><a href="#239、滑动窗口的最大值" class="headerlink" title="239、滑动窗口的最大值"></a>239、滑动窗口的最大值</h4><p><strong>题目</strong>：给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>思路</strong></p>
<ol>
<li>优先队列</li>
<li>单调队列</li>
<li>分块+预处理</li>
</ol>
<p><strong>优先队列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; mq;		<span class="hljs-comment">/*******    最大堆  *******/</span><br>   <span class="hljs-comment">// 最小堆	priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; minHeap</span><br><span class="hljs-comment">//  priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            mq.<span class="hljs-built_in">push</span>(&#123;nums[i], i&#125;);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;mq.<span class="hljs-built_in">top</span>().first&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)<br>        &#123;<br>            mq.<span class="hljs-built_in">push</span>(&#123;nums[i], i&#125;);<br>            <span class="hljs-keyword">while</span>(mq.<span class="hljs-built_in">top</span>().second &lt;= i - k)<br>            &#123;<br>                mq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(mq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>优先队列会自动构建堆顶是最大元素，然后存入下标来判断最大值是否在滑动窗口内。</p>
<p><strong>单调队列</strong></p>
<p>队列里仅保存下标，</p>
<p>队尾比不过同龄人的删掉，队头超出时代区间的删掉，历史就是这么不断更迭的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        deque&lt;<span class="hljs-type">int</span>&gt; mq;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!mq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[mq.<span class="hljs-built_in">back</span>()])<br>            &#123;<br>                mq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            mq.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans = &#123;nums[mq.<span class="hljs-built_in">front</span>()]&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!mq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[mq.<span class="hljs-built_in">back</span>()])<br>            &#123;<br>                mq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            mq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">while</span>(mq.<span class="hljs-built_in">front</span>() &lt;= i - k)<br>            &#123;<br>                mq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(nums[mq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="76、最小覆盖字串"><a href="#76、最小覆盖字串" class="headerlink" title="76、最小覆盖字串"></a>76、最小覆盖字串</h4><p><strong>题目</strong>：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>思路</strong></p>
<p>滑动窗口</p>
<p><strong>我们在 *s* 上滑动窗口，通过移动 *r* 指针不断扩张窗口。当窗口包含 *t* 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。</strong></p>
<p>如何判断当前的窗口包含所有 t 所需的字符呢？我们可以用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; tm, sm;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : tm)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sm[p.first] &lt; p.second)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slen = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> tlen = t.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(slen &lt; tlen)   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : t) tm[c]++;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> len = INT_MAX, ansL = <span class="hljs-number">-1</span>, ansR = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span>(r &lt; slen)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(tm.<span class="hljs-built_in">find</span>(s[++r]) != tm.<span class="hljs-built_in">end</span>()) <span class="hljs-comment">// r指针右移，只判断t中有的字符</span><br>            &#123;<br>                sm[s[r]]++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>() &amp;&amp; l &lt;= r)    <span class="hljs-comment">// 判断是否包含</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span> &lt; len)<br>                &#123;<br>                    len = r - l + <span class="hljs-number">1</span>;<br>                    ansL = l; <br>                &#125;<br>                <span class="hljs-keyword">if</span>(tm.<span class="hljs-built_in">find</span>(s[l]) != tm.<span class="hljs-built_in">end</span>())  <span class="hljs-comment">// 缩短序列</span><br>                &#123;<br>                    --sm[s[l]];<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ansL == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">string</span>() : s.<span class="hljs-built_in">substr</span>(ansL, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><h4 id="53、最大子数组和"><a href="#53、最大子数组和" class="headerlink" title="53、最大子数组和"></a>53、最大子数组和</h4><p>你在计算最大子数组和时，使用了前缀和，并试图通过找到最小的前缀和位置来计算最大和。但这个逻辑并不能适用于所有情况，特别是当输入数组只有一个负数时。你现在的代码会计算最小前缀和并在此基础上继续计算最大和，这会导致输出为0（因为空子数组的和是0），而实际上应该直接返回单个元素本身。</p>
<p><strong>问题:</strong></p>
<p>当前实现的问题是：在处理像 <code>[-1]</code> 这样的单元素负数数组时，程序默认会找到前缀和最小的情况并返回 <code>0</code>，因为代码试图计算的是从 <code>min_pos</code> 到 <code>n</code> 之间的最大和，而没有考虑到最优解可能是负数的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入<br>nums = [<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>]<br>输出<br><span class="hljs-number">0</span><br>预期结果<br><span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>

<p><strong>正确思路</strong></p>
<ol>
<li>动态规划</li>
<li>分治</li>
</ol>
<p>动态规划的思路：转移过程为：<br>$$<br>f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>, max_value = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + nums[i], nums[i]);<br>            max_value = <span class="hljs-built_in">max</span>(max_value, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_value;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="56、合并区间"><a href="#56、合并区间" class="headerlink" title="56、合并区间"></a>56、合并区间</h4><p>做过相关题的，分为三种情况，只在 ed &lt; a[0] 的时候把线段加入答案</p>
<p>还有注意的一点就是这个lamba表达式，虽然默认的是按照第一个排序，但是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>           <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>       &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-comment">// 按照每个区间的第一个元素升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b) &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-type">int</span> st = <span class="hljs-number">-1</span>, ed = <span class="hljs-number">-1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : intervals) &#123;<br>            <span class="hljs-comment">// 如果当前区间不重叠，保存之前的区间并开始新的区间</span><br>            <span class="hljs-keyword">if</span> (ed &lt; a[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>                st = a[<span class="hljs-number">0</span>];<br>                ed = a[<span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果区间重叠，更新右边界</span><br>                ed = <span class="hljs-built_in">max</span>(ed, a[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 最后一个区间需要单独加入结果</span><br>        <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="189、轮转数组-1"><a href="#189、轮转数组-1" class="headerlink" title="189、轮转数组"></a>189、轮转数组</h4><p><strong>题目</strong>：给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p>我想出来的三种方法</p>
<ol>
<li>deque，deque支持双端操作</li>
<li>暴力for循环</li>
<li>数组分段，再合并数组</li>
</ol>
<p>下面是deque的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        deque&lt;<span class="hljs-type">int</span>&gt; mdq;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)    mdq.<span class="hljs-built_in">push_back</span>(nums[i]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = mdq.<span class="hljs-built_in">back</span>();<br>            mdq.<span class="hljs-built_in">pop_back</span>();<br>            mdq.<span class="hljs-built_in">push_front</span>(a);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            nums[i] = mdq.<span class="hljs-built_in">front</span>();<br>            mdq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>官方题解的方法</p>
<ol>
<li><p>使用额外数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    newArr[(i + k) % n] = nums[i];<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>环状替换</p>
</li>
<li><p>数组反转：数组一共反转3次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">原数组：<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br>第一次：<span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第二次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br>第三次：<span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="238、除自身以外数组的乘积"><a href="#238、除自身以外数组的乘积" class="headerlink" title="238、除自身以外数组的乘积"></a>238、除自身以外数组的乘积</h4><p>分三种情况讨论</p>
<ol>
<li>没有零：就是正常处理</li>
<li>有一个零：除零的哪一位有数，其他全是零</li>
<li>一个以上的零：全都是零</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> mux = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt_zero = <span class="hljs-number">0</span>, cnt_pos = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)<br>            &#123;<br>                mux *= nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cnt_zero++;<br>                cnt_pos = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span>(cnt_zero &gt; <span class="hljs-number">1</span>)&#123;&#125; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt_zero == <span class="hljs-number">1</span>)<br>            res[cnt_pos] = mux;<br>        <span class="hljs-keyword">else</span>       <br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                res[i] = mux / nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>额，才看到，不允许使用除法运算</p>
<p><strong>官方思路</strong></p>
<ol>
<li>左右乘积列表</li>
<li>空间复杂度为O(1)的方法</li>
</ol>
<p>左右乘积列表：初始化两个空数组 <code>L</code> 和 <code>R</code>。对于给定索引 <code>i</code>，<code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// L[i] 代表左侧所有数字的乘积</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">R</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// R[i] 代表右侧所有数字的乘积</span><br><br>        L[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) L[i] = L[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br><br>        R[n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) R[i] = R[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            res[i] = L[i] * R[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="41、缺失的第一个正数"><a href="#41、缺失的第一个正数" class="headerlink" title="41、缺失的第一个正数"></a>41、缺失的第一个正数</h4><p>有点难呢</p>
<p>算法的流程如下：</p>
<ul>
<li>我们将数组中所有小于等于 0 的数修改为 N+1；</li>
<li>我们遍历数组中的每一个数 x，它可能已经被打了标记，因此原本对应的数为 ∣x∣，其中 ∣∣ 为绝对值符号。如果 ∣x∣∈[1,N]，那么我们给数组中的第 ∣x∣−1 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；</li>
<li>在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1，否则答案是第一个正数的位置加 1。</li>
</ul>
<img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/41_%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0.png" srcset="/img/loading.gif" lazyload class="">

<p>作者：力扣官方题解<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/">https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= <span class="hljs-number">0</span>)    nums[i] = n + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;   <br>            <span class="hljs-type">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(num &lt;= n)<br>            &#123;<br>                nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="73、矩阵置零"><a href="#73、矩阵置零" class="headerlink" title="73、矩阵置零"></a>73、矩阵置零</h4><p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法<strong>。</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(*m**n*)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<p><strong>思路</strong></p>
<p> 使用第一行和第一列作为标记</p>
<p>通常我们会使用额外的两个数组来记录哪些行和列需要置零。但我们可以复用矩阵的第一行和第一列，将它们作为标记来记录哪些行和列需要置零。这就减少了空间的额外消耗。</p>
<p>为了达到这个目的，我们需要先处理两个特殊情况：</p>
<ul>
<li>第一行是否需要被置零？</li>
<li>第一列是否需要被置零？</li>
</ul>
<p>这两个问题单独处理，因为我们在用第一行和第一列作为标记时，不希望它们的内容被破坏。接下来，通过两步来完成整个算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> first_col_zero = <span class="hljs-literal">false</span>, first_row_zero = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)<br>            &#123;<br>                first_row_zero = <span class="hljs-literal">true</span>; 		<span class="hljs-comment">// 记录第一行是否需要置零</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>            &#123;<br>                first_col_zero = <span class="hljs-literal">true</span>;	<span class="hljs-comment">// 记录第一列是否需要置零</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)		<span class="hljs-comment">// 使用第一行和第一列作为标记</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)		<span class="hljs-comment">// 从第二行第二列开始置零</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(first_row_zero)	<span class="hljs-comment">// 处理第一行</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>            &#123;<br>                matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(first_col_zero)	<span class="hljs-comment">// 处理第一列</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="54、螺旋矩阵"><a href="#54、螺旋矩阵" class="headerlink" title="54、螺旋矩阵"></a>54、螺旋矩阵</h4><p><strong>第一种方法：模拟</strong></p>
<p>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p>
<p><strong>第二种方法：按层模拟</strong></p>
<p>这个问题的关键在于按照顺时针的螺旋顺序遍历一个矩阵，并返回矩阵中的所有元素。我们可以使用边界变量来控制遍历的范围：上边界 <code>top</code>，下边界 <code>bottom</code>，左边界 <code>left</code>，右边界 <code>right</code>，然后依次按照顺时针的顺序遍历矩阵。每次遍历一行或一列之后，相应的边界会向内收缩。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, bottom = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(top &lt;= bottom &amp;&amp; left &lt;= right)<br>        &#123;	<br>            <span class="hljs-comment">// 从左到右遍历上边</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left; i &lt;= right; i++)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>            &#125;<br>            top++;		<span class="hljs-comment">// 上边界下移</span><br>			<span class="hljs-comment">// 从上到下遍历右边</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = top; i &lt;= bottom; i++)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            &#125;<br>            right--; 	<span class="hljs-comment">// 右边界左移</span><br>			<br>            <span class="hljs-keyword">if</span>(top &lt;= bottom)<br>            &#123;	<span class="hljs-comment">// 从右到左遍历下边</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = right; i &gt;= left; i--)<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[bottom][i]);<br>                &#125;<br>                bottom--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(left &lt;= right)<br>            &#123;	<span class="hljs-comment">// 从下到上遍历左边</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bottom; i &gt;= top; i--)<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>**<code>if (top &lt;= bottom)</code>**：</p>
<ul>
<li>这个判断是在完成从左到右、从上到下的遍历后，为了确保在遍历完顶部和右侧之后，矩阵的底部仍然是有效的。如果<code>top</code>已经大于<code>bottom</code>，说明顶部已经穿越到底部，矩阵的元素已经全部遍历完毕，底部已经不需要再遍历了，所以我们避免再继续处理底部的元素。</li>
</ul>
<p>**<code>if (left &lt;= right)</code>**：</p>
<ul>
<li>这个判断是在从右到左、从下到上的遍历之后进行的，确保在遍历完右侧和底部之后，矩阵的左边仍然是有效的。如果<code>left</code>已经大于<code>right</code>，说明左侧已经穿越到右侧，同理，矩阵的元素已经全部遍历完毕，左侧不再需要遍历。</li>
</ul>
<h4 id="48、旋转图像"><a href="#48、旋转图像" class="headerlink" title="48、旋转图像"></a>48、旋转图像</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
<p><strong>思路</strong></p>
<p>为了实现这一目标，我们可以分两个步骤来完成：</p>
<ol>
<li><p><strong>矩阵转置</strong>：将矩阵的行列进行交换。</p>
</li>
<li><p><strong>每一行翻转</strong>：将转置后的矩阵的每一行进行左右翻转。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br><br>        <span class="hljs-comment">// 矩阵转置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 同一行前后翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;	<br>            <span class="hljs-comment">// reverse(matrix[i].begin(), matrix[i].end()); 用这个更简单</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(l &lt;= r)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][l], matrix[i][r]);<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="240、搜索二维矩阵Ⅱ"><a href="#240、搜索二维矩阵Ⅱ" class="headerlink" title="240、搜索二维矩阵Ⅱ"></a>240、搜索二维矩阵Ⅱ</h4><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/240_%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1.png" srcset="/img/loading.gif" lazyload class="">

<p>为了更高效地解决这个问题，可以利用矩阵的特性——每行从左到右递增，每列从上到下递增。我们可以从矩阵的右上角开始搜索，利用行列的单调性。如果当前值大于目标值，就向左移动；如果当前值小于目标值，就向下移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> col = n - <span class="hljs-number">1</span>, row = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(col &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[row][col] ==  target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target)<br>            &#123;<br>                row++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                col--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="160、相交链表"><a href="#160、相交链表" class="headerlink" title="160、相交链表"></a>160、相交链表</h4><p><strong>思路：</strong></p>
<ol>
<li>获取两个链表的长度：首先你可以遍历两个链表，获取它们的长度 <code>lenA</code> 和 <code>lenB</code>。根据这两个长度的差值，将较长的链表向前移动，使得两个链表的剩余长度相等。</li>
<li>对齐两个链表：如果两个链表的长度不相等，那么可以将较长的链表先向前移动 <code>lenA - lenB</code> 个节点（如果 <code>lenA</code> 比 <code>lenB</code> 长），或者将 <code>lenB - lenA</code> 个节点移除（如果 <code>lenB</code> 比 <code>lenA</code> 长）。</li>
<li>遍历两个链表：接下来，你可以同时遍历两个链表，当某个节点在两个链表中同时出现时，即为它们的交点。</li>
<li>特殊情况：如果两个链表没有相交，最终遍历完之后没有发现相同的节点，那么返回 <code>null</code>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        ListNode *curA = headA;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            curA = curA-&gt;next;<br>        &#125;<br><br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode *curB = headB;<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            curB = curB-&gt;next;<br>        &#125;<br><br>        <br>        curA = headA;<br>        curB = headB;<br>        <br>        <span class="hljs-keyword">if</span>(m &gt; n)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - n; i++) curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - m; i++) curB = curB-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(curA != curB)<br>        &#123;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;  <br><br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="206、反转链表"><a href="#206、反转链表" class="headerlink" title="206、反转链表"></a>206、反转链表</h4><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p>
<p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode *cur = head;<br><br>        ListNode *ne;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = ne;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="234、回文链表"><a href="#234、回文链表" class="headerlink" title="234、回文链表"></a>234、回文链表</h4><p><strong>思路</strong></p>
<p>先反转链表，再依次判断是否相等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverses</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode *cur = head;<br><br>        ListNode *ne;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ne = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = ne;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        ListNode *headB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(head-&gt;val);<br>        ListNode *curB = headB;<br><br>        ListNode *cur = head-&gt;next;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            curB-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br><br>        headB = <span class="hljs-built_in">reverses</span>(headB);<br>        cur = head;<br>        curB = headB;<br><br>        <span class="hljs-keyword">while</span>(cur &amp;&amp; curB)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur-&gt;val != curB-&gt;val)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            cur = cur-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="141、环形链表"><a href="#141、环形链表" class="headerlink" title="141、环形链表"></a>141、环形链表</h4><p>两种方法;</p>
<ol>
<li><p>哈希表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;ListNode*&gt; seen; <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>快慢指针</p>
<p>我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ListNode *fastcur = head-&gt;next;<br>        ListNode *cur = head;<br><br>        <span class="hljs-keyword">while</span>(cur != fastcur)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fastcur == <span class="hljs-literal">nullptr</span> || fastcur-&gt;next == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fastcur = fastcur-&gt;next-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="142、环形链表Ⅱ"><a href="#142、环形链表Ⅱ" class="headerlink" title="142、环形链表Ⅱ"></a>142、环形链表Ⅱ</h4><p>这个和上一题的区别是这个需要返回     开始入环的第一个节点</p>
<p>用到的是哈希表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode *&gt; visited;<br><br>        ListNode *cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(cur))  <span class="hljs-keyword">return</span> cur;<br><br>            visited.<span class="hljs-built_in">insert</span>(cur);<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="21、合并两个有序链表"><a href="#21、合并两个有序链表" class="headerlink" title="21、合并两个有序链表"></a>21、合并两个有序链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *cur = dummy;<br><br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val)<br>            &#123;<br>                cur-&gt;next = list1;<br>                list1 = list1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;next = list2;<br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">nullptr</span>)    cur-&gt;next = list1;<br>        <span class="hljs-keyword">if</span>(list2 != <span class="hljs-literal">nullptr</span>)    cur-&gt;next = list2;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2、两数相加"><a href="#2、两数相加" class="headerlink" title="2、两数相加"></a>2、两数相加</h4><p><strong>题目</strong>：</p>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>        ListNode *cur1 = l1, *cur2 = l2;<br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            cur1 = cur1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(cur2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            cur2 = cur2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(m &lt; n)   <span class="hljs-keyword">return</span> <span class="hljs-built_in">addTwoNumbers</span>(l2, l1);<br><br>        cur1 = l1, cur2 = l2;<br>        <span class="hljs-type">int</span> jin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span> &amp;&amp; cur2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> num = cur1-&gt;val + cur2-&gt;val + jin;<br>            cur1-&gt;val = num % <span class="hljs-number">10</span>;<br>            jin = num / <span class="hljs-number">10</span>;<br><br>            cur1 = cur1-&gt;next;<br>            cur2 = cur2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> num = cur1-&gt;val + jin;<br>            cur1-&gt;val = num % <span class="hljs-number">10</span>;<br>            jin = num / <span class="hljs-number">10</span>;<br><br>            cur1 = cur1-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(jin != <span class="hljs-number">0</span>)<br>        &#123;   <br>            cur1 = l1;<br>            <span class="hljs-keyword">while</span>(cur1-&gt;next != <span class="hljs-literal">nullptr</span>) cur1 = cur1-&gt;next;<br>            cur1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(jin);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>简化代码的简化思路：</p>
<ol>
<li>哑节点 (dummy node)：使用哑节点 <code>dummyHead</code> 可以避免处理头节点的特殊情况，让代码更简洁和通用。最终返回时直接返回 <code>dummyHead-&gt;next</code>。</li>
<li>处理链表不同长度：在遍历链表时，使用 <code>p</code> 和 <code>q</code> 来分别指向 <code>l1</code> 和 <code>l2</code>，如果其中一个链表已经遍历完了，我们用 0 作为该链表的值，继续进行加法运算。</li>
<li>进位处理：每次相加时，将 <code>carry</code> 记录下来，之后的相加都包含这个 <code>carry</code>。如果最后还有进位，则在链表尾部追加一个新的节点。</li>
<li>遍历到链表末尾：使用 <code>p</code> 和 <code>q</code> 分别遍历 <code>l1</code> 和 <code>l2</code>，当其中一个链表提前结束时，继续处理另一个链表的剩余部分。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <br>        ListNode *head = <span class="hljs-literal">nullptr</span>, *tail = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>( l1 != <span class="hljs-literal">nullptr</span> || l2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> n1 = (l1 == <span class="hljs-literal">nullptr</span>) ? <span class="hljs-number">0</span> : l1-&gt;val;<br>            <span class="hljs-type">int</span> n2 = (l2 == <span class="hljs-literal">nullptr</span>) ? <span class="hljs-number">0</span> : l2-&gt;val;<br><br>            <span class="hljs-type">int</span> sum = n1 + n2 + carry;<br><br>            <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                head = tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>                tail = tail-&gt;next;<br>            &#125;<br>            carry = sum / <span class="hljs-number">10</span>;<br><br>            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">nullptr</span>)   l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">nullptr</span>)   l2 = l2-&gt;next;<br><br>            <span class="hljs-keyword">if</span>(carry &gt; <span class="hljs-number">0</span>)   tail-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="19、删除链表的倒数第N个节点"><a href="#19、删除链表的倒数第N个节点" class="headerlink" title="19、删除链表的倒数第N个节点"></a>19、删除链表的倒数第N个节点</h4><p>题目：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点</p>
<p>第一种方法：遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        ListNode *cur = head;<br><br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            cur = cur-&gt;next;<br>        &#125;<br><br>        cur = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - n &amp;&amp; cur != <span class="hljs-literal">nullptr</span>; i++)  cur = cur-&gt;next;<br><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)  cur-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>第二种方法：快慢指针</p>
<p>可以使用 <strong>快慢指针法</strong>，只需遍历一次链表即可完成删除倒数第 <code>n</code> 个节点的操作。基本思路是设置两个指针 <code>fast</code> 和 <code>slow</code>，让 <code>fast</code> 指针先向前移动 <code>n</code> 步，然后再同时移动 <code>fast</code> 和 <code>slow</code>，直到 <code>fast</code> 指向链表的末尾。此时，<code>slow</code> 刚好指向要删除节点的前一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        ListNode *fast = dummy, *slow = dummy;<br>        <span class="hljs-keyword">while</span>(n--)<br>        &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(fast-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="24、两两交换链表中的节点"><a href="#24、两两交换链表中的节点" class="headerlink" title="24、两两交换链表中的节点"></a>24、两两交换链表中的节点</h4><p><strong>题目：</strong>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>迭代、两两交换</p>
<p>我们使用了三个主要指针：</p>
<ul>
<li><code>pre</code>：表示上一个已经交换好的节点。</li>
<li><code>cur</code>：当前要交换的第一个节点。</li>
<li><code>ne</code>：当前要交换的第二个节点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)   <span class="hljs-keyword">return</span> head;<br>        <br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *pre = dummy, *cur = head, *ne = head-&gt;next;   <span class="hljs-comment">// 设置三个节点</span><br><br>        <span class="hljs-keyword">while</span>(ne != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            cur-&gt;next = ne-&gt;next;<br>            ne-&gt;next = cur;<br>            pre-&gt;next = ne;<br><br>            pre = cur;      <span class="hljs-comment">// 交换一次后，原来的cur就是下一次的pre了</span><br>            <span class="hljs-comment">// 如果 pre-&gt;next 存在（即链表中还有未处理的节点），那么将 cur 更新为下一个要处理的第一个节点，即 pre-&gt;next。</span><br>            <span class="hljs-keyword">if</span>(pre-&gt;next)   cur = pre-&gt;next;<br>            ne = cur-&gt;next; <span class="hljs-comment">// 将 ne 更新为 cur-&gt;next，即下一个要处理的第二个节点</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一样的方法，但这个代码好理解一些</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)   <span class="hljs-keyword">return</span> head;<br>        <br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode *pre = dummy;   <span class="hljs-comment">// 设置三个节点</span><br>        ListNode *cur, *ne;<br><br>        <span class="hljs-keyword">while</span>(pre-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; pre-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;   <br>            cur = pre-&gt;next;<br>            ne = cur-&gt;next;<br><br>            cur-&gt;next = ne-&gt;next;<br>            ne-&gt;next = cur;<br>            pre-&gt;next = ne;<br><br>            pre = cur;          <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="138、随机链表的复制"><a href="#138、随机链表的复制" class="headerlink" title="138、随机链表的复制"></a>138、随机链表的复制</h4><p><strong>什么是深拷贝</strong></p>
<p><strong>深拷贝</strong>是指在拷贝对象时，不仅拷贝对象本身的值，还拷贝对象包含的所有引用对象，递归地将引用对象以及引用对象内部的引用对象一并复制。这意味着，深拷贝后的新对象与原对象之间完全独立，它们不会共享任何引用的子对象或属性。</p>
<p>深拷贝的特点</p>
<ol>
<li><strong>完全独立</strong>：深拷贝会创建一个新的对象，所有属性（包括对象或容器类型的属性）都会重新创建。这使得深拷贝后的对象与原对象之间没有任何直接的联系，任何一个对象的修改都不会影响另一个对象。</li>
<li><strong>递归复制</strong>：对于包含复杂结构的对象（例如列表、字典或自定义类实例），深拷贝会递归复制每一层的对象，确保所有引用的对象都被独立复制。</li>
</ol>
<p><strong>浅拷贝（Shallow Copy）</strong>：浅拷贝只会复制对象本身，但不会递归地复制它所引用的对象。浅拷贝后的对象与原对象共享子对象。如果修改了子对象，两个对象都会受到影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    cachedNode是一个哈希表，作用是缓存原链表节点与其对应的复制节点之间的映射关系。这样可以避免在递归过程中多次创建同一个节点的副本。</span><br><span class="hljs-comment">    Key: 原链表中的节点地址。</span><br><span class="hljs-comment">	Value: 对应复制链表中的节点地址。</span><br><span class="hljs-comment">    */</span><br>    unordered_map&lt;Node*, Node*&gt; cachedNode;<br>	<br>    <span class="hljs-comment">// 它的输入是原链表的头节点 head，输出是复制链表的头节点。</span><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)<br>        &#123;	<br>          <span class="hljs-comment">// 如果当前 head 是空的（表示链表结束），直接返回 nullptr，这是递归的终止条件。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;    <br>		<br>        <span class="hljs-keyword">if</span>(!cachedNode.<span class="hljs-built_in">count</span>(head))	<span class="hljs-comment">// 检查当前节点是否已经被复制过</span><br>        &#123;<br>            Node *headNew = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cachedNode[head] = headNew;<br>            <span class="hljs-comment">// 递归复制 next 和 random 指针</span><br>            headNew-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            headNew-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cachedNode[head]; <span class="hljs-comment">// 最终返回缓存中已经创建好的当前节点 head 的副本。</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="148、排序链表"><a href="#148、排序链表" class="headerlink" title="148、排序链表"></a>148、排序链表</h4><p>用冒泡算法的话，需要先定义一个交换节点的函数，再用冒泡依次判断</p>
<p>但是这个方法，超过时间限制了，冒泡的时间复杂度为 <code>O(n^2)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapnode</span><span class="hljs-params">(ListNode* pre)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *cur = pre-&gt;next;<br>        ListNode *ne = cur-&gt;next;<br><br>        pre-&gt;next = ne;<br>        cur-&gt;next = ne-&gt;next;<br>        ne-&gt;next = cur;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> head;<br><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        ListNode *start = head;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(start != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            m++;<br>            start = start-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            ListNode *pre = dummy;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  j &lt; m - <span class="hljs-number">1</span> - i; j++)<br>            &#123;   <br>                ListNode *cur = pre-&gt;next;<br>                <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span> || cur-&gt;next == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">break</span>;<br>                ListNode *ne = cur-&gt;next;<br><br>                <span class="hljs-keyword">if</span>(cur-&gt;val &gt; ne-&gt;val)  <span class="hljs-built_in">swapnode</span>(pre);<br><br>                pre = pre-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>官方题解要求 <code>O(nlogn)</code> 需要用到归并排序</strong></p>
<p>归并需要用到三个函数</p>
<ol>
<li>快慢指针得到中间节点：其中while结束条件不好判断</li>
<li>合并两个有序链表</li>
<li>排序主函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 快慢指针 得到中间节点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getMiddle</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        <br>        ListNode *fast = dummy, *slow = dummy;<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeListNode</span><span class="hljs-params">(ListNode *l1, ListNode *l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *cur = dummy;<br><br>        ListNode *cur1 = l1, *cur2 = l2;<br><br>        <span class="hljs-keyword">while</span>(cur1 != <span class="hljs-literal">nullptr</span> &amp;&amp; cur2 != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val)<br>            &#123;<br>                cur-&gt;next = cur1;<br>                cur1 = cur1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;next = cur2;<br>                cur2 = cur2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125; <br><br>        <span class="hljs-keyword">if</span>(cur1 != <span class="hljs-literal">nullptr</span>)     cur-&gt;next = cur1;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur2 != <span class="hljs-literal">nullptr</span>)    cur-&gt;next = cur2;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> head;<br>		<span class="hljs-comment">// 1. 使用快慢指针找到链表的中间节点，并将链表一分为二</span><br>        ListNode *midnode = <span class="hljs-built_in">getMiddle</span>(head);<br>        ListNode *righthead = midnode-&gt;next;<br>        midnode-&gt;next = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// // 断开链表</span><br>		<span class="hljs-comment">// 2. 递归排序链表的两部分</span><br>        ListNode *left = <span class="hljs-built_in">sortList</span>(head);<br>        ListNode *right = <span class="hljs-built_in">sortList</span>(righthead);<br>		 <span class="hljs-comment">// 3. 合并两个有序的子链表</span><br>        head = <span class="hljs-built_in">mergeListNode</span>(left, right);<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="23、合并K个升序链表（重要）"><a href="#23、合并K个升序链表（重要）" class="headerlink" title="23、合并K个升序链表（重要）"></a>23、合并K个升序链表（重要）</h4><p><strong>题目：</strong></p>
<p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>三种方法：</strong></p>
<ol>
<li><p>顺序合并：我们可以想到一种最朴素的方法：用一个变量 <em>ans</em> 来维护以及合并的链表，第 <em>i</em> 次循环把第 <em>i</em> 个链表和 <em>ans</em> 合并，答案保存到 <em>ans</em> 中。</p>
</li>
<li><p>分治合并：将 k 个链表配对并将同一对中的链表合并；第一轮合并以后， k 个链表被合并成了 k&#x2F;2 个链表，然后是  k&#x2F;4 个链表，  k&#x2F;8  个链表等等；重复这一过程，直到我们得到了最终的有序链表。</p>
</li>
<li><p>使用优先队列合并:这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，k 个链表就最多有 k 个满足这样条件的元素，每次在这些元素里面选取 val 属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode *l1, ListNode *l2)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> l1-&gt;val &gt; l2-&gt;val;       <span class="hljs-comment">// 小顶堆</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <br>        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, compare&gt; minHeap;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> list : lists)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(list != <span class="hljs-literal">nullptr</span>)<br>                minHeap.<span class="hljs-built_in">push</span>(list);<br>        &#125;<br><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode *cur = dummy;<br><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            ListNode *tmp = minHeap.<span class="hljs-built_in">top</span>();<br>            minHeap.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(tmp-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                minHeap.<span class="hljs-built_in">push</span>(tmp-&gt;next);<br>            &#125;<br><br>            cur-&gt;next = tmp;<br>            cur = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="146、LRU缓存（重要）"><a href="#146、LRU缓存（重要）" class="headerlink" title="146、LRU缓存（重要）"></a>146、LRU缓存（重要）</h4><p><strong>什么是LRU缓存</strong></p>
<p>LRU（Least Recently Used）缓存是一种缓存淘汰策略，用于在内存受限的情况下有效地管理数据。其主要思想是，当缓存达到上限时，移除<strong>最久未使用</strong>的数据（即最近最少使用的数据），以腾出空间存放新的数据。LRU缓存特别适合那些访问频率和时间局部性较高的场景，即最近使用过的数据更有可能再次被访问。</p>
<p><strong>LRU缓存的核心概念</strong></p>
<ul>
<li><strong>缓存（Cache）</strong>：缓存是一种临时存储数据的机制，用于加速对数据的访问。缓存的大小有限，不能存储无限的数据，因此当缓存满了时，就需要一个策略来决定哪些数据应该被移除。</li>
<li><strong>最久未使用（Least Recently Used, LRU）</strong>：LRU策略的核心是移除<strong>最久没有被访问</strong>的数据，而不是简单的随机移除或移除最近添加的数据。这种策略基于一个假设：近期使用过的数据将来可能会再次使用，而很久未使用的数据可能不会再使用。</li>
</ul>
<p>LRU缓存的工作原理</p>
<ol>
<li><strong>缓存满了时的移除策略</strong>： 当缓存满了且需要添加新的数据时，LRU缓存会移除<strong>最近最少使用</strong>的数据。这意味着缓存需要记录每个数据的访问时间或顺序，并根据这些信息来决定淘汰哪一个。</li>
<li><strong>数据的访问顺序</strong>： 每次访问缓存中的数据时，都会将该数据标记为最新访问。这可以通过将数据移动到某种队列的前端来实现，从而保持数据的访问顺序。</li>
<li><strong>常用的数据结构</strong>：<ul>
<li><strong>双向链表（Doubly Linked List）</strong>：用于按访问顺序存储数据，链表头部表示最近访问的数据，尾部表示最久未访问的数据。</li>
<li><strong>哈希表（Hash Map）</strong>：用于通过键快速查找对应的缓存数据。 通过这两种数据结构的结合，LRU缓存可以在常数时间内（O(1)）完成查找、添加和删除操作。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 以 正整数 作为容量 capacity 初始化 LRU 缓存</span><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity_) &#123;<br>        capacity = capacity_;<br>    &#125;<br>    <span class="hljs-comment">// 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span>(it == cache.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            items.<span class="hljs-built_in">splice</span>(items.<span class="hljs-built_in">begin</span>(), items, it-&gt;second.second);<br>            <span class="hljs-keyword">return</span> it-&gt;second.first;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。</span><br>    <span class="hljs-comment">// 如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = cache.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span>(it != cache.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-comment">// 如果键已经存在，更新其值，并将其移到列表的前端</span><br>            it-&gt;second.first = value;<br>            items.<span class="hljs-built_in">splice</span>(items.<span class="hljs-built_in">begin</span>(), items, it-&gt;second.second);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(items.<span class="hljs-built_in">size</span>() == capacity)<br>            &#123;<br>                <span class="hljs-type">int</span> old_key = items.<span class="hljs-built_in">back</span>();<br>                items.<span class="hljs-built_in">pop_back</span>();<br>                cache.<span class="hljs-built_in">erase</span>(old_key);<br>            &#125;<br>            items.<span class="hljs-built_in">push_front</span>(key);<br>            cache[key] = &#123;value, items.<span class="hljs-built_in">begin</span>()&#125;;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 缓存容量</span><br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">// 存储键的双向链表，越靠近前端表示最近访问，靠后表示最久未使用</span><br>    list&lt;<span class="hljs-type">int</span>&gt; items;<br>    <span class="hljs-comment">// 哈希表，键是key，值是pair，pair的first是value，second是指向链表的迭代器</span><br>    <span class="hljs-comment">// 是指向双向链表中该元素的迭代器，帮助快速定位该元素在链表中的位置。</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;::iterator&gt;&gt; cache;<br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p><strong>一些解释</strong></p>
<p>splice</p>
<p><code>splice</code> 是 C++ 中 <code>std::list</code> 提供的成员函数，用于在常数时间内移动或合并链表中的元素。它允许将一个列表中的元素移动到同一个列表或不同列表的指定位置，而不会进行元素的复制或重分配。<code>splice</code> 常用于高效地处理双向链表中的元素，特别是像 LRU 缓存这样的应用场景。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将元素移到链表的前端</span><br>items.<span class="hljs-built_in">splice</span>(items.<span class="hljs-built_in">begin</span>(), items, cache[key].second);<br></code></pre></td></tr></table></figure>

<p>在这里，<code>items.begin()</code> 表示链表的头部，<code>cache[key].second</code> 是链表中要移动的元素，通过 <code>splice</code>，该元素被高效地移动到链表的头部。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="94、二叉树的中序遍历"><a href="#94、二叉树的中序遍历" class="headerlink" title="94、二叉树的中序遍历"></a>94、二叉树的中序遍历</h4><p><strong>用栈来实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> 		// 默认构造函数</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> 		// 仅接受 int 参数的构造函数</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> 		// 接受 int 和两个指针参数的构造函数</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; myStk;<br>        TreeNode *cur = root;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                myStk.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur = myStk.<span class="hljs-built_in">top</span>();<br>                myStk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;result)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">inorder</span>(root-&gt;left, result);<br>        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right, result);<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">inorder</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="104、二叉树的最大深度"><a href="#104、二叉树的最大深度" class="headerlink" title="104、二叉树的最大深度"></a>104、二叉树的最大深度</h4><p>树结构体定义</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">struct TreeNode<br>&#123;<br>	int val;<br>	TreeNode *<span class="hljs-attribute">left</span>;<br>	TreeNode *<span class="hljs-attribute">right</span>;<br>	<br>	<span class="hljs-built_in">TreeNode</span>(int x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125; <br>&#125;;<br></code></pre></td></tr></table></figure>

<p>两种方法：</p>
<ol>
<li><p>深搜</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>广搜（层序遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt;  q;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>)    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>)   q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            deep++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="226、翻转二叉树"><a href="#226、翻转二叉树" class="headerlink" title="226、翻转二叉树"></a>226、翻转二叉树</h4><p>方法1：层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; q;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode *cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-comment">// 先交换，再入队</span><br>                <span class="hljs-built_in">swap</span>(cur-&gt;left, cur-&gt;right);	<br>                <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>)    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>)   q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>方法二：递归</p>
<p>我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode *left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        TreeNode *right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br><br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="101、对称二叉树"><a href="#101、对称二叉树" class="headerlink" title="101、对称二叉树"></a>101、对称二叉树</h4><p>同样层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        queue&lt;TreeNode *&gt; myQue;<br>        myQue.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        myQue.<span class="hljs-built_in">push</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *nl = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>            TreeNode *nr = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 分四种情况讨论</span><br>            <span class="hljs-keyword">if</span>(nl == <span class="hljs-literal">NULL</span> &amp;&amp; nr == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">continue</span>;	<span class="hljs-comment">// 两个都为空</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl != <span class="hljs-literal">NULL</span> &amp;&amp; nr == <span class="hljs-literal">NULL</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 左为空，右不空</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl == <span class="hljs-literal">NULL</span> &amp;&amp; nr != <span class="hljs-literal">NULL</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 左不空，右为空</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl-&gt;val != nr-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 左右都不空，但值不一样</span><br>            <span class="hljs-comment">// 对称入队  不需要判断是是否为空</span><br>            myQue.<span class="hljs-built_in">push</span>(nl-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(nr-&gt;right);<br>            myQue.<span class="hljs-built_in">push</span>(nl-&gt;right);<br>            myQue.<span class="hljs-built_in">push</span>(nr-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p &amp;&amp; !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="hljs-built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">check</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root, root);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="543、二叉树的直径"><a href="#543、二叉树的直径" class="headerlink" title="543、二叉树的直径"></a>543、二叉树的直径</h4><p><strong>题目</strong>：</p>
<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<p>深度优先搜索方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">depth</span>(root-&gt;right);<br>        ans = <span class="hljs-built_in">max</span>(ans, l + r + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">depth</span>(root);<br><br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="102、二叉树的层序遍历（重要）"><a href="#102、二叉树的层序遍历（重要）" class="headerlink" title="102、二叉树的层序遍历（重要）"></a>102、二叉树的层序遍历（重要）</h4><p>模板，很重要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        queue&lt;TreeNode *&gt; q;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> result;<br><br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode *cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>)    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>)   q.<span class="hljs-built_in">push</span>(cur-&gt;right); <br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="108、将有序数组转换为二叉搜索树"><a href="#108、将有序数组转换为二叉搜索树" class="headerlink" title="108、将有序数组转换为二叉搜索树"></a>108、将有序数组转换为二叉搜索树</h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<p>找一个中点，左边的是他的左子树，右边的是他的右子树（因为这个数组是有序的），然后递归构架根节点，左孩子和右孩子都是返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right)    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">helper</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">helper</span>(nums, mid + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="98、验证二叉搜索树"><a href="#98、验证二叉搜索树" class="headerlink" title="98、验证二叉搜索树"></a>98、验证二叉搜索树</h4><p><strong>方法一：递归</strong></p>
<p>设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// 确定递归函数的参数和返回类型</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> lower, <span class="hljs-type">long</span> <span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function">    </span>&#123;   <br>        <span class="hljs-comment">// 确定终止条件</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 确定单层递归的逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left, lower, root-&gt;val) &amp;&amp; <span class="hljs-built_in">helper</span>(root-&gt;right, root-&gt;val, upper);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root, LONG_MIN, LONG_MAX);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>方法2：用中序遍历</p>
<p>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stack;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> inorder = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)INT_MIN - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>                stack.<span class="hljs-built_in">push</span>(root);<br>                root = root -&gt; left;<br>            &#125;<br>            root = stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br>            <span class="hljs-keyword">if</span> (root -&gt; val &lt;= inorder) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            inorder = root -&gt; val;<br>            root = root -&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<p>错误答案</p>
<p>我想的用层序遍历，每次遍历左右节点是否满足条件</p>
<p>这种方法存在一个问题，就是</p>
<p>问题主要在于它只检查了当前节点与其直接子节点之间的值关系，而没有验证整个子树是否满足二叉搜索树的条件。对于有效的二叉搜索树，左子树所有节点的值必须都小于根节点，右子树所有节点的值必须都大于根节点，而不仅仅是直接子节点。</p>
<h4 id="230、二叉搜索树中第K小的元素"><a href="#230、二叉搜索树中第K小的元素" class="headerlink" title="230、二叉搜索树中第K小的元素"></a>230、二叉搜索树中第K小的元素</h4><p>重点是前序遍历的  栈形式   实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stk;<br><br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            k--;		<span class="hljs-comment">// 重点，前序遍历了，然后选择第几个</span><br><br>            <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> root-&gt;val;<br><br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="199、二叉树的右视图"><a href="#199、二叉树的右视图" class="headerlink" title="199、二叉树的右视图"></a>199、二叉树的右视图</h4><p>深搜：要维护一个目前遍历到的最大层数</p>
<p>广搜：层序遍历输出最后的一个值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> result;<br><br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode *cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">if</span>(i == size - <span class="hljs-number">1</span>)   result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br><br>                <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>)    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span>)   q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="144、二叉树展开为链表"><a href="#144、二叉树展开为链表" class="headerlink" title="144、二叉树展开为链表"></a>144、二叉树展开为链表</h4><p>题目：</p>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<p>方法一：用数组存入节点信息，然后构建链表</p>
<p>方法二：边前序遍历，边同步进行</p>
<p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p>
<p>作者：力扣官方题解<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solutions/356853/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode *cur = root;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode *ne = cur-&gt;left;<br>                TreeNode *pre = ne;<br>                <span class="hljs-keyword">while</span>(pre-&gt;right != <span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    pre = pre-&gt;right;<br>                &#125;<br><br>                pre-&gt;right = cur-&gt;right;<br>                cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>                cur-&gt;right = ne;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="105、从前序与中序遍历序列构造二叉树"><a href="#105、从前序与中序遍历序列构造二叉树" class="headerlink" title="105、从前序与中序遍历序列构造二叉树"></a>105、从前序与中序遍历序列构造二叉树</h4><p>解题思路：</p>
<ul>
<li><strong>前序遍历</strong>：前序遍历的顺序是根节点 -&gt; 左子树 -&gt; 右子树。所以 <code>preorder</code> 的第一个元素一定是根节点。</li>
<li><strong>中序遍历</strong>：中序遍历的顺序是左子树 -&gt; 根节点 -&gt; 右子树。通过根节点，我们可以将中序遍历的序列分成左右子树的两个部分。</li>
</ul>
<p>步骤：</p>
<ol>
<li>根据前序遍历的第一个元素确定根节点。</li>
<li>在中序遍历中找到根节点的位置，这样就能确定左子树和右子树的元素。</li>
<li>递归构造左子树和右子树。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; index;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder_left &gt; preorder_right)  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span><br>        <span class="hljs-type">int</span> preorder_root = preorder_left;<br>        <span class="hljs-comment">// 在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> inorder_root = index[preorder[preorder_root]];<br><br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preorder_root]);<br>        <span class="hljs-comment">// 得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> size_left_subtree = inorder_root - inorder_left;<br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中[从 左边界+1 开始的 size_left_subtree] 个元素就对应了中序遍历中 [从 左边界 开始到 根节点定位-1] 的元素</span><br>        root-&gt;left = <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root-&gt;right = <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="hljs-number">1</span> + size_left_subtree, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            index[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h4><p>采用堆的定义，这个需要自定义比较结构体，构建大顶堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> a &lt; b;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, compare&gt; maxHeap;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)    maxHeap.<span class="hljs-built_in">push</span>(num);<br><br>        <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            maxHeap.<span class="hljs-built_in">pop</span>();<br>        &#125;    <br><br>        <span class="hljs-keyword">return</span> maxHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>











<h2 id="十进制转任意进制"><a href="#十进制转任意进制" class="headerlink" title="十进制转任意进制"></a>十进制转任意进制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 【分析】</span><br><span class="hljs-comment">//  n = …… + a * (base)^5 + b * (base)^4 + c * (base)^3 + d * (base)^2 + e * (base)^1 + f * (base)^0</span><br><span class="hljs-comment">//  若base为正数，则n也必定为非负数</span><br><span class="hljs-comment">//  若base为负数，则n可为所有整数</span><br><br><span class="hljs-comment">// 【任意base的通用写法】</span><br><span class="hljs-function">string <span class="hljs-title">baseAny</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> base)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>    string ans;<br>    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 获取当前最低位</span><br>        <span class="hljs-type">int</span> r = n % base;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>)     <span class="hljs-comment">// 说明 base 必为负数</span><br>            r -= base; <span class="hljs-comment">// 保证找到的余数在有效范围 [0, base - 1] 内</span><br>        n -= r;        <span class="hljs-comment">// 将最后一位抹零，保证后续是整除，从而保证不同语言通用</span><br>        <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">10</span>)<br>            ans += <span class="hljs-string">&#x27;A&#x27;</span> + r - <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">else</span><br>            ans += <span class="hljs-string">&#x27;0&#x27;</span> + r;<br><br>        <span class="hljs-comment">// 将n的进制表达式向右移一位</span><br>        n /= base;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>





















<h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="3-移除元素-双指针方法"><a href="#3-移除元素-双指针方法" class="headerlink" title="3.移除元素      										双指针方法"></a>3.移除元素      										双指针方法</h3><h4 id="884-比较含退格的字符串"><a href="#884-比较含退格的字符串" class="headerlink" title="884.比较含退格的字符串"></a>884.比较含退格的字符串</h4><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p>
<p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</p>
<p>若该字符为普通字符：</p>
<p>若 skip 为 0，则说明当前字符不需要删去；</p>
<p>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。</p>
<p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p>
<p>作者：力扣官方题解<br>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/">https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = s,<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)<br>        &#123;	<br>            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span>)	<span class="hljs-comment">// 处理	#</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;#&#x27;</span>)	<span class="hljs-comment">// 如果遇到 #, 计数器+1，并且跳过这个#</span><br>                &#123;<br>                    skipS++, i--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipS &gt; <span class="hljs-number">0</span>)	<span class="hljs-comment">// 如果计数器 &gt; 0，则跳过下一个字符，计数器-1 </span><br>                &#123;<br>                    skipS--, i--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(t[j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    skipT++, j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skipT &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    skipT--, j--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)	<br>                <span class="hljs-keyword">if</span>(s[i] != t[j])    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;	<span class="hljs-comment">//经过前面的处理，是没有#和删除的字符</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;	<span class="hljs-comment">// 如果两个不一样长，就k</span><br>            i--, j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-长度最小的子数组"><a href="#5-长度最小的子数组" class="headerlink" title="5. 长度最小的子数组"></a>5. 长度最小的子数组</h3><h4 id="904水果成篮-滑动区间unordered-map使用"><a href="#904水果成篮-滑动区间unordered-map使用" class="headerlink" title="904水果成篮         滑动区间		unordered_map使用"></a>904水果成篮         滑动区间		unordered_map使用</h4><p><strong>问题：</strong>怎么判断滑动区间内元素种类？		采用哈希表unordered_map来统计，或者构建数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个unordered_map，键是string类型，值是int类型</span><br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap;<br><br>    <span class="hljs-comment">// 插入元素</span><br>    myMap[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">5</span>;<br>    myMap[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">3</span>;<br>    myMap[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 查找元素</span><br>    std::string fruit = <span class="hljs-string">&quot;banana&quot;</span>;<br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">find</span>(fruit) != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;The number of &quot;</span> &lt;&lt; fruit &lt;&lt; <span class="hljs-string">&quot; is: &quot;</span> &lt;&lt; myMap[fruit] &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No information available for &quot;</span> &lt;&lt; fruit &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&quot;orange&quot;</span>);<br><br>    <span class="hljs-comment">// 遍历unordered_map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取unordered_map的长度</span><br>    cout &lt;&lt; myMap.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-螺旋数组Ⅱ"><a href="#6-螺旋数组Ⅱ" class="headerlink" title="6. 螺旋数组Ⅱ"></a>6. 螺旋数组Ⅱ</h3><h4 id="二维vector的定义"><a href="#二维vector的定义" class="headerlink" title="二维vector的定义"></a>二维vector的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;	<span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>

<h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>|| matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m * n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = left; j &lt; right; j++)   res[count++] = matrix[top][j];<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = top; i &lt;= bottom; i++)   res[count++] = matrix[i][right];<br><br>            <span class="hljs-keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = right - <span class="hljs-number">1</span>; j &gt; left; j--)   res[count++] = matrix[bottom][j];<br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = bottom; i &gt; top; i--)   res[count++] = matrix[i][left];<br>            &#125;<br><br>            left++, right--, top++, bottom--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p>
<p>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<p>使用默认构造函数初始化节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p>
<h3 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>dummyHead-&gt;next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方便后面做删除操作</span><br></code></pre></td></tr></table></figure>

<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><p><strong>双指针法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp; <span class="hljs-comment">// 保存cur的下一个节点</span><br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            temp = cur-&gt;next;  <span class="hljs-comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span><br>            cur-&gt;next = pre; <span class="hljs-comment">// 翻转操作</span><br>            <span class="hljs-comment">// 更新pre 和 cur指针</span><br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>递归法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre,ListNode* cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>        <span class="hljs-comment">// pre = cur;</span><br>        <span class="hljs-comment">// cur = temp;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur,temp);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>        <span class="hljs-comment">// ListNode* cur = head;</span><br>        <span class="hljs-comment">// ListNode* pre = NULL;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">NULL</span>, head);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>重点是推导的过程，详见代码随想录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png" srcset="/img/loading.gif" lazyload class="">



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">数组<br>set、unordered_set<br>map、unordered_<br></code></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1、KMP算法"><a href="#1、KMP算法" class="headerlink" title="1、KMP算法"></a>1、KMP算法</h3><h4 id="得到next-前缀表"><a href="#得到next-前缀表" class="headerlink" title="得到next 前缀表"></a>得到next 前缀表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/******************************** KMP伪代码 ****************************/</span><br><span class="hljs-comment">// 求 next 前缀表 数组步骤</span><br><span class="hljs-number">1</span>、初始化 <br>    <span class="hljs-comment">// 指针  i : 后缀末尾位置  j : 指向前缀末尾位置,   还代表了 当前 最长相等前后缀的长度</span><br>    j = <span class="hljs-number">0</span>, next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;&#125;<br><span class="hljs-number">2</span>、处理前后缀不同的情况<br>    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) <span class="hljs-comment">// 不等的时候，j 应该回退， 看前一位 前缀表里的值 可能会存在一直回退的情况，所以要用while </span><br>    	j = ne[j - <span class="hljs-number">1</span>];		<br><span class="hljs-number">3</span>、处理前后缀相同的情况<br>    <span class="hljs-keyword">if</span>(s[i] == s[j])  j++;		<span class="hljs-comment">// 最长相等前后缀的长度 + 1</span><br><span class="hljs-number">4</span>、更新next数组<br>    ne[i] = j;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNest</span><span class="hljs-params">(<span class="hljs-type">int</span> *ne, <span class="hljs-type">const</span> string &amp;s)</span></span><br><span class="hljs-function"></span>&#123;	<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = ne[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(s[i] == s[j])	j++;<br>        ne[i] = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用next数组做匹配"><a href="#使用next数组做匹配" class="headerlink" title="使用next数组做匹配"></a>使用next数组做匹配</h4><p>匹配过程和得到前缀和表的过程是相似的</p>
<p>在文本串s里 找是否出现过模式串t。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(needle.size())</span></span>;<br>        <span class="hljs-built_in">getNext</span>(&amp;next[<span class="hljs-number">0</span>], needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() ) &#123;<br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1、二叉树理论基础"><a href="#1、二叉树理论基础" class="headerlink" title="1、二叉树理论基础"></a>1、二叉树理论基础</h3><h4 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h4><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p>
<p><strong>满二叉树：</strong>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p><strong>完全二叉树：</strong>在完全二叉树中，除了最底层节点可能没填满外，其余<strong>每层节点数都达到最大值</strong>，并且最下面一层的节点都集中在<strong>该层最左边</strong>的若干位置。</p>
<p><strong>二叉搜索树：</strong>二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。（左  &lt;  根  &lt;  右）</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p><strong>平衡二叉树：</strong>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的<strong>高度差</strong>的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>补充： <strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p>
<h4 id="二叉树存储方式"><a href="#二叉树存储方式" class="headerlink" title="二叉树存储方式"></a>二叉树存储方式</h4><p>1、链式存储：用指针</p>
<p>2、顺序存储：用数组，<strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><ul>
<li>深度优先遍历<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p>
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<h4 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h4><p>链式存储的节点定义方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-comment">// 构造函数，初始化节点的值和子节点指针</span><br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;	<span class="hljs-comment">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这是构造函数，这么说吧C语言中的结构体是C++中类的祖先，所以C++结构体也可以有构造函数。</p>
<p>构造函数也可以不写，但是new一个新的节点的时候就比较麻烦。</p>
<p>例如有构造函数，定义初始值为9的节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">TreeNode* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure>

<p>没有构造函数的话就要这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">TreeNode* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>a-&gt;val = <span class="hljs-number">9</span>;<br>a-&gt;left = <span class="hljs-literal">NULL</span>;<br>a-&gt;right = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>



<h3 id="2、二叉树的递归遍历"><a href="#2、二叉树的递归遍历" class="headerlink" title="2、二叉树的递归遍历"></a>2、二叉树的递归遍历</h3><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>前序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>注意：由于 <code>vec</code> 是引用传递，因此对 <code>vec</code> 的任何修改都会保留，并且在递归调用中不断累积结果。</strong></p>
<h3 id="3、二叉树的迭代遍历"><a href="#3、二叉树的迭代遍历" class="headerlink" title="3、二叉树的迭代遍历"></a>3、二叉树的迭代遍历</h3><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p><strong>为什么要先加入右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br><br>        stack&lt;TreeNode *&gt; myStk;<br>        myStk.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = myStk.<span class="hljs-built_in">top</span>();<br>            myStk.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">NULL</span>)     myStk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)      myStk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><strong>再来看后序遍历，先序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">=<br><span class="hljs-keyword">class</span> Solution &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">postorderTraversal</span>(TreeNode* root) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br><br>        stack&lt;TreeNode *&gt; myStk;<br>        myStk.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = myStk.<span class="hljs-built_in">top</span>();<br>            myStk.<span class="hljs-built_in">pop</span>();<br><br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span>)      myStk.<span class="hljs-built_in">push</span>(node-&gt;left);		<span class="hljs-comment">////////</span><br>            <span class="hljs-keyword">if</span>(node-&gt;right != <span class="hljs-literal">NULL</span>)     myStk.<span class="hljs-built_in">push</span>(node-&gt;right);	<span class="hljs-comment">////////</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());			<span class="hljs-comment">//////////</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p>
<p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; myStk;<br>        TreeNode *cur = root;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> || !myStk.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                myStk.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur = myStk.<span class="hljs-built_in">top</span>();<br>                myStk.<span class="hljs-built_in">pop</span>();<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="4、二叉树的统一迭代法"><a href="#4、二叉树的统一迭代法" class="headerlink" title="4、二叉树的统一迭代法"></a>4、二叉树的统一迭代法</h3><h4 id="中旬遍历"><a href="#中旬遍历" class="headerlink" title="中旬遍历"></a>中旬遍历</h4><p><strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p>
<p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p>
<p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-comment">/*********************** 中序 ************************/</span><br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>                <br>                <span class="hljs-comment">/*********************** 前序 ************************/</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <br>                <span class="hljs-comment">/*********************** 后续 ************************/</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                <br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="5、二叉树的层序遍历"><a href="#5、二叉树的层序遍历" class="headerlink" title="5、二叉树的层序遍历"></a>5、二叉树的层序遍历</h3><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。</p>
<p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p>
<p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣102题</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        queue&lt;TreeNode *&gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> result;<br><br>        myQue.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;   <br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>                <br>                res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>                myQue.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">力扣107题</a>——二叉树的层序遍历Ⅱ</p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历</p>
<p>解：在最后反转一下数组就行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">力扣199题</a>——二叉树的右视图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        queue&lt;TreeNode *&gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root = <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;		<span class="hljs-comment">// 这里不能简写位 if(root)</span><br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;<br>                TreeNode * tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br><br>                <span class="hljs-keyword">if</span> (i == (size - <span class="hljs-number">1</span>)) result.<span class="hljs-built_in">push_back</span>(tmp-&gt;val); <span class="hljs-comment">// 将每一层的最后元素放入result数组中</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">力扣637题</a>——二叉树的层平均值</p>
<p>简单，获取到每层的数量 size 后，结点总和 sum 加起来除以 size 就行</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">力扣429题</a>——N叉树的层序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br>    <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>	&#123;<br>        Node *tmp = myQue.<span class="hljs-built_in">front</span>();<br>        myQue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; tmp-&gt;children.<span class="hljs-built_in">size</span>(); j++)<br>    	&#123;<br>        	<span class="hljs-keyword">if</span>(tmp-&gt;children[j])   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;children[j]);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>    &#125;<br>    result.<span class="hljs-built_in">push_back</span>(res);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">力扣515题</a>——在每个数行中找最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> max = INT_MIN;			<span class="hljs-comment">/////////////////// int的最小值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>    TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>    myQue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>    <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br><br>    <span class="hljs-keyword">if</span>(tmp-&gt;val &gt; max)  max = tmp-&gt;val;<br>&#125;<br>result.<span class="hljs-built_in">push_back</span>(max);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">力扣116题</a>——填充每个节点的下一个右侧节点指针</p>
<p>本题依然是层序遍历，只不过在单层遍历的时候单独处理每层最后节点，使其指向NULL，其他弹出的节点就指向队头节点</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">力扣117题</a>——填充每个节点的下一个右侧节点指针Ⅱ</p>
<p>跟上一题一样</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣104题</a>——二叉树的最大深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>            deep++;   <span class="hljs-comment">//////////////////////////////////////</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣111题</a>——二叉树的最小深度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            deep++;   <span class="hljs-comment">//////////////////////////////////////</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; tmp-&gt;right == <span class="hljs-literal">NULL</span>) <br>                    <span class="hljs-keyword">return</span> deep; <span class="hljs-comment">//////</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="6、翻转二叉树"><a href="#6、翻转二叉树" class="headerlink" title="6、翻转二叉树"></a>6、翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">力扣226题</a></p>
<p>想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。</p>
<p>关键在于遍历顺序，前中后序应该选哪一种遍历顺序？</p>
<p>遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。</p>
<p><strong>注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果</strong></p>
<p><strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong></p>
<p>那么层序遍历可以不可以呢？<strong>依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！</strong></p>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><h5 id="深度优先遍历（看不太懂）"><a href="#深度优先遍历（看不太懂）" class="headerlink" title="深度优先遍历（看不太懂）"></a>深度优先遍历（看不太懂）</h5><p>C++代码迭代法（前序遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>统一格式的迭代法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);          <span class="hljs-comment">// 节点处理逻辑</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h5><p>也就是层序遍历，层数遍历也是可以翻转这棵树的，因为层序遍历也可以把每个节点的左右孩子都翻转一遍，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 节点处理		///////</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p><span style="color: red; font-weight: bold;"><strong>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</strong></span></p>
<h3 id="7、周末总结"><a href="#7、周末总结" class="headerlink" title="7、周末总结"></a>7、周末总结</h3><h3 id="8、对称二叉树"><a href="#8、对称二叉树" class="headerlink" title="8、对称二叉树"></a>8、对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">力扣101题</a></p>
<p><strong>首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！</strong></p>
<p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p>
<p>那么遍历的顺序应该是什么样的呢？</p>
<p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p>
<p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p>
<p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p>
<p>其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。</p>
<h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><h5 id="1）确定递归函数的参数和返回值"><a href="#1）确定递归函数的参数和返回值" class="headerlink" title="1）确定递归函数的参数和返回值"></a>1）确定递归函数的参数和返回值</h5><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span><br></code></pre></td></tr></table></figure>

<h5 id="2）确定终止条件"><a href="#2）确定终止条件" class="headerlink" title="2）确定终止条件"></a>2）确定终止条件</h5><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p>
<p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 注意这里我没有使用else</span><br></code></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
<h5 id="3）确定单层递归的逻辑"><a href="#3）确定单层递归的逻辑" class="headerlink" title="3）确定单层递归的逻辑"></a>3）确定单层递归的逻辑</h5><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br><span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br><span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中（逻辑处理）</span><br><span class="hljs-keyword">return</span> isSame;<br></code></pre></td></tr></table></figure>

<p>如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。</p>
<p>最后递归的C++整体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right); <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);  <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;       <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><p>这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。</p>
<p>这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（<strong>注意这不是层序遍历</strong>）</p>
<p><strong>使用队列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    queue&lt;TreeNode *&gt; myQue;<br>    myQue.<span class="hljs-built_in">push</span>(root-&gt;left);<br>    myQue.<span class="hljs-built_in">push</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        TreeNode *nl = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>        TreeNode *nr = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">if</span>(nl == <span class="hljs-literal">NULL</span> &amp;&amp; nr == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl != <span class="hljs-literal">NULL</span> &amp;&amp; nr == <span class="hljs-literal">NULL</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl == <span class="hljs-literal">NULL</span> &amp;&amp; nr != <span class="hljs-literal">NULL</span>)   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nl-&gt;val != nr-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        myQue.<span class="hljs-built_in">push</span>(nl-&gt;left);<br>        myQue.<span class="hljs-built_in">push</span>(nr-&gt;right);<br>        myQue.<span class="hljs-built_in">push</span>(nl-&gt;right);<br>        myQue.<span class="hljs-built_in">push</span>(nr-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用栈</strong></p>
<p>细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。</p>
<p>只要把队列原封不动的改成栈就可以了，我下面也给出了代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; st; <span class="hljs-comment">// 这里改成了栈</span><br>        st.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        st.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* rightNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            TreeNode* leftNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;left);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">力扣100题</a>——相同的树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt;   myQue;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        myQue.<span class="hljs-built_in">push</span>(p);<br>        myQue.<span class="hljs-built_in">push</span>(q);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *np = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>            TreeNode *nq = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(!np &amp;&amp; !nq)  <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span>(!np || !nq || (np-&gt;val != nq-&gt;val))  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;right);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">力扣572题</a>——另一棵树的子树</p>
<p>这道题在 <strong>相同的树</strong> 的基础上就很好做了，遍历原来树的每一个节点，与子树判断是否是相同的树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> &amp;&amp; subRoot == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        queue&lt;TreeNode *&gt; myQue;<br><br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>            myQue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSameTree</span>(tmp, subRoot))    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>            <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>        &#125;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        queue&lt;TreeNode *&gt;   myQue;<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        myQue.<span class="hljs-built_in">push</span>(p);<br>        myQue.<span class="hljs-built_in">push</span>(q);<br><br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *np = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br>            TreeNode *nq = myQue.<span class="hljs-built_in">front</span>();   myQue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">if</span>(!np &amp;&amp; !nq)  <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span>(!np || !nq || (np-&gt;val != nq-&gt;val))  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;left);<br>            myQue.<span class="hljs-built_in">push</span>(np-&gt;right);<br>            myQue.<span class="hljs-built_in">push</span>(nq-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="9、二叉树的最大深度"><a href="#9、二叉树的最大深度" class="headerlink" title="9、二叉树的最大深度"></a>9、二叉树的最大深度</h3><p>前面做过的，层序遍历，遍历了有多少层，深度就是多少</p>
<h4 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣559题</a>——N叉树的最大深度</p>
<p>包含了N叉树的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        queue&lt;Node* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                Node *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; tmp-&gt;children.<span class="hljs-built_in">size</span>(); j++)<br>                    <span class="hljs-keyword">if</span>(tmp-&gt;children[j])   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;children[j]);<br>            &#125;<br>            deep++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="10、二叉树的最小深度"><a href="#10、二叉树的最小深度" class="headerlink" title="10、二叉树的最小深度"></a>10、二叉树的最小深度</h3><p>这个也是前面做过的，</p>
<p>思路：只要判断出了一个节点的左右节点都为空，就是他的最小深度，即返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; myQue;<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        myQue.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-type">int</span> deep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!myQue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = myQue.<span class="hljs-built_in">size</span>();<br>            deep++;   <span class="hljs-comment">//////////////////////////////////////</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>            &#123;   <br>                TreeNode *tmp = myQue.<span class="hljs-built_in">front</span>();<br>                myQue.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; tmp-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> deep;  <span class="hljs-comment">///////////</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;left)   myQue.<span class="hljs-built_in">push</span>(tmp-&gt;left);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right)  myQue.<span class="hljs-built_in">push</span>(tmp-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> deep;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="11、完全三叉树的节点个数"><a href="#11、完全三叉树的节点个数" class="headerlink" title="11、完全三叉树的节点个数"></a>11、完全三叉树的节点个数</h3><h4 id="普通二叉树的做法"><a href="#普通二叉树的做法" class="headerlink" title="普通二叉树的做法"></a>普通二叉树的做法</h4><p>迭代：层序遍历</p>
<p>低轨：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">![完全二叉树](刷题笔记/完全二叉树.png)<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bianl</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftnum = <span class="hljs-built_in">bianl</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightnum = <span class="hljs-built_in">bianl</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> total = leftnum + rightnum + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-built_in">bianl</span>(root);<br>        <br>        <span class="hljs-keyword">return</span> num;<br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点</p>
<img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" srcset="/img/loading.gif" lazyload class="">

<p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
<p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p>
<p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p>
<h5 id="第二部-终止条件"><a href="#第二部-终止条件" class="headerlink" title="第二部 终止条件"></a>第二部 终止条件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><span class="hljs-comment">// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树</span><br>TreeNode* left = root-&gt;left;<br>TreeNode* right = root-&gt;right;<br><span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br><span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>    left = left-&gt;left;<br>    leftDepth++;<br>&#125;<br><span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>    right = right-&gt;right;<br>    rightDepth++;<br>&#125;<br><span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，返回满足满二叉树的子树节点数量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="第三步-单层递归的逻辑"><a href="#第三步-单层递归的逻辑" class="headerlink" title="第三步 单层递归的逻辑"></a>第三步 单层递归的逻辑</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> leftTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;left);       <span class="hljs-comment">// 左</span><br><span class="hljs-type">int</span> rightTreeNum = <span class="hljs-built_in">countNodes</span>(root-&gt;right);     <span class="hljs-comment">// 右</span><br><span class="hljs-type">int</span> result = leftTreeNum + rightTreeNum + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure>

<p>精简后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>; 		<br></code></pre></td></tr></table></figure>

<h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>        <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>            left = left-&gt;left;<br>            leftDepth++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>            right = right-&gt;right;<br>            rightDepth++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload class="">

<h3 id="1、理论基础"><a href="#1、理论基础" class="headerlink" title="1、理论基础"></a>1、理论基础</h3><h4 id="1）什么是回溯"><a href="#1）什么是回溯" class="headerlink" title="1）什么是回溯"></a>1）什么是回溯</h4><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p><strong>所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数</strong>。</p>
<h4 id="2）回溯法的效率"><a href="#2）回溯法的效率" class="headerlink" title="2）回溯法的效率"></a>2）回溯法的效率</h4><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<h4 id="3）回溯法解决的问题"><a href="#3）回溯法解决的问题" class="headerlink" title="3）回溯法解决的问题"></a>3）回溯法解决的问题</h4><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<h4 id="4）如何理解回溯法"><a href="#4）如何理解回溯法" class="headerlink" title="4）如何理解回溯法"></a>4）如何理解回溯法</h4><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</p>
<p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。</p>
<p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p>
<h4 id="5）回溯法模板"><a href="#5）回溯法模板" class="headerlink" title="5）回溯法模板"></a>5）回溯法模板</h4><p><strong>回溯的三部曲</strong></p>
<ul>
<li><p>回溯函数模板返回值以及参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>回溯函数终止条件</p>
<p>既然是树形结构，那么我们在讲解<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p>
<p>所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (终止条件) &#123;<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>回溯搜索的遍历过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure>

<p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p>
<p>backtracking这里自己调用自己，实现递归。</p>
<p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
</li>
</ul>
<p>​	分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、组合问题"><a href="#2、组合问题" class="headerlink" title="2、组合问题"></a>2、组合问题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">力扣77题</a>——组合</p>
<img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload class="">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == k)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(res);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt;= n - (k - res.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(i + <span class="hljs-number">1</span>, n, k);<br>            res.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>       <span class="hljs-built_in">backtracking</span>(<span class="hljs-number">1</span>, n, k);<br>       <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="3、组合优化"><a href="#3、组合优化" class="headerlink" title="3、组合优化"></a>3、组合优化</h3><img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%89%AA%E6%9E%9D%E4%BC%98%E5%8C%96.png" srcset="/img/loading.gif" lazyload class="">

<h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p>
<p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
<p>接下来看一下优化过程如下：</p>
<ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li>
</ol>
<p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p>
<p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p>
<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p>
<p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p>
<p>所以优化之后的for循环是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++) <span class="hljs-comment">// i为本次搜索的起始位置</span><br></code></pre></td></tr></table></figure>

<h3 id="4、组合总和Ⅲ"><a href="#4、组合总和Ⅲ" class="headerlink" title="4、组合总和Ⅲ"></a>4、组合总和Ⅲ</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">力扣216题</a>——组合总和Ⅲ</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;	<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        if(path.size() == k &amp;&amp; sum == n)	// 这样写会出错， 因为这不能同时判断</span><br><span class="hljs-comment">        &#123;   					// 不管sum 是否等于 0，  只要位数到了，就要返回</span><br><span class="hljs-comment">            result.push_back(path);				</span><br><span class="hljs-comment">            return ;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)<br>        &#123;   <br>            <span class="hljs-keyword">if</span>(sum == n)<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            sum += i;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k, i + <span class="hljs-number">1</span>, sum);<br>            sum -= i;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="5、电话号码的字符组合"><a href="#5、电话号码的字符组合" class="headerlink" title="5、电话号码的字符组合"></a>5、电话号码的字符组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣17题</a>——电话号码的字母组合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//                 我的代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; result;<br><br>    string numToChar[<span class="hljs-number">8</span>] = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> string&amp; digits, string str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">size</span>() == n)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numToChar[digits[str.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">2</span>].<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            str += numToChar[digits[str.<span class="hljs-built_in">size</span>()] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">2</span>][i];<br>            <span class="hljs-built_in">backtracking</span>(n, digits, str);<br>            str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = digits.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> result;<br><br>        <span class="hljs-built_in">backtracking</span>(n, digits, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>        <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/********************************  代码随想录  *******************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">&quot;wxyz&quot;</span>, <span class="hljs-comment">// 9</span><br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; result;<br>    string s;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; digits, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> digit = digits[index] - <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-comment">// 将index指向的数字转为int</span><br>        string letters = letterMap[digit];      <span class="hljs-comment">// 取数字对应的字符集</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letters.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            s.<span class="hljs-built_in">push_back</span>(letters[i]);            <span class="hljs-comment">// 处理  ///////////////////</span><br>            <span class="hljs-built_in">backtracking</span>(digits, index + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 递归，注意index+1，一下层要处理下一个数字了</span><br>            s.<span class="hljs-built_in">pop_back</span>();                       <span class="hljs-comment">// 回溯		///////////////</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        s.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="6、周总结"><a href="#6、周总结" class="headerlink" title="6、周总结"></a>6、周总结</h3><p><strong>回溯是递归的副产品，只要有递归就会有回溯</strong>。</p>
<p>回溯法就是暴力搜索，并不是什么高效的算法，最多在剪枝一下。</p>
<p>回溯算法能解决如下问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>本题我把回溯问题抽象为树形结构，可以直观的看出其搜索的过程：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong></p>
<p><strong>for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了</strong>。</p>
<p>回溯法抽象为树形结构后，其遍历过程就是：<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong>。</p>
<h3 id="7、组合总和"><a href="#7、组合总和" class="headerlink" title="7、组合总和"></a>7、组合总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">力扣39题</a>——组合总和</p>
<p>这道题的难点在于，回溯得出所有结果后，对同一个数字具有相同个数的结果进行去重操作</p>
<p>比如说[2,2,3]和[2,3,2] 这是同一个结果，但是回溯，都不能识别为同一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/********************************  我的代码  *******************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">const</span> <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum &gt;= target)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum == target)<br>            &#123;<br>                <span class="hljs-built_in">sort</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>                res.<span class="hljs-built_in">insert</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = res.<span class="hljs-built_in">begin</span>(); it != res.<span class="hljs-built_in">end</span>(); ++it)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(*it);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">我的代码中，使用了 std::set 来存储结果以去重，这虽然有效，但效率可能不高。而且你期望的输出与实际输出不同的原因在于，每次递归都从头开始遍历 candidates，这可能导致重复组合。我们可以通过引入递归中的索引限制，确保组合是非递减顺序，从而避免重复组合。</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>

<p>上面这个是错误代码，不能通过测试用例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/********************************  代码随想录  *******************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sum == target)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum == target)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>		<span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = idx; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)<br>        &#123;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-comment">// // 不用i+1了，表示可以重复读取当前的  //////////// 重点， 重复取就是 i， </span><br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i);<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());	  <span class="hljs-comment">// 需要排序</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="8、组合总和Ⅱ"><a href="#8、组合总和Ⅱ" class="headerlink" title="8、组合总和Ⅱ"></a>8、组合总和Ⅱ</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">力扣39题</a>——组合总和Ⅱ</p>
<p><strong>本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。</p>
<p>一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！</p>
<p>所以要在搜索的过程中就去掉重复组合。</p>
<p>这个去重为什么很难理解呢，<strong>所谓去重，其实就是使用过的元素不能重复选取。</strong> 这么一说好像很简单！</p>
<p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p>
<p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p>
<p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p>
<p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p>
<p>为了理解去重我们来举一个例子，candidates &#x3D; [1, 1, 2], target &#x3D; 3，（方便起见candidates已经排序了）</p>
<p><strong>强调一下，树层去重的话，需要对数组排序！</strong></p>
<img src="/2024/07/10/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1.png" srcset="/img/loading.gif" lazyload class="">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;<br>            <span class="hljs-comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span><br>            <span class="hljs-comment">// 要对同一树层使用过的元素进行跳过</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i + <span class="hljs-number">1</span>, used); <span class="hljs-comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h3 id="15、全排列"><a href="#15、全排列" class="headerlink" title="15、全排列"></a>15、全排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">力扣46题</a>——全排列</p>
<p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。但排列问题需要一个used数组，标记已经选择的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*********************************  我的代码   *********************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracing</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;st)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-literal">false</span>)<br>            &#123;   <br>                st[i] = <span class="hljs-literal">true</span>;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">backtracing</span>(nums, st);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                st[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracing</span>(nums, st);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*********************************  代码随想录   *********************************/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span> </span>&#123;<br>        <span class="hljs-comment">// 此时说明找到了一组</span><br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>大家此时可以感受出排列问题的不同：</p>
<ul>
<li>每层都是从0开始搜索而不是startIndex</li>
<li>需要used数组记录path里都放了哪些元素</li>
</ul>
<h3 id="21、解数独"><a href="#21、解数独" class="headerlink" title="21、解数独"></a>21、解数独</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">力扣37题</a>——解数独</p>
<h4 id="回溯三部曲"><a href="#回溯三部曲" class="headerlink" title="回溯三部曲"></a>回溯三部曲</h4><ul>
<li>递归函数以及参数</li>
</ul>
<p><strong>递归函数的返回值需要是bool类型，为什么呢？</strong></p>
<p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回， 相当于找根节点到叶子节点一条唯一路径，所以需要使用<code>bool</code>返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>递归终止条件</li>
</ul>
<p>本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。（因为只有一个结果？）</p>
<p><strong>不用终止条件会不会死循环？</strong></p>
<p>递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！</p>
<p>我们需要的是一个二维的递归 （一行一列）</p>
<p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p>
<p><strong>二维递归？</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                    board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                    board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                           <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意这里return false的地方，这里放return false 是有讲究的</strong>。</p>
<p>因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</p>
<p>那么会直接返回， <strong>这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！</strong></p>
<h4 id="判断棋盘是否合法"><a href="#判断棋盘是否合法" class="headerlink" title="判断棋盘是否合法"></a>判断棋盘是否合法</h4><p>判断棋盘是否合法有如下三个维度：</p>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9宫格里是否重复</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123; <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-comment">// 遍历行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123; <span class="hljs-comment">// 遍历列</span><br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>; k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; k++) &#123;     <span class="hljs-comment">// (i, j) 这个位置放k是否合适</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(i, j, k, board)) &#123;<br>                        board[i][j] = k;                <span class="hljs-comment">// 放置k</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">backtracking</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果找到合适一组立刻返回</span><br>                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;              <span class="hljs-comment">// 回溯，撤销k</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 9个数都试完了，都不行，那么就返回false</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历完没有返回false，说明找到了合适棋盘位置了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 判断行里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[row][i] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123; <span class="hljs-comment">// 判断列里是否重复</span><br>        <span class="hljs-keyword">if</span> (board[j][col] == val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> startRow = (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> startCol = (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// 判断9方格里是否重复</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == val ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtracking</span>(board);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="1、贪心的理论基础"><a href="#1、贪心的理论基础" class="headerlink" title="1、贪心的理论基础"></a>1、贪心的理论基础</h3><h4 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h4><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<h4 id="贪心一半解题步骤"><a href="#贪心一半解题步骤" class="headerlink" title="贪心一半解题步骤"></a>贪心一半解题步骤</h4><ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3 id="2、分发饼干"><a href="#2、分发饼干" class="headerlink" title="2、分发饼干"></a>2、分发饼干</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">力扣455题</a>——分发饼干</p>
<p><strong>思路</strong></p>
<p>为了满足更多的小孩，就不要造成饼干尺寸的浪费。</p>
<p>大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。</p>
<p><strong>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<p>可以尝试使用贪心策略，先将饼干数组和小孩数组排序。</p>
<p>然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;		<span class="hljs-comment">// 用 index 表示了未分发的饼干x</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)		<span class="hljs-comment">// 这里采用了反向遍历小孩的胃口值</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i])<br>            &#123;<br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



















<h1 id="基础数据结构和算法"><a href="#基础数据结构和算法" class="headerlink" title="基础数据结构和算法"></a>基础数据结构和算法</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1、堆"><a href="#1、堆" class="headerlink" title="1、堆"></a>1、堆</h3><p>[参考视频](【【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AF411G7cA?vd_source=8cc270f687a3e8776461d428d0e05aa9">https://www.bilibili.com/video/BV1AF411G7cA?vd_source=8cc270f687a3e8776461d428d0e05aa9</a>)</p>
<h3 id="2、红黑树与AVL树"><a href="#2、红黑树与AVL树" class="headerlink" title="2、红黑树与AVL树"></a>2、红黑树与AVL树</h3><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是一种自平衡的二叉搜索树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。</p>
<p>通过对任何一条从根到叶子的路径上的路径上各个节点着色方式的限制，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡</p>
<p>红黑树是一种弱平衡二叉树，相对于要求严格的 <code>AVL</code> 树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。</p>
<p><strong>性质</strong></p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点是黑的；</li>
<li>每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的；</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的</li>
<li>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点</li>
</ol>
<h4 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h4><p>红黑树是在AVL树的基础上提出来的</p>
<p>平衡二叉树又称AVL树，是一种特殊的二叉排序树</p>
<p>其左右子树都是平衡二叉树，且左右子树高度只差不超过1</p>
<p><strong>红黑树较AVL树的优点</strong></p>
<p><code>AVL</code> 树是高度自平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降</p>
<p>红黑树不是高度自平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。</p>
<p>所以红黑树在查找，插入删除的性能都是 <code>O(logn)</code> ，且性能稳定，所以STL里面很多结构包括 <code>set、map</code> 底层实现都是使用的红黑树。</p>
<h3 id="3、字典树（Trie树）"><a href="#3、字典树（Trie树）" class="headerlink" title="3、字典树（Trie树）"></a>3、字典树（Trie树）</h3><p>性质：</p>
<ol>
<li>根节点不保存字符，每个节点保存一个字符</li>
<li>从根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串</li>
<li>每个节点的所有子节点包含的字符都不相同</li>
</ol>
<p>应用：统计，排序，保存大量字符串</p>
<p>优点：利用字符的公共前缀减少查询时间，最大限度的减少无谓的字符串比较</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h3><h5 id="快速排序——基于分治（nlogn）"><a href="#快速排序——基于分治（nlogn）" class="headerlink" title="快速排序——基于分治（nlogn）"></a>快速排序——基于分治（<code>nlogn</code>）</h5><p><strong>快速排序的基本思想</strong></p>
<p>1、确定分界点   2、调整区间	3、低轨处理左右两端	</p>
<ol>
<li>确定分界点：最好取中间的元素，第一个和最后一个元素也可以</li>
<li>调整区间：通过一次排序将数组分为了两个部分，一半比分界点小，另一半比分界点大</li>
<li>低轨处理左右两端：低轨处理分界点左右两边的子数据进行快速排序</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(l &gt;= r)	<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br>        <span class="hljs-keyword">if</span>(i &lt; j)	<span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick</span>(q, l, j);<br>    <span class="hljs-built_in">quick</span>(q, j + l, r);<br>    <span class="hljs-comment">//也可以改成i，quick_sort(q, l, i-1);  quick_sort(q, i, r);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优势</strong></p>
<ol>
<li>时间效率高：平均比其他 <code>O(nlogn)</code>算法（归并、堆排序）更快</li>
<li><strong>原地排序</strong>：快速排序不需要额外的存储空间，适合处理大数据集</li>
<li>广泛应用：常用于各种场景中排序操作的实现（标准函数库实现）</li>
</ol>
<p><strong>劣势</strong></p>
<p>最坏情况退化为 <code>O(n^2)</code>:在特俗情况下（选择的分界点总是最大值或最小值），性能会退化</p>
<p>快速排序不稳定：快速排序不是稳定排序，元素相等时，元素的相对位置可能会改变。</p>
<h5 id="归并排序——基于分治（nlogn）"><a href="#归并排序——基于分治（nlogn）" class="headerlink" title="归并排序——基于分治（nlogn）"></a>归并排序——基于分治（<code>nlogn</code>）</h5><p><strong>归并排序的基本思想</strong></p>
<p>1、以数组中间为分界点 mid &#x3D; (left + right) &#x2F; 2	2、低轨排序left和right	3、归并——合二为一</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(l &gt;= r)	<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">mergeSort</span>(q, l, mid);<br>    <span class="hljs-built_in">mergeSort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, r = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 合并两个有序数组</span><br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j])<br>            tmp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span><br>            tmp[k++] = q[j++];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid)	tmp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r)	tmp[k++] = q[j++];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++)	q[i] = tmp[j]; <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ol>
<li>稳定性：归并排序是稳定的排序算法，即相等元素的相对顺序不会改变</li>
<li>时间复杂度良好：无论数据的初始状态，始终为 <code>O(nlogn)</code></li>
<li>适用于大数据：对外部存储排序时，因为他是个稳定的线性时间排序算法</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>空间复杂度高：需要额外 <code>O(n)</code> 的空间</p>
</li>
<li><p>在小规模数据上效率不如快速排序</p>
</li>
</ol>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>刷题笔记</div>
      <div>https://zy674517173.github.io/2024/07/10/刷题笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>张同学</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/11/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0TCP/" title="从零实现TCP">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">从零实现TCP</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/06/02/MyWebServer/" title="MyWebServer">
                        <span class="hidden-mobile">MyWebServer</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
